diff -ruN trilinos-11.4.3-clean/packages/amesos/CMakeLists.txt trilinos-11.4.3/packages/amesos/CMakeLists.txt
--- trilinos-11.4.3-clean/packages/amesos/CMakeLists.txt	2014-02-06 15:46:10.000000000 -0700
+++ trilinos-11.4.3/packages/amesos/CMakeLists.txt	2014-02-06 15:48:40.000000000 -0700
@@ -12,10 +12,15 @@
 # B) Set up package-specific options
 #
 
+#
+# TMA: We can actually build SuperLU_Dist without ParMETIS per a recent Tech-X
+# change made with the help of Sherry Li.
+#
+
 # if using SuperLUDist, must also link in ParMETIS for some reason
-IF(${PACKAGE_NAME}_ENABLE_SuperLUDist AND NOT ${PACKAGE_NAME}_ENABLE_ParMETIS)
-  MESSAGE(FATAL_ERROR "The Amesos support for the SuperLUIDist TPL requires the ParMETIS TPL.  Either disable Amesos SuperLUDist support or enable the ParMETIS TPL.")
-ENDIF()
+#IF(${PACKAGE_NAME}_ENABLE_SuperLUDist AND NOT ${PACKAGE_NAME}_ENABLE_ParMETIS)
+#  MESSAGE(FATAL_ERROR "The Amesos support for the SuperLUIDist TPL requires the ParMETIS TPL.  Either disable Amesos SuperLUDist support or enable the ParMETIS TPL.")
+#ENDIF()
 
 # if using parallel MUMPS, must also link in scalapack and BLACS
 
diff -ruN trilinos-11.4.3-clean/packages/amesos/CMakeLists.txt.rej trilinos-11.4.3/packages/amesos/CMakeLists.txt.rej
--- trilinos-11.4.3-clean/packages/amesos/CMakeLists.txt.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/amesos/CMakeLists.txt.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,21 @@
+--- packages/amesos/CMakeLists.txt	2013-11-04 12:26:37.000000000 -0700
++++ packages/amesos/CMakeLists.txt	2014-01-09 21:22:55.685993200 -0700
+@@ -12,10 +12,15 @@
+ # B) Set up package-specific options
+ #
+ 
++#
++# TMA: We can actually build SuperLU_Dist without ParMETIS per a recent Tech-X
++# change made with the help of Sherry Li.
++#
++
+ # if using SuperLUDist, must also link in ParMETIS for some reason
+-IF(${PACKAGE_NAME}_ENABLE_SuperLUDist AND NOT ${PACKAGE_NAME}_ENABLE_ParMETIS)
+-  MESSAGE(FATAL_ERROR "The Amesos support for the SuperLUIDist TPL requires the ParMETIS TPL.  Either disable Amesos SuperLUDist support or enable the ParMETIS TPL.")
+-ENDIF()
++#IF(${PACKAGE_NAME}_ENABLE_SuperLUDist AND NOT ${PACKAGE_NAME}_ENABLE_ParMETIS)
++#  MESSAGE(FATAL_ERROR "The Amesos support for the SuperLUIDist TPL requires the ParMETIS TPL.  Either disable Amesos SuperLUDist support or enable the ParMETIS TPL.")
++#ENDIF()
+ 
+ # if using parallel MUMPS, must also link in scalapack and BLACS
+ 
diff -ruN trilinos-11.4.3-clean/packages/amesos/src/Amesos_Superludist.h.orig trilinos-11.4.3/packages/amesos/src/Amesos_Superludist.h.orig
--- trilinos-11.4.3-clean/packages/amesos/src/Amesos_Superludist.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/amesos/src/Amesos_Superludist.h.orig	2013-11-21 13:12:56.000000000 -0700
@@ -0,0 +1,221 @@
+// @HEADER
+// ***********************************************************************
+// 
+//                Amesos: Direct Sparse Solver Package
+//                 Copyright (2004) Sandia Corporation
+// 
+// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
+// license for use of this work by or on behalf of the U.S. Government.
+// 
+// This library is free software; you can redistribute it and/or modify
+// it under the terms of the GNU Lesser General Public License as
+// published by the Free Software Foundation; either version 2.1 of the
+// License, or (at your option) any later version.
+//  
+// This library is distributed in the hope that it will be useful, but
+// WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//  
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA
+// Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
+// 
+// ***********************************************************************
+// @HEADER
+
+#ifndef AMESOS_SUPERLUDIST_H
+#define AMESOS_SUPERLUDIST_H
+
+#include "Amesos_ConfigDefs.h"
+#include "Amesos_BaseSolver.h"
+#include "Amesos_NoCopiable.h"
+#include "Amesos_Utils.h"
+#include "Amesos_Time.h"
+#include "Amesos_Status.h"
+#include "Amesos_Control.h"
+#include "Epetra_LinearProblem.h"
+#include "Teuchos_RCP.hpp"
+#ifdef EPETRA_MPI
+#include "Epetra_MpiComm.h"
+#else
+#include "Epetra_Comm.h"
+#endif
+
+
+// Amesos_Superludist_Pimpl contains a pointer to structures defined in 
+// superlu_ddefs.h.  This prevents Amesos_Superludist.h 
+// from having to include superludist.h.
+//
+//  Doxygen does not handle forward class references well.
+#ifndef DOXYGEN_SHOULD_SKIP_THIS
+class Amesos_Superlu_Pimpl ; 
+#endif
+
+
+//! Amesos_Superludist:  An object-oriented wrapper for Superludist.
+/*!  Amesos_Superludist will solve a linear systems of equations: <TT>A X = B</TT>
+   using Epetra objects and the Superludist solver library, where
+  <TT>A</TT> is an Epetra_RowMatrix and <TT>X</TT> and <TT>B</TT> are 
+  Epetra_MultiVector objects.
+*/
+class Amesos_Superludist: public Amesos_BaseSolver,
+                          private Amesos_Time,
+                          private Amesos_NoCopiable,
+                          private Amesos_Utils,
+                          private Amesos_Control,
+                          private Amesos_Status 
+{
+
+public: 
+
+  //@{ \name Constructor methods
+  //! Amesos_Superludist Constructor.
+  /*! Creates an Amesos_Superludist instance, using an Epetra_LinearProblem,
+      passing in an already-defined Epetra_LinearProblem object. 
+
+      Note: The operator in LinearProblem must be an
+      Epetra_RowMatrix.
+
+  */
+  Amesos_Superludist(const Epetra_LinearProblem& LinearProblem);
+
+  //! Amesos_Superludist Destructor.
+  /*! Completely deletes an Amesos_Superludist object.  
+  */  ~Amesos_Superludist(void);
+  //@}
+
+  //@{ \name Mathematical functions.
+
+  int SymbolicFactorization() ;
+
+  int NumericFactorization() ;
+
+  int Solve();
+
+
+  //@}
+  //@{ \name Attribute set methods
+  
+  //!  Amesos_Superludist does not support transpose at this time.
+  /*!  returns 0 if UseTranspose is set to false, else 1 (failure)
+   */
+  int SetUseTranspose(bool UseTranspose) { return( UseTranspose?1:0 );};
+
+  //@}
+  //@{ \name Attribute access functions
+
+  const Epetra_LinearProblem *GetProblem() const { return(Problem_); };
+
+  //! Returns true if SUPERLUDIST can handle this matrix shape 
+  /*! Returns true if the matrix shape is one that SUPERLUDIST can
+    handle. SUPERLUDIST only works with square matrices.  
+  */
+  bool MatrixShapeOK() const;
+
+  //! Always returns false. Superludist doesn't support transpose solve
+  bool UseTranspose() const {return(false);};
+  //@}
+
+  int SetParameters( Teuchos::ParameterList &ParameterList ) ;
+
+  //! Returns the number of symbolic factorizations performed by this object.
+  int NumSymbolicFact() const { return( Amesos_Status::NumSymbolicFact_ ); }
+
+  //! Returns the number of numeric factorizations performed by this object.
+  int NumNumericFact() const { return( Amesos_Status::NumNumericFact_ ); }
+
+  //! Returns the number of solves performed by this object.
+  int NumSolve() const { return( Amesos_Status::NumSolve_ ); }
+
+  //! Print various timig.
+  void PrintTiming() const;
+  
+  //! Print various information about the parameters used by Superludist.
+  void PrintStatus() const;
+
+  //! Extracts timing information from the current solver and places it in the parameter list.
+  void GetTiming( Teuchos::ParameterList &TimingParameterList ) const { Amesos_Time::GetTiming(TimingParameterList); }
+  
+private:  
+  inline const Epetra_Comm& Comm() const {return(GetProblem()->GetOperator()->Comm());};
+
+  inline const Epetra_Import& Importer() const
+  {
+    return(*(Importer_.get()));
+  }
+
+  inline const Epetra_Map& UniformMap() const
+  {
+    return(*(UniformMap_.get()));
+  }
+
+  inline const Epetra_RowMatrix& UniformMatrix() const
+  {
+    return(*(UniformMatrix_.get()));
+  }
+
+  inline Epetra_CrsMatrix& CrsUniformMatrix()
+  {
+    return(*(CrsUniformMatrix_.get()));
+  }
+
+  //
+  //  PrivateSuperluData_ contains pointers to data needed by klu whose
+  //  data structures are defined by klu.h
+  //
+  Teuchos::RCP<Amesos_Superlu_Pimpl> PrivateSuperluData_; 
+
+  int RedistributeA();
+
+  int ReFactor();
+  int Factor();
+  
+  const Epetra_LinearProblem* Problem_;
+  Epetra_RowMatrix *RowMatrixA_ ;  // Problem_->GetOperator()
+
+  RCP<Epetra_Map> UniformMap_;
+  RCP<Epetra_CrsMatrix> CrsUniformMatrix_;  
+  RCP<Epetra_RowMatrix> UniformMatrix_;  
+  Teuchos::RCP<Epetra_Import> Importer_;
+
+  //! Allows FactOption to be used on subsequent calls to pdgssvx from NumericFactorization
+  bool ReuseSymbolic_; 
+  //! redistribute the input matrix prior to calling Superludist
+  bool Redistribute_ ; 
+
+  //! \c true if the SuperLU_DIST's grid has been created (and has to be free'd)
+  int GridCreated_ ; 
+  int FactorizationDone_ ; 
+  //! \c true if NumericFactorization() has been successfully called.
+  bool FactorizationOK_ ;
+
+  //! Global dimension of the matrix.
+  int NumGlobalRows_; 
+
+  // Ap, Ai, Aval form the compressed row storage used by SuperLU_DIST
+  std::vector <int> Ap_;
+  std::vector <int> Ai_;
+  std::vector <double> Aval_;
+  //! Contains the global ID of local columns.
+  int* Global_Columns_;
+
+  int nprow_;
+  int npcol_;
+
+  bool PrintNonzeros_;
+  std::string ColPerm_;
+  std::string RowPerm_;
+  int* perm_c_;
+  int* perm_r_;
+  std::string IterRefine_;
+  bool ReplaceTinyPivot_;
+  bool Equil_;
+
+  int MtxConvTime_, MtxRedistTime_, VecRedistTime_;
+  int NumFactTime_, SolveTime_, OverheadTime_;
+ 
+};  // End of  class Amesos_Superludist  
+#endif /* AMESOS_SUPERLUDIST_H */
diff -ruN trilinos-11.4.3-clean/packages/amesos/src/Amesos_Superludist.h.rej trilinos-11.4.3/packages/amesos/src/Amesos_Superludist.h.rej
--- trilinos-11.4.3-clean/packages/amesos/src/Amesos_Superludist.h.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/amesos/src/Amesos_Superludist.h.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,13 @@
+--- packages/amesos/src/Amesos_Superludist.h	2013-11-04 12:26:38.000000000 -0700
++++ packages/amesos/src/Amesos_Superludist.h	2014-01-09 21:22:56.185199600 -0700
+@@ -115,8 +115,8 @@
+   */
+   bool MatrixShapeOK() const;
+ 
+-  //! Always returns true.
+-  bool UseTranspose() const {return(true);};
++  //! Always returns false.
++  bool UseTranspose() const {return(false);};
+   //@}
+ 
+   int SetParameters( Teuchos::ParameterList &ParameterList ) ;
diff -ruN trilinos-11.4.3-clean/packages/ifpack/src/Ifpack_ICT.cpp trilinos-11.4.3/packages/ifpack/src/Ifpack_ICT.cpp
--- trilinos-11.4.3-clean/packages/ifpack/src/Ifpack_ICT.cpp	2014-02-06 15:46:18.000000000 -0700
+++ trilinos-11.4.3/packages/ifpack/src/Ifpack_ICT.cpp	2014-02-06 15:48:50.000000000 -0700
@@ -40,6 +40,7 @@
 //@HEADER
 */
 
+#include <functional>
 #include "Ifpack_ConfigDefs.h"
 #include "Ifpack_Preconditioner.h"
 #include "Ifpack_ICT.h"
diff -ruN trilinos-11.4.3-clean/packages/ifpack/src/Ifpack_ICT.cpp.orig trilinos-11.4.3/packages/ifpack/src/Ifpack_ICT.cpp.orig
--- trilinos-11.4.3-clean/packages/ifpack/src/Ifpack_ICT.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ifpack/src/Ifpack_ICT.cpp.orig	2013-11-21 13:11:43.000000000 -0700
@@ -0,0 +1,529 @@
+/*@HEADER
+// ***********************************************************************
+//
+//       Ifpack: Object-Oriented Algebraic Preconditioner Package
+//                 Copyright (2002) Sandia Corporation
+//
+// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
+// license for use of this work by or on behalf of the U.S. Government.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// 1. Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the Corporation nor the names of the
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Questions? Contact Michael A. Heroux (maherou@sandia.gov)
+//
+// ***********************************************************************
+//@HEADER
+*/
+
+#include "Ifpack_ConfigDefs.h"
+#include "Ifpack_Preconditioner.h"
+#include "Ifpack_ICT.h"
+#include "Ifpack_Condest.h"
+#include "Ifpack_Utils.h"
+#include "Ifpack_HashTable.h"
+#include "Epetra_SerialComm.h"
+#include "Epetra_Comm.h"
+#include "Epetra_Map.h"
+#include "Epetra_RowMatrix.h"
+#include "Epetra_CrsMatrix.h"
+#include "Epetra_Vector.h"
+#include "Epetra_MultiVector.h"
+#include "Epetra_Util.h"
+#include "Teuchos_ParameterList.hpp"
+#include "Teuchos_RefCountPtr.hpp"
+#include <functional>
+
+//==============================================================================
+// FIXME: allocate Comm_ and Time_ the first Initialize() call
+Ifpack_ICT::Ifpack_ICT(const Epetra_RowMatrix* A) :
+  A_(*A),
+  Comm_(A_.Comm()),
+  Condest_(-1.0),
+  Athresh_(0.0),
+  Rthresh_(1.0),
+  LevelOfFill_(1.0),
+  DropTolerance_(0.0),
+  Relax_(0.0),
+  IsInitialized_(false),
+  IsComputed_(false),
+  UseTranspose_(false),
+  NumMyRows_(0),
+  NumInitialize_(0),
+  NumCompute_(0),
+  NumApplyInverse_(0),
+  InitializeTime_(0.0),
+  ComputeTime_(0.0),
+  ApplyInverseTime_(0.0),
+  ComputeFlops_(0.0),
+  ApplyInverseFlops_(0.0),
+  Time_(Comm()),
+  GlobalNonzeros_(0)
+{
+  // do nothing here
+}
+
+//==============================================================================
+Ifpack_ICT::~Ifpack_ICT()
+{
+  Destroy();
+}
+
+//==============================================================================
+void Ifpack_ICT::Destroy()
+{
+  IsInitialized_ = false;
+  IsComputed_ = false;
+}
+
+//==========================================================================
+int Ifpack_ICT::SetParameters(Teuchos::ParameterList& List)
+{
+
+  try
+  {
+    LevelOfFill_ = List.get("fact: ict level-of-fill",LevelOfFill_);
+    Athresh_ = List.get("fact: absolute threshold", Athresh_);
+    Rthresh_ = List.get("fact: relative threshold", Rthresh_);
+    Relax_ = List.get("fact: relax value", Relax_);
+    DropTolerance_ = List.get("fact: drop tolerance", DropTolerance_);
+
+    // set label
+    Label_ = "ICT (fill=" + Ifpack_toString(LevelOfFill())
+      + ", athr=" + Ifpack_toString(AbsoluteThreshold()) 
+      + ", rthr=" + Ifpack_toString(RelativeThreshold())
+      + ", relax=" + Ifpack_toString(RelaxValue())
+      + ", droptol=" + Ifpack_toString(DropTolerance())
+      + ")";
+
+    return(0);
+  }
+  catch (...)
+  {
+    cerr << "Caught an exception while parsing the parameter list" << endl;
+    cerr << "This typically means that a parameter was set with the" << endl;
+    cerr << "wrong type (for example, int instead of double). " << endl;
+    cerr << "please check the documentation for the type required by each parameer." << endl;
+    IFPACK_CHK_ERR(-1);
+  }
+}
+
+//==========================================================================
+int Ifpack_ICT::Initialize()
+{
+  // clean data if present
+  Destroy();
+
+  Time_.ResetStartTime();
+
+  // matrix must be square. Check only on one processor
+  if (Comm().NumProc() == 1 && Matrix().NumMyRows() != Matrix().NumMyCols())
+    IFPACK_CHK_ERR(-2);
+    
+  NumMyRows_ = Matrix().NumMyRows();
+
+  // nothing else to do here
+  IsInitialized_ = true;
+  ++NumInitialize_;
+  InitializeTime_ += Time_.ElapsedTime();
+
+  return(0);
+}
+
+//==========================================================================
+int Ifpack_ICT::Compute() 
+{
+  if (!IsInitialized()) 
+    IFPACK_CHK_ERR(Initialize());
+
+  Time_.ResetStartTime();
+  IsComputed_ = false;
+
+  NumMyRows_ = A_.NumMyRows();
+  int Length = A_.MaxNumEntries();
+  vector<int>    RowIndices(Length);
+  vector<double> RowValues(Length);
+
+  bool distributed = (Comm().NumProc() > 1)?true:false;
+
+  if (distributed)
+  {
+    SerialComm_ = Teuchos::rcp(new Epetra_SerialComm);
+    SerialMap_ = Teuchos::rcp(new Epetra_Map(NumMyRows_, 0, *SerialComm_));
+    assert (SerialComm_.get() != 0);
+    assert (SerialMap_.get() != 0);
+  }
+  else
+    SerialMap_ = Teuchos::rcp(const_cast<Epetra_Map*>(&A_.RowMatrixRowMap()), false);
+
+  int RowNnz;
+#ifdef IFPACK_FLOPCOUNTERS
+  double flops = 0.0;
+#endif
+
+  H_ = Teuchos::rcp(new Epetra_CrsMatrix(Copy,*SerialMap_,0));
+  if (H_.get() == 0)
+    IFPACK_CHK_ERR(-5); // memory allocation error
+
+  // get A(0,0) element and insert it (after sqrt)
+  IFPACK_CHK_ERR(A_.ExtractMyRowCopy(0,Length,RowNnz,
+                                     &RowValues[0],&RowIndices[0]));
+
+  // skip off-processor elements
+  if (distributed)
+  {
+    int count = 0;
+    for (int i = 0 ;i < RowNnz ; ++i) 
+    {
+      if (RowIndices[i] < NumMyRows_){
+        RowIndices[count] = RowIndices[i];
+        RowValues[count] = RowValues[i];
+        ++count;
+      }
+      else
+        continue;
+    }
+    RowNnz = count;
+  }
+
+  // modify diagonal
+  double diag_val = 0.0;
+  for (int i = 0 ;i < RowNnz ; ++i) {
+    if (RowIndices[i] == 0) {
+      double& v = RowValues[i];
+      diag_val = AbsoluteThreshold() * EPETRA_SGN(v) +
+        RelativeThreshold() * v;
+      break;
+    }
+  }
+
+  diag_val = sqrt(diag_val);
+  int diag_idx = 0;
+  EPETRA_CHK_ERR(H_->InsertGlobalValues(0,1,&diag_val, &diag_idx));
+
+  // The 10 is just a small constant to limit collisons as the actual keys
+  // we store are the indices and not integers
+  // [0..A_.MaxNumEntries()*LevelofFill()].
+  Ifpack_HashTable Hash( 10 * A_.MaxNumEntries() * LevelOfFill(), 1);
+
+  // start factorization for line 1
+  for (int row_i = 1 ; row_i < NumMyRows_ ; ++row_i) {
+
+    // get row `row_i' of the matrix
+    IFPACK_CHK_ERR(A_.ExtractMyRowCopy(row_i,Length,RowNnz,
+                                       &RowValues[0],&RowIndices[0]));
+
+    // skip off-processor elements
+    if (distributed)
+    {
+      int count = 0;
+      for (int i = 0 ;i < RowNnz ; ++i) 
+      {
+        if (RowIndices[i] < NumMyRows_){
+          RowIndices[count] = RowIndices[i];
+          RowValues[count] = RowValues[i];
+          ++count;
+        }
+        else
+          continue;
+      }
+      RowNnz = count;
+    }
+
+    // number of nonzeros in this row are defined as the nonzeros
+    // of the matrix, plus the level of fill 
+    int LOF = (int)(LevelOfFill() * RowNnz);
+    if (LOF == 0) LOF = 1;
+
+    // convert line `row_i' into hash for fast access
+    Hash.reset();
+
+    double h_ii = 0.0;
+    for (int i = 0 ; i < RowNnz ; ++i) {
+      if (RowIndices[i] == row_i) {
+        double& v = RowValues[i];
+        h_ii = AbsoluteThreshold() * EPETRA_SGN(v) + RelativeThreshold() * v;
+      }
+      else if (RowIndices[i] < row_i)
+      {
+        Hash.set(RowIndices[i], RowValues[i], true);
+      }
+    }
+      
+    // form element (row_i, col_j)
+    // I start from the first row that has a nonzero column
+    // index in row_i.
+    for (int col_j = RowIndices[0] ; col_j < row_i ; ++col_j) {
+
+      double h_ij = 0.0, h_jj = 0.0;
+      // note: get() returns 0.0 if col_j is not found
+      h_ij = Hash.get(col_j);
+
+      // get pointers to row `col_j'
+      int* ColIndices;
+      double* ColValues;
+      int ColNnz;
+      H_->ExtractGlobalRowView(col_j, ColNnz, ColValues, ColIndices);
+
+      for (int k = 0 ; k < ColNnz ; ++k) {
+        int col_k = ColIndices[k];
+
+        if (col_k == col_j)
+          h_jj = ColValues[k];
+        else {
+          double xxx = Hash.get(col_k);
+          if (xxx != 0.0)
+          {
+            h_ij -= ColValues[k] * xxx;
+#ifdef IFPACK_FLOPCOUNTERS
+            flops += 2.0;
+#endif
+          }
+        }
+      }
+
+      h_ij /= h_jj;
+
+      if (IFPACK_ABS(h_ij) > DropTolerance_)
+      {
+        Hash.set(col_j, h_ij);
+      }
+    
+#ifdef IFPACK_FLOPCOUNTERS
+      // only approx
+      ComputeFlops_ += 2.0 * flops + 1.0;
+#endif
+    }
+
+    int size = Hash.getNumEntries();
+
+    vector<double> AbsRow(size);
+    int count = 0;
+    
+    // +1 because I use the extra position for diagonal in insert
+    vector<int> keys(size + 1);
+    vector<double> values(size + 1);
+
+    Hash.arrayify(&keys[0], &values[0]);
+
+    for (int i = 0 ; i < size ; ++i)
+    {
+      AbsRow[i] = IFPACK_ABS(values[i]);
+    }
+    count = size;
+
+    double cutoff = 0.0;
+    if (count > LOF) {
+      nth_element(AbsRow.begin(), AbsRow.begin() + LOF, AbsRow.begin() + count, 
+
+		  std::greater<double>());
+      cutoff = AbsRow[LOF];
+    }
+
+    for (int i = 0 ; i < size ; ++i)
+    {
+      h_ii -= values[i] * values[i];
+    }
+
+    if (h_ii < 0.0) h_ii = 1e-12;;
+
+    h_ii = sqrt(h_ii);
+
+#ifdef IFPACK_FLOPCOUNTERS
+    // only approx, + 1 == sqrt
+    ComputeFlops_ += 2 * size + 1;
+#endif
+
+    double DiscardedElements = 0.0;
+
+    count = 0;
+    for (int i = 0 ; i < size ; ++i)    
+    { 
+      if (IFPACK_ABS(values[i]) > cutoff)
+      {
+        values[count] = values[i];
+        keys[count] = keys[i];
+        ++count;
+      }
+      else  
+        DiscardedElements += values[i];
+    }
+
+    if (RelaxValue() != 0.0) {
+      DiscardedElements *= RelaxValue();
+      h_ii += DiscardedElements;
+    }
+
+    values[count] = h_ii;
+    keys[count] = row_i;
+    ++count;
+
+    H_->InsertGlobalValues(row_i, count, &(values[0]), (int*)&(keys[0]));
+  }
+
+  IFPACK_CHK_ERR(H_->FillComplete());
+
+#if 0
+  // to check the complete factorization
+  Epetra_Vector LHS(Matrix().RowMatrixRowMap());
+  Epetra_Vector RHS1(Matrix().RowMatrixRowMap());
+  Epetra_Vector RHS2(Matrix().RowMatrixRowMap());
+  Epetra_Vector RHS3(Matrix().RowMatrixRowMap());
+  LHS.Random();
+
+  Matrix().Multiply(false,LHS,RHS1);
+  H_->Multiply(true,LHS,RHS2);
+  H_->Multiply(false,RHS2,RHS3);
+
+  RHS1.Update(-1.0, RHS3, 1.0);
+  cout << endl;
+  cout << RHS1;
+#endif
+  int MyNonzeros = H_->NumGlobalNonzeros();
+  Comm().SumAll(&MyNonzeros, &GlobalNonzeros_, 1);
+
+  IsComputed_ = true;
+#ifdef IFPACK_FLOPCOUNTERS
+  double TotalFlops; // sum across all the processors
+  A_.Comm().SumAll(&flops, &TotalFlops, 1);
+  ComputeFlops_ += TotalFlops;
+#endif
+  ++NumCompute_;
+  ComputeTime_ += Time_.ElapsedTime();
+
+  return(0);
+
+}
+
+//=============================================================================
+int Ifpack_ICT::ApplyInverse(const Epetra_MultiVector& X, 
+			     Epetra_MultiVector& Y) const
+{
+
+  if (!IsComputed())
+    IFPACK_CHK_ERR(-3); // compute preconditioner first
+
+  if (X.NumVectors() != Y.NumVectors()) 
+    IFPACK_CHK_ERR(-2); // Return error: X and Y not the same size
+
+  Time_.ResetStartTime();
+
+  // AztecOO gives X and Y pointing to the same memory location,
+  // need to create an auxiliary vector, Xcopy
+  Teuchos::RefCountPtr<const Epetra_MultiVector> Xcopy;
+  if (X.Pointers()[0] == Y.Pointers()[0])
+    Xcopy = Teuchos::rcp( new Epetra_MultiVector(X) );
+  else
+    Xcopy = Teuchos::rcp( &X, false );
+
+  // NOTE: H_ is based on SerialMap_, while Xcopy is based
+  // on A.Map()... which are in general different. However, Solve()
+  // does not seem to care... which is fine with me.
+  //
+  EPETRA_CHK_ERR(H_->Solve(false,false,false,*Xcopy,Y));
+  EPETRA_CHK_ERR(H_->Solve(false,true,false,Y,Y));
+
+#ifdef IFPACK_FLOPCOUNTERS
+  // these are global flop count
+  ApplyInverseFlops_ += 4.0 * GlobalNonzeros_;
+#endif
+
+  ++NumApplyInverse_;
+  ApplyInverseTime_ += Time_.ElapsedTime();
+
+  return(0);
+}
+//=============================================================================
+// This function finds X such that LDU Y = X or U(trans) D L(trans) Y = X for multiple RHS
+int Ifpack_ICT::Apply(const Epetra_MultiVector& X, 
+		      Epetra_MultiVector& Y) const 
+{
+
+  IFPACK_CHK_ERR(-98);
+}
+
+//=============================================================================
+double Ifpack_ICT::Condest(const Ifpack_CondestType CT, 
+                            const int MaxIters, const double Tol,
+			    Epetra_RowMatrix* Matrix_in)
+{
+  if (!IsComputed()) // cannot compute right now
+    return(-1.0);
+
+  // NOTE: this is computing the *local* condest
+  if (Condest_ == -1.0)
+    Condest_ = Ifpack_Condest(*this, CT, MaxIters, Tol, Matrix_in);
+
+  return(Condest_);
+}
+
+//=============================================================================
+std::ostream&
+Ifpack_ICT::Print(std::ostream& os) const
+{
+  if (!Comm().MyPID()) {
+    os << endl;
+    os << "================================================================================" << endl;
+    os << "Ifpack_ICT: " << Label() << endl << endl;
+    os << "Level-of-fill      = " << LevelOfFill() << endl;
+    os << "Absolute threshold = " << AbsoluteThreshold() << endl;
+    os << "Relative threshold = " << RelativeThreshold() << endl;
+    os << "Relax value        = " << RelaxValue() << endl;
+    os << "Condition number estimate = " << Condest() << endl;
+    os << "Global number of rows            = " << Matrix().NumGlobalRows() << endl;
+    if (IsComputed_) {
+      os << "Number of nonzeros of H         = " << H_->NumGlobalNonzeros() << endl;
+      os << "nonzeros / rows                 = " 
+         << 1.0 * H_->NumGlobalNonzeros() / H_->NumGlobalRows() << endl;
+    }
+    os << endl;
+    os << "Phase           # calls   Total Time (s)       Total MFlops     MFlops/s" << endl;
+    os << "-----           -------   --------------       ------------     --------" << endl;
+    os << "Initialize()    "   << std::setw(5) << NumInitialize() 
+       << "  " << std::setw(15) << InitializeTime() 
+       << "               0.0            0.0" << endl;
+    os << "Compute()       "   << std::setw(5) << NumCompute() 
+       << "  " << std::setw(15) << ComputeTime()
+       << "  " << std::setw(15) << 1.0e-6 * ComputeFlops();
+    if (ComputeTime() != 0.0) 
+      os << "  " << std::setw(15) << 1.0e-6 * ComputeFlops() / ComputeTime() << endl;
+    else
+      os << "  " << std::setw(15) << 0.0 << endl;
+    os << "ApplyInverse()  "   << std::setw(5) << NumApplyInverse() 
+       << "  " << std::setw(15) << ApplyInverseTime()
+       << "  " << std::setw(15) << 1.0e-6 * ApplyInverseFlops();
+    if (ApplyInverseTime() != 0.0)
+      os << "  " << std::setw(15) << 1.0e-6 * ApplyInverseFlops() / ApplyInverseTime() << endl;
+    else
+      os << "  " << std::setw(15) << 0.0 << endl;
+    os << "================================================================================" << endl;
+    os << endl;
+  }
+
+  
+  return(os);
+}
diff -ruN trilinos-11.4.3-clean/packages/ifpack/src/Ifpack_ICT.cpp.rej trilinos-11.4.3/packages/ifpack/src/Ifpack_ICT.cpp.rej
--- trilinos-11.4.3-clean/packages/ifpack/src/Ifpack_ICT.cpp.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ifpack/src/Ifpack_ICT.cpp.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,11 @@
+--- packages/ifpack/src/Ifpack_ICT.cpp	2013-11-04 12:26:55.000000000 -0700
++++ packages/ifpack/src/Ifpack_ICT.cpp	2014-01-09 21:23:16.605861400 -0700
+@@ -328,7 +329,7 @@
+     double cutoff = 0.0;
+     if (count > LOF) {
+       nth_element(AbsRow.begin(), AbsRow.begin() + LOF, AbsRow.begin() + count, 
+-                  greater<double>());
++                  std::greater<double>());
+       cutoff = AbsRow[LOF];
+     }
+ 
diff -ruN trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_MultiVector.h trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_MultiVector.h
--- trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_MultiVector.h	2014-02-06 15:46:27.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_MultiVector.h	2014-02-06 15:48:40.000000000 -0700
@@ -15,6 +15,7 @@
 /* person and disclaimer.                                               */        
 /* ******************************************************************** */
 
+#include <functional>
 //#include "ml_lapack.h"
 #include "MLAPI_Error.h"
 #include "MLAPI_BaseObject.h"
diff -ruN trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_MultiVector.h.rej trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_MultiVector.h.rej
--- trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_MultiVector.h.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_MultiVector.h.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,10 @@
+--- packages/ml/src/MLAPI/MLAPI_MultiVector.h	2013-11-04 12:27:10.000000000 -0700
++++ packages/ml/src/MLAPI/MLAPI_MultiVector.h	2014-01-09 21:23:38.477341800 -0700
+@@ -15,6 +15,7 @@
+ /* person and disclaimer.                                               */        
+ /* ******************************************************************** */
+ 
++#include <functional>
+ //#include "ml_lapack.h"
+ #include "MLAPI_Error.h"
+ #include "MLAPI_BaseObject.h"
diff -ruN trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_Workspace.cpp trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_Workspace.cpp
--- trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_Workspace.cpp	2014-02-06 15:46:27.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_Workspace.cpp	2014-02-06 15:48:40.000000000 -0700
@@ -13,8 +13,10 @@
 #endif
 #include "MLAPI_Error.h"
 #include "MLAPI_Workspace.h"
-#ifdef _MSC_VER
-#include "winprocess.h"
+#if defined(_MSC_VER)
+# include "winprocess.h"
+#elif defined(__MINGW32__)
+# include "windows.h"
 #endif
 
 namespace MLAPI {
@@ -119,8 +121,10 @@
 #endif
         printf("%s\n",buf);
         fflush(stdout);
-#ifdef ICL
+#if defined(ICL)
         Sleep(1);
+#elif defined(__MINGW32__)
+        Sleep(1000.);  // Windows sleep is in milliseconds
 #else
         sleep(1);
 #endif
diff -ruN trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_Workspace.cpp.rej trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_Workspace.cpp.rej
--- trilinos-11.4.3-clean/packages/ml/src/MLAPI/MLAPI_Workspace.cpp.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/MLAPI/MLAPI_Workspace.cpp.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,27 @@
+--- packages/ml/src/MLAPI/MLAPI_Workspace.cpp	2013-11-04 12:27:10.000000000 -0700
++++ packages/ml/src/MLAPI/MLAPI_Workspace.cpp	2014-01-09 21:23:38.508542200 -0700
+@@ -13,8 +13,10 @@
+ #endif
+ #include "MLAPI_Error.h"
+ #include "MLAPI_Workspace.h"
+-#ifdef _MSC_VER
+-#include "winprocess.h"
++#if defined(_MSC_VER)
++# include "winprocess.h"
++#elif defined(__MINGW32__)
++# include "windows.h"
+ #endif
+ 
+ namespace MLAPI {
+@@ -119,8 +121,10 @@
+ #endif
+         printf("%s\n",buf);
+         fflush(stdout);
+-#ifdef ICL
++#if defined(ICL)
+         Sleep(1);
++#elif defined(__MINGW32__)
++        Sleep(1000.);  // Windows sleep is in milliseconds
+ #else
+         sleep(1);
+ #endif
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_epetra_utils.cpp trilinos-11.4.3/packages/ml/src/Utils/ml_epetra_utils.cpp
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_epetra_utils.cpp	2014-02-06 15:46:27.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_epetra_utils.cpp	2014-02-06 15:48:40.000000000 -0700
@@ -40,8 +40,10 @@
 #include "Teuchos_Array.hpp"
 #include "Teuchos_ParameterList.hpp"
 #endif
-#ifdef _MSC_VER
+#if defined(_MSC_VER)
 # include "winprocess.h"
+#elif defined(__MINGW32__)
+# include "windows.h"
 #endif
 
 #ifdef HAVE_ML_TEUCHOS
@@ -3539,6 +3541,11 @@
       if (i == Comm.MyPID() ) {
 #if defined(TFLOP) || defined(JANUS_STLPORT) || defined(COUGAR)
     sprintf(buf, "Host: %s   PID: %d", "janus", getpid());
+#elif defined(__MINGW32__)
+// getpid not present for mingw
+    sprintf(buf, "Host: %s   PID: %d", "mingw32", 0);
+#elif defined(_MSC_VER)
+    sprintf(buf, "Host: %s   PID: %d", "msvc", getpid());
 #else
     gethostname(hostname, sizeof(hostname));
     int pid = getpid();
@@ -3547,8 +3554,10 @@
 #endif
     printf("%s\n",buf);
     fflush(stdout);
-#ifdef ICL
+#if defined(ICL)
     Sleep(1);
+#elif defined(__MINGW32__)
+    Sleep(1000.);  // Windows sleep is in milliseconds
 #else
     sleep(1);
 #endif
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_epetra_utils.cpp.orig trilinos-11.4.3/packages/ml/src/Utils/ml_epetra_utils.cpp.orig
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_epetra_utils.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_epetra_utils.cpp.orig	2013-11-21 13:12:26.000000000 -0700
@@ -0,0 +1,3790 @@
+/* ******************************************************************** */
+/* See the file COPYRIGHT for a complete copyright notice, contact      */
+/* person and disclaimer.                                               */
+/* ******************************************************************** */
+
+/************************************************************************/
+/*          Utilities for Trilinos/ML users                             */
+/*----------------------------------------------------------------------*/
+/* Authors : Mike Heroux   (SNL)                                        */
+/*           Jonathan Hu   (SNL)                                        */
+/*           Ray Tuminaro  (SNL)                                        */
+/*           Marzio Sala   (SNL)                                        */
+/*           Michael Gee   (SNL)                                        */
+/*           Chris Siefert (SNL)                                        */
+/************************************************************************/
+
+#include "ml_common.h"
+
+#ifdef ML_WITH_EPETRA
+#include <vector>
+#include "ml_epetra.h"
+#include "ml_epetra_utils.h"
+#include "Epetra_Map.h"
+#include "Epetra_IntVector.h"
+#include "Epetra_Vector.h"
+#include "Epetra_CrsGraph.h"
+#include "Epetra_FECrsMatrix.h"
+#include "Epetra_VbrMatrix.h"
+#include "Epetra_SerialDenseMatrix.h"
+#include "Epetra_Import.h"
+#include "Epetra_Export.h"
+#include "Epetra_Time.h"
+#ifdef ML_MPI
+#include "Epetra_MpiComm.h"
+#else
+#include "Epetra_SerialComm.h"
+#endif
+#include "ml_FilterType.h"
+#ifdef HAVE_ML_TEUCHOS
+#include "Teuchos_Array.hpp"
+#include "Teuchos_ParameterList.hpp"
+#endif
+#ifdef _MSC_VER
+# include "winprocess.h"
+#endif
+
+#ifdef HAVE_ML_TEUCHOS
+using namespace Teuchos;
+#endif
+
+
+// ====================================================================== 
+
+typedef struct {
+  ML_Epetra::FilterType Type;
+  double AThresh;
+  double RThresh;
+  double FirstDivider;
+  double SecondDivider;
+  int Eqns;
+  double* Mask;
+} ML_Filter_Data;
+
+static ML_Filter_Data Filter_;
+
+// ======================================================================
+// Epetra_ML_GetCrsDataptrs() extracts the raw data pointers from an
+// Epetra_CrsMatrix that is wrapped as an ML_Operator.  Return code is 0
+// if successful, [-5,...,-1] otherwise.
+// ======================================================================
+
+int Epetra_ML_GetCrsDataptrs(ML_Operator *mlA, double **values, int **cols,
+                             int **rowptr)
+{
+  *values = NULL;
+  *cols   = NULL;
+  *rowptr = NULL;
+
+  if ( (mlA->matvec->func_ptr != ML_Epetra_matvec) &&
+       (mlA->matvec->func_ptr != ML_Epetra_CrsMatrix_matvec)) return -1;
+
+  // First check the type field of the ML_Operator.  The ML_Operator may have
+  // already been dynamically cast to an Epetra_CrsMatrix for efficiency
+  // reasons, so immediately casting (void *) data to an Epetra_RowMatrix*
+  // is potentially fatal.
+  Epetra_RowMatrix *A = 0;
+  Epetra_CrsMatrix * CrsA=0;
+  int ierr = 0;
+  switch (mlA->type) {
+
+    case ML_TYPE_CRS_MATRIX:
+      CrsA = (Epetra_CrsMatrix *) ML_Get_MyMatvecData(mlA);
+      if (CrsA == 0) ierr = -2;
+      if (CrsA && !CrsA->StorageOptimized()) ierr = -5;
+      break;
+
+    case ML_TYPE_ROW_MATRIX:
+      A = (Epetra_RowMatrix *) ML_Get_MyMatvecData(mlA);
+      CrsA = dynamic_cast<Epetra_CrsMatrix *>(A);
+      if (CrsA == 0) ierr = -3;
+      if (CrsA && !CrsA->StorageOptimized()) ierr = -5;
+      break;
+
+    case ML_TYPE_UNKNOWN:
+    default:
+      ierr = -4;
+      break;
+  } //switch
+
+
+  if (ierr == 0)
+     return(CrsA->ExtractCrsDataPointers(*rowptr, *cols, *values));
+  else
+     return ierr;
+} //Epetra_ML_GetCrsDataptrs()
+
+int ML_Epetra_matvec(ML_Operator *data, int in, double *p, int out, double *ap)
+{
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+  /* ML matvec wrapper for Epetra matrices. */
+
+  // general case
+  Epetra_RowMatrix *A = (Epetra_RowMatrix *) ML_Get_MyMatvecData(mat_in);
+
+  // for VBR matrices first
+  Epetra_VbrMatrix * VbrA = NULL;
+  VbrA = dynamic_cast<Epetra_VbrMatrix *>(A);
+
+  if( VbrA != NULL ) {
+    Epetra_Vector X(View, VbrA->DomainMap(), p);
+    Epetra_Vector Y(View, VbrA->RangeMap(), ap);
+    VbrA->Multiply(false, X, Y);
+  } else {   
+    Epetra_Vector X(View, A->OperatorDomainMap(), p);
+    Epetra_Vector Y(View, A->OperatorRangeMap(), ap);
+  
+    A->Multiply(false, X, Y);
+  }
+
+  return 1;
+}
+
+// ====================================================================== 
+
+int ML_Epetra_CrsMatrix_matvec(ML_Operator *data, int in, double *p,
+                                                  int out, double *ap)
+{
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+  /* ML matvec wrapper for Epetra matrices. */
+
+  Epetra_CrsMatrix *A = (Epetra_CrsMatrix *) ML_Get_MyMatvecData(mat_in);
+
+  Epetra_Vector X(View, A->OperatorDomainMap(), p);
+  Epetra_Vector Y(View, A->OperatorRangeMap(), ap);
+  
+#ifndef ML_MODIFIED_EPETRA_CRS_MATVEC
+  A->Multiply(false, X, Y);
+#else
+  // to use this feature, you must modify Epetra's CSR matvec to time
+  // communication and computation separately.  I've included the
+  // modified method in a comment at the bottom of this file.
+  double apply_only_time, total_time;
+  A->Multiply(false, X, Y, &apply_only_time, &total_time);
+  mat_in->apply_without_comm_time += apply_only_time;
+  mat_in->apply_time += total_time;
+#endif
+
+  return 1;
+}
+
+// ====================================================================== 
+
+int ML_Epetra_VbrMatrix_matvec(ML_Operator *data, int in, double *p,
+                                                  int out, double *ap)
+{
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+  /* ML matvec wrapper for Epetra matrices. */
+
+  Epetra_VbrMatrix *A = (Epetra_VbrMatrix *) ML_Get_MyMatvecData(mat_in);
+
+  Epetra_Vector X(View, A->DomainMap(), p);
+  Epetra_Vector Y(View, A->RangeMap(), ap);
+  A->Multiply(false, X, Y);
+
+  return 1;
+}
+
+// ====================================================================== 
+
+int ML_Epetra_matvec_Filter(ML_Operator *mat_in, int in, double *p, 
+                            int out, double *ap)
+{
+  Epetra_RowMatrix *A = (Epetra_RowMatrix *) ML_Get_MyMatvecData(mat_in);
+  int NumMyRows = A->NumMyRows();
+
+  int row_lengths = 0;
+  int allocated_space = A->MaxNumEntries();
+  std::vector<int> columns(allocated_space + 1);
+  std::vector<double> values(allocated_space + 1);
+
+  // FIXME: DOES NOT WORK IN PARALLEL!
+  assert (A->Comm().NumProc() == 1);
+  
+  for (int i = 0 ; i < NumMyRows ; ++i) {
+    ap[i] = 0.0;
+    int ierr;
+    ierr = ML_Epetra_getrow_Filter(mat_in, 1, &i, allocated_space, 
+                                   &columns[0], &values[0], &row_lengths);
+    assert (ierr == 1); ierr++;
+
+    for (int j = 0 ; j < row_lengths ; ++j)
+      ap[i] += values[j] * p[columns[j]];
+  }
+
+  return 1;
+}
+
+// ====================================================================== 
+// General getrow for Epetra matrix classes.
+// This function is deprecated, use one of the following instead:
+// - ML_Epetra_RowMatrix_getrow
+// - ML_Epetra_CrsMatrix_getrow
+// - ML_Epetra_VbrMatrix_getrow
+// ====================================================================== 
+
+int ML_Epetra_getrow(ML_Operator *data, int N_requested_rows, int requested_rows[], 
+		    int allocated_space, int columns[], double values[],
+		    int row_lengths[])
+{
+
+  cout << "Fuction ML_Epetra_getrow() is no longer supported." << std::endl;
+  cout << "You should use one of the following instead:" << std::endl;
+  cout << "- ML_Epetra_RowMatrix_getrow();" << std::endl;
+  cout << "- ML_Epetra_CrsMatrix_getrow();" << std::endl;
+  cout << "- ML_Epetra_VbrMatrix_getrow()." << std::endl;
+  cout << "If you don't know what is your matrix type, then use" << std::endl;
+  cout << "the generic function for Epetra_RowMatrix's." << std::endl;
+  cout << "You may need to update your Epetra wrapper and set the" << std::endl;
+  cout << "appropriete function instead if ML_Epetra_getrow()" << std::endl;
+
+  ML_RETURN(-1);
+
+#if 0
+
+  int nz_ptr = 0;
+  int NumEntries;
+  int MaxPerRow = 0;
+  int NumPDEEqns=1;
+  int * BlockIndices;
+  Epetra_SerialDenseMatrix ** Entries;
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+
+  Epetra_RowMatrix *Abase = (Epetra_RowMatrix *) ML_Get_MyGetrowData(mat_in);
+  
+  Epetra_CrsMatrix * Acrs = dynamic_cast<Epetra_CrsMatrix *>(Abase);
+  int MatrixIsCrsMatrix = (Acrs!=0); // If this pointer is non-zero,
+                                  // the cast to Epetra_CrsMatrix worked
+
+  Epetra_VbrMatrix * Avbr = dynamic_cast<Epetra_VbrMatrix *>(Abase);
+  int MatrixIsVbrMatrix = (Avbr!=0); // If this pointer is non-zero,
+                                  // the cast to Epetra_VbrMatrix worked
+
+  int *Indices;
+  double *Values;
+  int MatrixIsRowMatrix = false;
+  if (MatrixIsCrsMatrix) {
+    // do nothing for Crs
+  } else  if( MatrixIsVbrMatrix ) {
+    // for Vbr we need to know the number of PDE for each row
+    if( Avbr->NumMyRows() % Avbr->NumMyBlockRows() != 0 ){
+      cerr << "Error : NumPDEEqns does not seem to be constant\n";
+      exit( EXIT_FAILURE );
+    }
+    NumPDEEqns = (Avbr->NumMyRows())/(Avbr->NumMyBlockRows());
+  } else {
+    // general RowMatrix case
+    MatrixIsRowMatrix = true;
+    MaxPerRow = Abase->MaxNumEntries();
+    Values = new double [MaxPerRow]; 
+    Indices = new int [MaxPerRow]; 
+  }  
+
+  for (int i = 0; i < N_requested_rows; i++)
+  {
+    int ierr;
+    int LocalRow = requested_rows[i];
+    if (MatrixIsCrsMatrix)
+      ierr = Acrs->ExtractMyRowView(LocalRow, NumEntries, Values, Indices);
+    else if (MatrixIsVbrMatrix) {
+      // for vbr, we recover the local number of the BlockRow
+      // (dividing by NumPDEEqns). In this way, we can get a view
+      // of the local row (no memory allocation occurs).
+      int PDEEqn = LocalRow % NumPDEEqns;
+      int LocalBlockRow = LocalRow/NumPDEEqns;
+      
+      int RowDim;
+      int NumBlockEntries;    
+      ierr = Avbr->ExtractMyBlockRowView(LocalBlockRow,RowDim,
+                     NumBlockEntries, BlockIndices, Entries);
+      // I do here some stuff because Vbr matrices must
+      // be treated differently.
+      if (ierr) {
+        if (MatrixIsRowMatrix) {
+          delete [] Indices;
+          delete [] Values;
+        }
+        return(0); 
+      }
+      NumEntries = NumBlockEntries*NumPDEEqns;
+      if (nz_ptr + NumEntries > allocated_space) {
+        if (MatrixIsRowMatrix) {
+          delete [] Indices;
+          delete [] Values;
+        }
+        return(0);
+      }
+      
+      for( int j=0 ; j<NumBlockEntries ; ++j ) {
+    for( int k=0 ; k<NumPDEEqns ; ++k ) {
+      columns[nz_ptr] = BlockIndices[j]*NumPDEEqns+k;
+      values[nz_ptr++] = (*Entries[j])(PDEEqn,k);
+    }
+      }
+      row_lengths[i] = NumBlockEntries*NumPDEEqns;      
+    }
+    else
+      ierr = Abase->ExtractMyRowCopy(LocalRow, MaxPerRow, NumEntries,
+                                      Values, Indices);
+    if (ierr) {
+      if (MatrixIsRowMatrix) {
+        delete [] Indices;
+        delete [] Values;
+      }
+      return(0); //JJH I think this is the correct thing to return if
+                 //    A->ExtractMyRowCopy returns something nonzero ..
+    }
+
+    if( !MatrixIsVbrMatrix ) {
+      row_lengths[i] = NumEntries;
+      if (nz_ptr + NumEntries > allocated_space) {
+        if (MatrixIsRowMatrix) {
+          delete [] Indices;
+          delete [] Values;
+        }
+         return(0);
+      }
+      
+      for (int j=0; j<NumEntries; j++) {
+        columns[nz_ptr] = Indices[j];
+        values[nz_ptr++] = Values[j];
+      }
+    }
+  }
+
+  if (MatrixIsRowMatrix) {
+    delete [] Indices;
+    delete [] Values;
+  }
+  
+  return(1);
+#endif
+}
+
+// ====================================================================== 
+// Getrow for RowMatrix that are not Epetra_CrsMatrix or Epetra_VbrMatrix
+// ====================================================================== 
+
+int ML_Epetra_RowMatrix_getrow(ML_Operator *data, int N_requested_rows, 
+                               int requested_rows[], int allocated_space, 
+                               int columns[], double values[],
+                               int row_lengths[])
+{
+  int nz_ptr = 0;
+  int NumEntries;
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+
+  Epetra_RowMatrix* A = (Epetra_RowMatrix *) ML_Get_MyGetrowData(mat_in);
+  
+  for (int i = 0; i < N_requested_rows; i++)
+  {
+    int ierr;
+    int LocalRow = requested_rows[i];
+    A->NumMyRowEntries(LocalRow, NumEntries);
+    if (allocated_space < NumEntries)
+      return(0); // to avoid Epetra print something on cout
+    ierr = A->ExtractMyRowCopy(LocalRow, allocated_space, NumEntries,
+                               values + nz_ptr, columns + nz_ptr);
+    if (ierr) 
+      return(0); //JJH I think this is the correct thing to return if
+                 //    A->ExtractMyRowCopy returns something nonzero ..
+
+    row_lengths[i] = NumEntries;
+    // increase count of already used space...
+    nz_ptr += NumEntries;
+    // and decrease amount of available space
+    allocated_space -= NumEntries;
+    if (allocated_space < 0)
+      return(0); // something was wrong here
+  }
+
+  return(1);
+}
+
+// ====================================================================== 
+// Specialized getrow for Epetra_CrsMatrix class.
+// ====================================================================== 
+
+int ML_Epetra_CrsMatrix_getrow(ML_Operator *data, int N_requested_rows,
+            int requested_rows[], 
+		    int allocated_space, int columns[], double values[],
+		    int row_lengths[])
+{
+  int nz_ptr = 0;
+  int NumEntries;
+  //int MaxPerRow = 0;
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+
+  Epetra_CrsMatrix *Acrs =  (Epetra_CrsMatrix *) ML_Get_MyGetrowData(mat_in);
+  
+  for (int i = 0; i < N_requested_rows; i++)
+  {
+    int LocalRow = requested_rows[i];
+    int *Indices;
+    double *Values;
+
+    int ierr = Acrs->ExtractMyRowView(LocalRow, NumEntries, Values, Indices);
+    if (ierr)
+      return(0); //JJH I think this is the correct thing to return if
+                 //    A->ExtractMyRowCopy returns something nonzero ..
+
+    row_lengths[i] = NumEntries;
+    if (nz_ptr + NumEntries > allocated_space)
+      return(0);
+      
+    for (int j=0; j<NumEntries; j++) {
+      columns[nz_ptr] = Indices[j];
+      values[nz_ptr++] = Values[j];
+    }
+  }
+
+  return(1);
+} //ML_Epetra_CrsMatrix_getrow
+
+// ====================================================================== 
+// Specialized getrow for Epetra_CrsMatrix class.
+// ====================================================================== 
+
+int ML_Epetra_CrsMatrix_get_one_row(ML_Operator *data, int N_requested_rows,
+                                    int requested_rows[], 
+                                    int allocated_space, int columns[], double values[],
+                                    int row_lengths[])
+{
+  int nz_ptr = 0;
+  int NumEntries;
+  //int MaxPerRow = 0;
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+
+  Epetra_CrsMatrix *Acrs =  (Epetra_CrsMatrix *) ML_Get_MyGetrowData(mat_in);
+  
+  for (int i = 0; i < N_requested_rows; i++)
+  {
+    int LocalRow = requested_rows[i];
+    int *Indices;
+    double *Values;
+
+    int ierr = Acrs->ExtractMyRowView(LocalRow, NumEntries, Values, Indices);
+    if (ierr)
+      return(0); //JJH I think this is the correct thing to return if
+                 //    A->ExtractMyRowCopy returns something nonzero ..
+
+    row_lengths[i] = NumEntries;
+    if (nz_ptr + NumEntries > allocated_space)
+      return(0);
+      
+    for (int j=0; j<NumEntries; j++) {
+      columns[nz_ptr] = Indices[j];
+      values[nz_ptr++] = 1.0;
+    }
+  }
+
+  return(1);
+} //ML_Epetra_CrsMatrix_getrow
+
+
+// ====================================================================== 
+// Specialized getrow for Epetra_VbrMatrix class.
+// ====================================================================== 
+
+int ML_Epetra_VbrMatrix_getrow(ML_Operator *data, int N_requested_rows, 
+                               int requested_rows[], int allocated_space, 
+                               int columns[], double values[],
+                               int row_lengths[])
+{
+  int nz_ptr = 0;
+  int NumEntries;
+  int * BlockIndices;
+  Epetra_SerialDenseMatrix ** Entries;
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+  Epetra_VbrMatrix * Avbr = (Epetra_VbrMatrix *) ML_Get_MyGetrowData(mat_in);
+
+  /* moved into MultiLevelPreconditioner
+  // for Vbr we need to know the number of PDE for each row
+  if( Avbr->NumMyRows() % Avbr->NumMyBlockRows() != 0 ){
+    cerr << "Error : NumPDEEqns does not seem to be constant\n";
+    exit( EXIT_FAILURE );
+  }
+  */
+  // NO! // int NumPDEEqns = mat_in->num_PDEs;
+  // The above expression does not hold because of AmalgamateAndDropWeak,
+  // which changes the value of mat_in->num_PDEs. Therefore we need
+  // to use the one below, which might be slightly slower.
+  int NumPDEEqns = (Avbr->NumMyRows())/(Avbr->NumMyBlockRows());
+
+  for (int i = 0; i < N_requested_rows; i++)
+  {
+    int LocalRow = requested_rows[i];
+    // for vbr, we recover the local number of the BlockRow
+    // (dividing by NumPDEEqns). In this way, we can get a view
+    // of the local row (no memory allocation occurs).
+    int PDEEqn = LocalRow % NumPDEEqns;
+    int LocalBlockRow = LocalRow/NumPDEEqns;
+    
+    int RowDim;
+    int NumBlockEntries;    
+    int ierr = Avbr->ExtractMyBlockRowView(LocalBlockRow,RowDim,
+                   NumBlockEntries, BlockIndices, Entries);
+    if (ierr) return(0); 
+    NumEntries = NumBlockEntries*NumPDEEqns;
+    if (nz_ptr + NumEntries > allocated_space)
+      return(0);
+
+    for( int j=0 ; j<NumBlockEntries ; ++j ) {
+      for( int k=0 ; k<NumPDEEqns ; ++k ) {
+        columns[nz_ptr] = BlockIndices[j]*NumPDEEqns+k;
+        values[nz_ptr++] = (*Entries[j])(PDEEqn,k);
+      }
+    }
+    row_lengths[i] = NumBlockEntries*NumPDEEqns;      
+  }
+
+  return(1);
+} //ML_Epetra_VbrMatrix_getrow
+
+// ====================================================================== 
+
+#ifdef HAVE_ML_TEUCHOS
+void ML_Set_Filter(Teuchos::ParameterList& List)
+{
+  Filter_.Type    = List.get("filter: type", ML_Epetra::ML_NO_FILTER);
+  Filter_.AThresh = List.get("filter: absolute threshold", 0.0);
+  Filter_.RThresh = List.get("filter: relative threshold", 1.0);
+  Filter_.Eqns    = List.get("filter: equations", 1);
+  Filter_.FirstDivider  = List.get("filter: first divider", 0);
+  Filter_.SecondDivider = List.get("filter: second divider", 0);
+  Filter_.Mask          = List.get("filter: mask", (double*)0);
+}
+#endif
+
+// ====================================================================== 
+
+int ML_Epetra_getrow_Filter(ML_Operator *data, int N_requested_rows, 
+                            int requested_rows[], int allocated_space, 
+                            int columns[], double values[], int row_lengths[])
+{
+  int ierr, eqn;
+  ierr = ML_Epetra_getrow(data, N_requested_rows, requested_rows, allocated_space,
+                          columns, values, row_lengths);
+
+  if (ierr == 0)
+    return(0);
+
+  if (N_requested_rows != 1) {
+    cerr << "Only N_requested_rows == 1 currently implemented..." << std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  switch (Filter_.Type) {
+
+  case ML_Epetra::ML_NO_FILTER:
+    return(1);
+
+  case ML_Epetra::ML_EQN_FILTER:
+
+    for (int i = 0; i < row_lengths[0]; i++) {
+      if (columns[i] % Filter_.Eqns != requested_rows[0] % Filter_.Eqns)
+        values[i] = 0.0;
+    }
+    break;
+
+  case ML_Epetra::ML_TWO_BLOCKS_FILTER:
+
+    eqn = (requested_rows[0] % Filter_.Eqns);
+
+    if (eqn < Filter_.FirstDivider) {
+      // upper block
+      for (int i = 0; i < row_lengths[0]; i++) {
+        if (columns[i] % Filter_.Eqns >= Filter_.FirstDivider)
+          // upper-right block
+          values[i] = 0.0;
+      }
+    }
+    else {
+      // lower block
+      for (int i = 0; i < row_lengths[0]; i++) {
+        if (columns[i] % Filter_.Eqns < Filter_.FirstDivider)
+          // lower-left block
+          values[i] = 0.0;
+      }
+    }
+
+    break;
+
+  case ML_Epetra::ML_THREE_BLOCKS_FILTER:
+
+    eqn = (requested_rows[0] % Filter_.Eqns);
+
+    if (eqn < Filter_.FirstDivider) {
+      for (int i = 0; i < row_lengths[0]; i++) {
+        if (columns[i] % Filter_.Eqns >= Filter_.FirstDivider)
+          values[i] = 0.0;
+      }
+    }
+    else if (eqn < Filter_.SecondDivider) {
+      for (int i = 0; i < row_lengths[0]; i++) {
+        if (columns[i] % Filter_.Eqns <  Filter_.FirstDivider ||
+            columns[i] % Filter_.Eqns >= Filter_.SecondDivider)
+          values[i] = 0.0;
+      }
+    }
+    else {
+      for (int i = 0; i < row_lengths[0]; i++) {
+        if (columns[i] % Filter_.Eqns <  Filter_.SecondDivider)
+          values[i] = 0.0;
+      }
+    }
+
+    break;
+
+  case ML_Epetra::ML_MASK_FILTER:
+
+    eqn = (requested_rows[0] % Filter_.Eqns);
+    for (int i = 0; i < row_lengths[0]; i++) {
+      values[i] *= Filter_.Mask[eqn * Filter_.Eqns + columns[i] % Filter_.Eqns];
+    }
+    break;
+
+  default:
+
+    cerr << "Error, file " << __FILE__ << ", line " << __LINE__ << std::endl;
+    exit(EXIT_FAILURE);
+  }
+
+  if (Filter_.RThresh != 1.00 && Filter_.AThresh != 0.0) {
+    for (int i = 0; i < row_lengths[0]; i++) {
+      if (columns[i] == requested_rows[0]) {
+        values[i] = Filter_.RThresh * values[i] + Filter_.AThresh * fabs(values[i]);
+        break;
+      }
+    }
+  }
+
+  return(1);
+}
+
+// ====================================================================== 
+
+int ML_Epetra_comm_wrapper(double vec[], void *data)
+{
+  Epetra_RowMatrix *A = (Epetra_RowMatrix *) data;
+
+  if (A->Comm().NumProc()==1) return(1); // Nothing to do in serial mode.
+
+  if( A->RowMatrixImporter() != 0 ) {
+    Epetra_Vector X_target(View, A->RowMatrixImporter()->TargetMap(),
+			   vec); //ghosted
+    Epetra_Vector X_source(View, A->RowMatrixImporter()->SourceMap(),
+			   vec); //loc only
+    X_target.Import(X_source, *(A->RowMatrixImporter()), Insert);
+  }
+  
+  return(1);
+}
+
+// ====================================================================== 
+
+int ML_Epetra_CrsMatrix_comm_wrapper(double vec[], void *data)
+{
+  Epetra_CrsMatrix *A = (Epetra_CrsMatrix *) data;
+
+  if (A->Comm().NumProc()==1) return(1); // Nothing to do in serial mode.
+
+  if( A->RowMatrixImporter() != 0 ) {
+    Epetra_Vector X_target(View, A->RowMatrixImporter()->TargetMap(),
+			   vec); //ghosted
+    Epetra_Vector X_source(View, A->RowMatrixImporter()->SourceMap(),
+			   vec); //loc only
+    X_target.Import(X_source, *(A->RowMatrixImporter()), Insert);
+  }
+  
+  return(1);
+}
+
+// ====================================================================== 
+
+int ML_Epetra_VbrMatrix_comm_wrapper(double vec[], void *data)
+{
+  Epetra_VbrMatrix *A = (Epetra_VbrMatrix *) data;
+
+  if (A->Comm().NumProc()==1) return(1); // Nothing to do in serial mode.
+
+//  Epetra_Vector X_target(View, A->RowMatrixImporter()->TargetMap(), vec); //ghosted
+//  Epetra_Vector X_source(View, A->RowMatrixImporter()->SourceMap(), vec); //loc only
+
+  if( A->RowMatrixImporter() != 0 ) {
+    Epetra_Vector X_target(View, A->RowMatrixImporter()->TargetMap(),
+			   vec); //ghosted
+    Epetra_Vector X_source(View, A->RowMatrixImporter()->SourceMap(),
+			   vec); //loc only
+  
+//  assert(X_target.Import(X_source, *(A->RowMatrixImporter()),Insert)==0);
+    X_target.Import(X_source, *(A->RowMatrixImporter()), Insert);
+  }
+  
+  return(1);
+}
+
+// ======================================================================
+
+int ML_Operator_WrapEpetraMatrix(Epetra_RowMatrix * A, ML_Operator *newMatrix)
+{
+  int isize, osize;
+
+  // FIXME ?? 
+  //osize = A->NumMyRows();
+  osize = A->OperatorRangeMap().NumMyElements();
+  isize = A->OperatorDomainMap().NumMyElements();
+  //  isize = A->NumMyCols();
+  int N_ghost = A->RowMatrixColMap().NumMyElements() - isize;
+  newMatrix->N_nonzeros = A->NumMyNonzeros();
+
+  if (N_ghost < 0) N_ghost = 0;  // A->NumMyCols() = 0 for an empty matrix
+
+  Epetra_CrsMatrix *Acrs = dynamic_cast<Epetra_CrsMatrix*>(A);
+
+  if (Acrs) { // Epetra_CrsMatrix
+    ML_Operator_Set_ApplyFuncData(newMatrix, isize, osize,
+                                (void*) Acrs, osize,
+                                NULL, 0);
+
+    ML_CommInfoOP_Generate( &(newMatrix->getrow->pre_comm), 
+                          ML_Epetra_CrsMatrix_comm_wrapper, (void *) Acrs, 
+                          newMatrix->comm, isize, N_ghost);
+
+    ML_Operator_Set_Getrow(newMatrix, newMatrix->outvec_leng,
+                           ML_Epetra_CrsMatrix_getrow);
+
+    ML_Operator_Set_ApplyFunc (newMatrix, ML_Epetra_CrsMatrix_matvec);
+
+    newMatrix->type = ML_TYPE_CRS_MATRIX;
+  }
+  // TODO implement functionality for Epetra_VbrMatrix
+  else { // RowMatrix
+    ML_Operator_Set_ApplyFuncData(newMatrix, isize, osize,
+                                (void*) A, osize,
+                                NULL, 0);
+
+    ML_CommInfoOP_Generate( &(newMatrix->getrow->pre_comm), 
+                          ML_Epetra_comm_wrapper, (void *) A, 
+                          newMatrix->comm, isize, N_ghost);
+
+    ML_Operator_Set_Getrow(newMatrix, newMatrix->outvec_leng,
+                           ML_Epetra_RowMatrix_getrow);
+
+    ML_Operator_Set_ApplyFunc (newMatrix, ML_Epetra_VbrMatrix_matvec);
+
+    newMatrix->type = ML_TYPE_ROW_MATRIX;
+  }
+
+  return 0;
+}
+
+
+
+/* This should (correctly) build the epetra maps from the ML_Operator object*/
+void ML_Build_Epetra_Maps(ML_Operator* Amat,Epetra_Map **domainmap, Epetra_Map **rangemap,
+                          Epetra_Map **colmap,int base, const Epetra_Comm &EpetraComm )
+{
+  
+  int    isize_offset, osize_offset;
+  int Nghost;
+  ML_Comm *comm;
+
+  comm = Amat->comm;
+
+  Epetra_Time Time(EpetraComm);
+
+  if (Amat->getrow->post_comm != NULL)  {
+    if (Amat->comm->ML_mypid == 0)
+      pr_error("Error: Please transpose matrix with ML_Operator_Transpose_byrow()\n       before calling ML_Build_Epetra_Maps().\n");
+  }
+
+  if (Amat->getrow->pre_comm == NULL)
+    Nghost = 0;
+  else {
+    if (Amat->getrow->pre_comm->total_rcv_length <= 0)
+      ML_CommInfoOP_Compute_TotalRcvLength(Amat->getrow->pre_comm);
+    Nghost = Amat->getrow->pre_comm->total_rcv_length;
+  }
+
+  int isize = Amat->invec_leng;
+  int osize = Amat->outvec_leng;
+
+  EpetraComm.ScanSum(&isize,&isize_offset,1); isize_offset-=isize + base;
+  EpetraComm.ScanSum(&osize,&osize_offset,1); osize_offset-=osize + base;
+
+  std::vector<double> global_isize; global_isize.resize(isize+Nghost+1);
+  std::vector<int>    global_isize_as_int; global_isize_as_int.resize(isize+Nghost+1);
+
+  //vector<double> global_osize(osize);
+  std::vector<int>    global_osize_as_int(osize);
+  
+  for (int i = 0 ; i < isize; i++) {
+          global_isize[i] = (double) (isize_offset + i);
+          global_isize_as_int[i] = isize_offset + i;
+  }
+          
+  for (int i = 0 ; i < osize; i++) {
+    //global_osize[i] = (double) (osize_offset + i);
+    global_osize_as_int[i] = osize_offset + i;
+  }
+  for (int i = 0 ; i < Nghost; i++) global_isize[i+isize] = -1;
+
+  if(rangemap) *rangemap=new Epetra_Map( -1, osize, &global_osize_as_int[0], base, EpetraComm ) ; 
+  if(domainmap) *domainmap=new Epetra_Map( -1, isize, &global_isize_as_int[0], base, EpetraComm ) ; 
+
+
+  /* Build the column map first to make sure we get communication patterns correct.  This uses
+     the ML_Operator comm, which could be (much) bigger than EpetraComm.  This should be ok,
+     however, since only 'active' processors in the ML comm participate.
+  */
+  ML_exchange_bdry(&global_isize[0],Amat->getrow->pre_comm, 
+ 		 Amat->invec_leng,comm,ML_OVERWRITE,NULL);
+
+  for ( int j = isize; j < isize+Nghost; j++ ) { 
+    global_isize_as_int[j] = (int) global_isize[j];
+  }
+  
+  if(colmap) *colmap=new Epetra_Map( -1, isize+Nghost, &global_isize_as_int[0], base, EpetraComm ) ; 
+
+}/*end ML_Build_Epetra_Maps*/
+
+
+// ================================================ ====== ==== ==== == = 
+// This is a *ultra* lightweight wrap of an Epetra_CrsMatrix in ML.  This uses a
+// "may change for experts only" function ExtractCrsDataPointers.
+//
+//  You need to have remapped the Epetra Matrix to include all the columns
+//  before this routine gets called or else this won't work in parallel.
+//
+// -Chris Siefert 11/28/2006.
+#include "Epetra_Comm.h"
+#include "Epetra_CrsMatrix.h"
+int ML_Operator_WrapEpetraCrsMatrix(Epetra_CrsMatrix * A, ML_Operator *newMatrix, bool verbose)
+{
+  int rv=0;
+  if(A->StorageOptimized() && A->IndexBase()==0){
+    int isize, osize;
+    osize = A->OperatorRangeMap().NumMyElements();
+    isize = A->OperatorDomainMap().NumMyElements();
+    
+    int N_ghost = A->RowMatrixColMap().NumMyElements() - isize; 
+    if (N_ghost < 0) N_ghost = 0; 
+    
+    /* Do the "View" Wrap */
+    struct ML_CSR_MSRdata *epetra_csr= (struct ML_CSR_MSRdata*)malloc(sizeof(struct ML_CSR_MSRdata));
+    epetra_csr->Nnz = A->NumGlobalNonzeros();
+    newMatrix->N_nonzeros = A->NumMyNonzeros();
+    epetra_csr->Nrows=osize;
+    epetra_csr->Ncols=isize;  
+    A->ExtractCrsDataPointers(epetra_csr->rowptr,epetra_csr->columns,epetra_csr->values);
+
+    /* Sanity Check */
+    if(!epetra_csr->rowptr || !epetra_csr->columns || !epetra_csr->values) {
+      if(verbose && !A->Comm().MyPID()) printf("WARNING: ExtractDataPointers failed [%s], reverting to heavyweight wrap.\n",A->Label());
+      free(epetra_csr);
+      return ML_Operator_WrapEpetraMatrix(A,newMatrix);
+    }/*end if*/
+    
+    /* Set the appropriate function pointers + data */
+    ML_Operator_Set_ApplyFuncData(newMatrix, isize, osize,(void*) epetra_csr, osize,NULL,0);  
+    ML_CommInfoOP_Generate(&(newMatrix->getrow->pre_comm),ML_Epetra_CrsMatrix_comm_wrapper, (void *) A, 
+                           newMatrix->comm, isize, N_ghost);
+    ML_Operator_Set_Getrow(newMatrix, newMatrix->outvec_leng,CSR_getrow);
+    ML_Operator_Set_ApplyFunc (newMatrix, CSR_matvec);  
+    newMatrix->data_destroy=free;
+    newMatrix->type = ML_TYPE_CRS_MATRIX;  
+  }/*end if*/
+  else{
+    if(verbose && !A->Comm().MyPID()) printf("WARNING: Matrix storage not optimized [%s], reverting to heavyweight wrap.\n",A->Label());
+    return ML_Operator_WrapEpetraMatrix(A,newMatrix);
+  }/*end else*/
+  return rv;      
+}/*end ML_Operator_WrapEpetraCrsMatrix*/
+
+// ================================================ ====== ==== ==== == 
+// Thie provides a lightweight wrap of an ML_Operator in Epetra.  The Epetra
+// object needs to be setup correctly beforehand or else this will have
+// disasterous consequences.  We assume that the ML_Operator will persist until
+// after the Epetra_CrsMatrix is destroyed, if this is set in View mode.
+// -Chris Siefert 11/20/2006.
+void Epetra_CrsMatrix_Wrap_ML_Operator(ML_Operator * A, const Epetra_Comm &Comm, const Epetra_Map &RowMap,Epetra_CrsMatrix **Result,Epetra_DataAccess CV,int base){ 
+
+#define LIGHTWEIGHT_WRAP
+#ifdef LIGHTWEIGHT_WRAP
+  /* This is a very dangerous way to do this.  Live on the edge. */
+  int *cols;
+  double* vals;
+  struct ML_CSR_MSRdata* M_= (struct ML_CSR_MSRdata*)ML_Get_MyGetrowData(A);
+
+  /* Build the Column Map */
+  Epetra_Map *DomainMap,*ColMap;
+  ML_Build_Epetra_Maps(A,&DomainMap,NULL,&ColMap,base,Comm);
+  
+  /* Allocate the Epetra_CrsMatrix Object */
+  *Result=new Epetra_CrsMatrix(CV,RowMap,*ColMap,base);
+  
+  /* Fill the matrix */
+  for(int row=0;row<A->outvec_leng;row++){
+    cols=&(M_->columns[M_->rowptr[row]]);
+    vals=&(M_->values[M_->rowptr[row]]);
+    (*Result)->InsertMyValues(row,M_->rowptr[row+1]-M_->rowptr[row],vals,cols);
+  }/*end for*/
+  (*Result)->FillComplete(*DomainMap,RowMap);
+  if(CV!=View) (*Result)->OptimizeStorage();
+  
+  /* Cleanup */
+  delete DomainMap; delete ColMap;
+#else
+  double bob;
+  int mnz=10000;
+  ML_Operator2EpetraCrsMatrix(A,*Result,mnz,true,bob,base);
+#endif
+}/*end Epetra_CrsMatrix_Wrap_ML_Operator*/
+
+
+// ====================================================================== 
+//! Does an P^TAP for Epetra_CrsMatrices using ML's kernels.
+int ML_Epetra::ML_Epetra_PtAP(const Epetra_CrsMatrix & A, const Epetra_CrsMatrix & P, Epetra_CrsMatrix *&Result,bool verbose){
+  ML_Comm* comm;
+  ML_Comm_Create(&comm);
+#ifdef ML_MPI
+  // Use the same communicator as A if we're using MPI.
+  const Epetra_MpiComm * Mcomm=dynamic_cast<const Epetra_MpiComm*>(&A.Comm());
+  if(Mcomm) ML_Comm_Set_UsrComm(comm,Mcomm->GetMpiComm());
+#endif
+
+  ML_Operator *R_       = ML_Operator_Create(comm);
+  ML_Operator *A_       = ML_Operator_Create(comm);
+  ML_Operator *P_       = ML_Operator_Create(comm);
+  ML_Operator *Result_  = ML_Operator_Create(comm);    
+
+  /* Do the wrapping */  
+  ML_Operator_WrapEpetraCrsMatrix((Epetra_CrsMatrix*)&P,P_,verbose);
+  ML_Operator_WrapEpetraCrsMatrix((Epetra_CrsMatrix*)&A,A_,verbose);
+  
+  /* Build the transpose */ 
+  ML_Operator_Transpose_byrow(P_,R_);
+
+  /* Triple mat-product */
+  ML_rap(R_,A_,P_ ,Result_, ML_CSR_MATRIX);
+  
+  /* Wrap back */
+  int nnz;
+  double time;
+  ML_Operator2EpetraCrsMatrix(Result_,Result,nnz,true,time,0,false);
+  Result->OptimizeStorage();
+  
+  /* Cleanup */
+  ML_Operator_Destroy(&R_);
+  ML_Operator_Destroy(&A_);
+  ML_Operator_Destroy(&P_);
+  ML_Operator_Destroy(&Result_);
+  ML_Comm_Destroy(&comm);
+  return 0;
+}/*end ML_Epetra_PtAP */
+
+
+// ============================================================================
+//! Does an RAP for Epetra_CrsMatrices using ML's kernels.
+int ML_Epetra::ML_Epetra_RAP(const Epetra_CrsMatrix & A, const Epetra_CrsMatrix & P, const Epetra_CrsMatrix & R, Epetra_CrsMatrix *&Result,bool verbose){
+  ML_Comm* comm;
+  ML_Comm_Create(&comm);
+#ifdef ML_MPI
+  // Use the same communicator as A if we're using MPI.
+  const Epetra_MpiComm * Mcomm=dynamic_cast<const Epetra_MpiComm*>(&A.Comm());
+  if(Mcomm) ML_Comm_Set_UsrComm(comm,Mcomm->GetMpiComm());
+#endif
+
+  ML_Operator *R_       = ML_Operator_Create(comm);
+  ML_Operator *A_       = ML_Operator_Create(comm);
+  ML_Operator *P_       = ML_Operator_Create(comm);
+  ML_Operator *Result_  = ML_Operator_Create(comm);    
+
+  /* Do the wrapping */  
+  ML_Operator_WrapEpetraCrsMatrix((Epetra_CrsMatrix*)&P,P_,verbose);
+  ML_Operator_WrapEpetraCrsMatrix((Epetra_CrsMatrix*)&R,R_,verbose);
+  ML_Operator_WrapEpetraCrsMatrix((Epetra_CrsMatrix*)&A,A_,verbose);
+  
+  /* Triple mat-product */
+  ML_rap(R_,A_,P_ ,Result_, ML_CSR_MATRIX);
+  
+  /* Wrap back */
+  int nnz;
+  double time;
+  ML_Operator2EpetraCrsMatrix(Result_,Result,nnz,true,time,0,false);
+  Result->OptimizeStorage();
+  
+  /* Cleanup */
+  ML_Operator_Destroy(&R_);
+  ML_Operator_Destroy(&A_);
+  ML_Operator_Destroy(&P_);
+  ML_Operator_Destroy(&Result_);
+  ML_Comm_Destroy(&comm);
+  return 0;
+}/*end ML_Epetra_PtAP */
+
+
+
+// ============================================================================
+int* ML_Epetra::FindLocalDiricheltRowsFromOnesAndZeros(const Epetra_CrsMatrix & Matrix, int &numBCRows){
+  int *dirichletRows = new int[Matrix.NumMyRows()];
+  numBCRows = 0;
+  for (int i=0; i<Matrix.NumMyRows(); i++) {
+    int numEntries, *cols;
+    double *vals;
+    int ierr = Matrix.ExtractMyRowView(i,numEntries,vals,cols);
+    if (ierr == 0) {
+      int nz=0;
+      for (int j=0; j<numEntries; j++) if (vals[j] != 0.0) nz++;
+      if (nz == 1) dirichletRows[numBCRows++] = i;      
+    }/*end if*/
+  }/*end fpr*/
+  return dirichletRows;
+}/*end FindLocalDiricheltRowsFromOnesAndZeros*/
+
+
+// ====================================================================== 
+ //! Finds Dirichlet the local Dirichlet columns, given the local Dirichlet rows
+Epetra_IntVector * ML_Epetra::FindLocalDirichletColumnsFromRows(const int *dirichletRows, int numBCRows,const Epetra_CrsMatrix & Matrix){
+  const Epetra_Map & ColMap = Matrix.ColMap();
+  int indexBase = ColMap.IndexBase();
+  Epetra_Map* mapPtr = 0;
+  
+  if(Matrix.RowMap().GlobalIndicesInt())
+    mapPtr = new Epetra_Map((int) Matrix.NumGlobalCols(),indexBase,Matrix.Comm());
+  else if(Matrix.RowMap().GlobalIndicesLongLong())
+    mapPtr = new Epetra_Map(Matrix.NumGlobalCols(),indexBase,Matrix.Comm());
+  else
+    assert(false);
+  
+  Epetra_Map& globalMap = *mapPtr;
+
+  // create the exporter from this proc's column map to global 1-1 column map
+  Epetra_Export Exporter(ColMap,globalMap);
+
+  // create a vector of global column indices that we will export to
+  Epetra_IntVector globColsToZero(globalMap);
+  // create a vector of local column indices that we will export from
+  Epetra_IntVector *myColsToZero= new Epetra_IntVector(ColMap);
+  myColsToZero->PutValue(0);  
+
+  // for each local column j in a local dirichlet row, set myColsToZero[j]=1
+  for (int i=0; i < numBCRows; i++) {
+    int numEntries;
+    double *vals;
+    int *cols;
+    Matrix.ExtractMyRowView(dirichletRows[i],numEntries,vals,cols);
+    for (int j=0; j < numEntries; j++)
+      (*myColsToZero)[ cols[j] ] = 1;
+  }/*end for*/
+
+  // export to the global column map
+  globColsToZero.Export(*myColsToZero,Exporter,Add);
+  // now import from the global column map to the local column map
+  myColsToZero->Import(globColsToZero,Exporter,Insert);
+
+  delete mapPtr;
+
+  return myColsToZero;
+}/*end FindLocalDirichletColumnsFromRows*/
+
+
+  // ====================================================================== 
+Epetra_IntVector * ML_Epetra::LocalRowstoColumns(int *Rows, int numRows,const Epetra_CrsMatrix & Matrix){
+  const Epetra_Map & ColMap = Matrix.ColMap();
+  int indexBase = ColMap.IndexBase();
+  Epetra_Map* mapPtr = 0;
+  
+  if(Matrix.RowMap().GlobalIndicesInt())
+    mapPtr = new Epetra_Map((int) Matrix.NumGlobalCols(),indexBase,Matrix.Comm());
+  else if(Matrix.RowMap().GlobalIndicesLongLong())
+    mapPtr = new Epetra_Map(Matrix.NumGlobalCols(),indexBase,Matrix.Comm());
+  else
+    assert(false);
+  
+  Epetra_Map& globalMap = *mapPtr;
+
+  // create the exporter from this proc's column map to global 1-1 column map
+  Epetra_Export Exporter(ColMap,globalMap);
+
+  // create a vector of global column indices that we will export to
+  Epetra_IntVector globColsToZero(globalMap);
+  // create a vector of local column indices that we will export from
+  Epetra_IntVector *myColsToZero= new Epetra_IntVector(ColMap);
+  myColsToZero->PutValue(0);  
+
+  // flag all local columns corresponding to the local rows specified
+  for (int i=0; i < numRows; i++) 
+    (*myColsToZero)[Matrix.LCID(Matrix.GRID(Rows[i]))]=1;
+
+  // export to the global column map
+  globColsToZero.Export(*myColsToZero,Exporter,Add);
+  // now import from the global column map to the local column map
+  myColsToZero->Import(globColsToZero,Exporter,Insert);
+
+  delete mapPtr;
+
+  return myColsToZero;
+}/*end LocalRowstoColumns*/
+
+  // ====================================================================== 
+void ML_Epetra::Apply_BCsToMatrixRows(const int *dirichletRows, int numBCRows, const Epetra_CrsMatrix & Matrix)
+{
+  /* This function zeros out *rows* of Matrix that correspond to Dirichlet rows.
+     Input:
+         Matrix             matrix
+     Output:
+         Grad               matrix with Dirichlet *rows* zeroed out
+
+     Comments: The graph of Matrix is unchanged.
+  */
+  
+  // -------------------------
+  // now zero out the rows
+  // -------------------------
+  for (int i=0; i < numBCRows; i++) {
+    int numEntries;
+    double *vals;
+    int *cols;
+    Matrix.ExtractMyRowView(dirichletRows[i],numEntries,vals,cols);
+    for (int j=0; j < numEntries; j++)
+      vals[j] = 0.0;
+  }/*end for*/
+}/*end Apply_BCsToMatrixRows*/
+
+
+
+// ====================================================================== 
+void ML_Epetra::Apply_BCsToMatrixColumns(const Epetra_IntVector &dirichletColumns,const Epetra_CrsMatrix & Matrix){
+  /* This function zeros out columns of Matrix.
+     Input:
+         dirichletColumns   outpuy from FindLocalDirichletColumnsFromRow
+         Matrix             matrix to nuke columns of 
+     Output:
+         Matrix             matrix with columns zeroed out
+
+     Comments: The graph of Matrix is unchanged.
+  */
+  for (int i=0; i < Matrix.NumMyRows(); i++) {
+    int numEntries;
+    double *vals;
+    int *cols;
+    Matrix.ExtractMyRowView(i,numEntries,vals,cols);
+    for (int j=0; j < numEntries; j++) {
+      if (dirichletColumns[ cols[j] ] > 0)  vals[j] = 0.0;
+    }/*end for*/
+  }/*end for*/
+}/* end Apply_BCsToMatrixColumns */
+
+
+// ====================================================================== 
+void ML_Epetra::Apply_BCsToMatrixColumns(const int *dirichletRows, int numBCRows, const Epetra_CrsMatrix & Matrix){
+  /* This function zeros out columns of Matrix.
+     Input:
+         dirichletRows      output from FindLocalDirichletRowsFromOnesAndZeros
+         numBCRows          output from FindLocalDirichletRowsFromOnesAndZeros
+         Matrix             matrix to nuke columns of 
+     Output:
+         Matrix             matrix with columns zeroed out
+
+     Comments: The graph of Matrix is unchanged.
+  */
+  Epetra_IntVector* dirichletColumns=FindLocalDirichletColumnsFromRows(dirichletRows,numBCRows,Matrix);
+  Apply_BCsToMatrixColumns(*dirichletColumns,Matrix);
+  delete dirichletColumns;  
+}/* end Apply_BCsToMatrixColumns */
+
+// ====================================================================== 
+void ML_Epetra::Apply_BCsToMatrixColumns(const Epetra_RowMatrix & iBoundaryMatrix, const Epetra_RowMatrix & iMatrix){
+  const Epetra_CrsMatrix *BoundaryMatrix = dynamic_cast<const Epetra_CrsMatrix*> (&iBoundaryMatrix);
+  const Epetra_CrsMatrix *Matrix = dynamic_cast<const Epetra_CrsMatrix*>(&iMatrix);
+
+  if (BoundaryMatrix == 0 || Matrix == 0) {
+    std::cout << "Not applying Dirichlet boundary conditions to gradient "
+         << "because cast failed." << std::endl;
+    return;
+  }
+
+  // locate Dirichlet edges
+  int numBCRows;
+  int *dirichletRows = FindLocalDiricheltRowsFromOnesAndZeros(*Matrix,numBCRows);
+  Apply_BCsToMatrixColumns(dirichletRows,numBCRows,*Matrix);
+
+  delete [] dirichletRows;
+}/* end Apply_BCsToMatrixColumns */
+
+
+
+// ====================================================================== 
+void ML_Epetra::Remove_Zeroed_Rows(const Epetra_CrsMatrix & Matrix,double tol)
+#define ABS(x) ((x)>0?(x):(-(x)))
+{
+  /* Finds zeroed out rows and plops a 1 on the diagonal
+     rows/columns to nuke.
+     Input:
+         Matrix             matrix
+     Output:
+         Grad               matrix with zerod out rows getting a one
+
+     Comments: The graph of Matrix is unchanged.
+  */
+  int i,j,N=Matrix.NumMyRows();
+  int numEntries, gridx,cidx;
+  double *vals;
+  int *cols;
+
+  /* Find zero'd the rows, add ones to diagonal */
+  for (i=0; i < N; i++) {
+    Matrix.ExtractMyRowView(i,numEntries,vals,cols);
+    gridx=Matrix.GRID(i);
+    if(numEntries==0) printf("WARNING: row %d has no entries\n",gridx);
+    for (j=0, cidx=-1; j < numEntries; j++){
+      if(ABS(vals[j])>tol) {cidx=-1;break;}
+      if(gridx == Matrix.GCID(cols[j])) cidx=j;
+    }/*end for*/
+    if(cidx!=-1) {
+      for (j=0; j < numEntries; j++)
+        vals[j]=0.0;      
+      vals[cidx]=1.0;     
+    }
+  }/*end for*/
+  
+}/*end Apply_OAZToMatrix*/
+
+
+
+
+// ====================================================================== 
+void ML_Epetra::Apply_OAZToMatrix(int *dirichletRows, int numBCRows, const Epetra_CrsMatrix & Matrix)
+{
+  /* This function does row/column ones-and-zeros on a matrix, given the
+     rows/columns to nuke.
+     Input:
+         Matrix             matrix
+     Output:
+         Grad               matrix with Dirichlet rows/columns OAZ'd.
+
+     Comments: The graph of Matrix is unchanged.
+  */
+
+  int numEntries,grid;
+  double *vals;
+  int *cols;
+
+  /* Find the local column numbers to nuke */
+  Epetra_IntVector *dirichletColumns=LocalRowstoColumns(dirichletRows,numBCRows,Matrix);
+
+  /* Zero the columns */
+  for (int i=0; i < Matrix.NumMyRows(); i++) {
+    Matrix.ExtractMyRowView(i,numEntries,vals,cols);
+    for (int j=0; j < numEntries; j++) 
+      if ((*dirichletColumns)[ cols[j] ] > 0)
+        vals[j] = 0.0;          
+  }/*end for*/
+
+  
+  /* Zero the rows, add ones to diagonal */
+  for (int i=0; i < numBCRows; i++) {
+    Matrix.ExtractMyRowView(dirichletRows[i],numEntries,vals,cols);
+    grid=Matrix.GRID(dirichletRows[i]);
+    for (int j=0; j < numEntries; j++)
+      if(grid==Matrix.GCID(cols[j])) vals[j]=1.0;
+      else vals[j] = 0.0;
+  }/*end for*/
+
+  delete dirichletColumns;  
+}/*end Apply_OAZToMatrix*/
+
+
+
+
+
+// ====================================================================== 
+void ML_Epetra::Apply_BCsToGradient(
+             const Epetra_RowMatrix & iEdgeMatrix,
+             const Epetra_RowMatrix & iGrad)
+{
+  /* This function zeros out *rows* of T that correspond to Dirichlet rows in
+     the curl-curl matrix.  It mimics what was done previously in
+     ML_Tmat_applyDirichletBC().
+     Input:
+         EdgeMatrix         curl-curl matrix
+         Grad               gradient matrix
+     Output:
+         Grad               gradient matrix with *rows* zeroed out
+
+     Comments: The graph of Grad is unchanged.
+  */
+
+  const Epetra_CrsMatrix *EdgeMatrix = dynamic_cast<const Epetra_CrsMatrix*>
+                                           (&iEdgeMatrix );
+  const Epetra_CrsMatrix *Grad = dynamic_cast<const Epetra_CrsMatrix*>(&iGrad );
+
+  if (EdgeMatrix == 0 || Grad == 0) {
+    std::cout << "Not applying Dirichlet boundary conditions to gradient "
+         << "because cast failed." << std::endl;
+    return;
+  }
+
+  // locate Dirichlet edges
+  int *dirichletEdges = new int[EdgeMatrix->NumMyRows()];
+  int numBCEdges = 0;
+  for (int i=0; i<EdgeMatrix->NumMyRows(); i++) {
+    int numEntries, *cols;
+    double *vals;
+    int ierr = EdgeMatrix->ExtractMyRowView(i,numEntries,vals,cols);
+    if (ierr == 0) {
+      int nz=0;
+      for (int j=0; j<numEntries; j++) if (vals[j] != 0.0) nz++;
+      if (nz == 1) {
+        dirichletEdges[numBCEdges++] = i;
+      }
+    }
+  }
+  
+  // -------------------------
+  // now zero out the rows
+  // -------------------------
+  for (int i=0; i < numBCEdges; i++) {
+    int numEntries;
+    double *vals;
+    int *cols;
+    Grad->ExtractMyRowView(dirichletEdges[i],numEntries,vals,cols);
+    for (int j=0; j < numEntries; j++)
+      vals[j] = 0.0;
+  }
+  delete [] dirichletEdges;
+} //Apply_BCsToGradient
+
+
+
+// ============================================================================
+
+#ifdef HAVE_ML_EPETRAEXT
+Epetra_RowMatrix* ML_Epetra::ModifyEpetraMatrixColMap(const Epetra_RowMatrix &A,
+                         EpetraExt::CrsMatrix_SolverMap &transform,
+                         const char *matrixLabel, bool verbose)
+{
+    Epetra_RowMatrix *B;
+    Epetra_CrsMatrix *Acrs;
+
+    const Epetra_CrsMatrix *Atmp = dynamic_cast<const Epetra_CrsMatrix*>(&A);
+    if (Atmp != 0) {
+      Acrs = const_cast<Epetra_CrsMatrix*>(Atmp);
+      B = &(transform(*Acrs));
+    }
+    else B = const_cast<Epetra_RowMatrix *>(&A);
+
+    if (verbose && !A.Comm().MyPID()) {
+      if (B != &A) printf("** Transforming column map of %s matrix\n", matrixLabel);
+      else printf("** Leaving column map of %s matrix unchanged\n",matrixLabel);
+    }
+
+    return B;
+} //ModifyEpetraMatrixColMap()
+#endif
+
+
+// ====================================================================== 
+
+int ML_Epetra_CrsGraph_matvec(ML_Operator *data, int in, double *p,
+                              int out, double *ap)
+{
+  cerr << "ML_Epetra_CrsGraph_matvec() not implemented." << std::endl;
+  ML_RETURN(-1);
+}
+
+// ====================================================================== 
+
+int ML_Epetra_CrsGraph_getrow(ML_Operator *data, int N_requested_rows,
+                              int requested_rows[], int allocated_space, 
+                              int columns[], double values[],
+                              int row_lengths[])
+{
+  int nz_ptr = 0;
+  int NumEntries;
+  ML_Operator *mat_in;
+
+  mat_in = (ML_Operator *) data;
+
+  Epetra_CrsGraph *Graph =  (Epetra_CrsGraph *) ML_Get_MyGetrowData(mat_in);
+  
+  for (int i = 0; i < N_requested_rows; i++)
+  {
+    int LocalRow = requested_rows[i];
+    int *Indices;
+
+    int ierr = Graph->ExtractMyRowView(LocalRow, NumEntries, Indices);
+    if (ierr)
+      return(0); //JJH I think this is the correct thing to return if
+                 //    A->ExtractMyRowCopy returns something nonzero ..
+
+    row_lengths[i] = NumEntries;
+    if (nz_ptr + NumEntries > allocated_space)
+      return(0);
+      
+    for (int j=0; j<NumEntries; j++) {
+      columns[nz_ptr] = Indices[j];
+      values[nz_ptr++] = 1.0; // simply set each entry to 1
+    }
+  }
+
+  return(1);
+} //ML_Epetra_CrsGraph_getrow
+
+// ====================================================================== 
+int ML_Epetra_CrsGraph_comm_wrapper(double vec[], void *data)
+{
+  Epetra_CrsGraph*A = (Epetra_CrsGraph*) data;
+
+  if (A->Comm().NumProc()==1) return(1); // Nothing to do in serial mode.
+
+  if( A->Importer() != 0 ) {
+    // this is SLOW
+    const Epetra_BlockMap& RowMap = A->RowMap(); // this is a block map
+    const Epetra_BlockMap& ColMap = A->ColMap(); // this is a block map
+
+    Epetra_Map RowMap2(-1, RowMap.NumMyElements(), RowMap.MyGlobalElements(), ColMap.IndexBase(), RowMap.Comm());
+    Epetra_Map ColMap2(-1, ColMap.NumMyElements(), ColMap.MyGlobalElements(), ColMap.IndexBase(), ColMap.Comm());
+    Epetra_Import Importer(ColMap2, RowMap2);
+
+    Epetra_Vector X_target(View, 
+                           ColMap2,
+                           //A->Importer()->TargetMap(),
+			   vec); //ghosted
+    Epetra_Vector X_source(View, 
+                           RowMap2, 
+                           //A->Importer()->SourceMap(),
+			   vec); //loc only
+  
+    X_target.Import(X_source, 
+                     Importer,
+                    //*(A->Importer()), 
+                    Insert);
+  }
+  
+  return(1);
+}
+// ======================================================================
+
+int ML_Operator_WrapEpetraCrsGraph(Epetra_CrsGraph* Graph, ML_Operator *newMatrix)
+{
+  int isize, osize;
+
+  osize = Graph->RangeMap().NumMyElements();
+  isize = Graph->DomainMap().NumMyElements();
+  assert (Graph->HaveColMap() == true);
+  int N_ghost = Graph->NumMyBlockCols() - isize;
+
+  if (N_ghost < 0) N_ghost = 0;
+
+  ML_Operator_Set_ApplyFuncData(newMatrix, isize, osize,
+                                (void*) Graph, osize,
+                                NULL, 0);
+
+  ML_CommInfoOP_Generate( &(newMatrix->getrow->pre_comm), 
+                         ML_Epetra_CrsGraph_comm_wrapper, (void *) Graph, 
+                         newMatrix->comm, isize, N_ghost);
+
+  ML_Operator_Set_Getrow(newMatrix, newMatrix->outvec_leng,
+                         ML_Epetra_CrsGraph_getrow);
+
+  ML_Operator_Set_ApplyFunc (newMatrix, ML_Epetra_CrsGraph_matvec);
+
+  return 0;
+}
+
+// ======================================================================
+
+int EpetraMatrix2MLMatrix(ML *ml_handle, int level,
+                         Epetra_RowMatrix * A)
+{
+  int isize, osize;
+
+  osize = A->NumMyRows();
+  isize = osize;
+  int N_ghost = A->NumMyCols() - A->NumMyRows();
+
+  if (N_ghost < 0) N_ghost = 0;  // A->NumMyCols() = 0 for an empty matrix
+
+  ML_Init_Amatrix(ml_handle, level,isize, osize, (void *) A);
+  ML_Set_Amatrix_Getrow(ml_handle, level, ML_Epetra_RowMatrix_getrow,
+                        ML_Epetra_comm_wrapper, isize+N_ghost);
+
+  ML_Set_Amatrix_Matvec(ml_handle,  level, ML_Epetra_matvec);
+
+  return 1;
+}
+
+// ======================================================================
+int ML_back_to_epetraCrs(ML_Operator *Mat1Mat2, ML_Operator *Result, 
+			 ML_Operator *Mat1, ML_Operator *Mat2)
+{
+  //---------------------------------------------------------------------------
+  Epetra_CrsMatrix *Mat1_epet = (Epetra_CrsMatrix *) Mat1->data;
+  Epetra_CrsMatrix *Mat2_epet = (Epetra_CrsMatrix *) Mat2->data;
+  
+  //---------------------------------------------------------------------------
+  // for temporary use create a linear row map, range map, domain map and a matrix
+  Epetra_Map* linrowmap = new Epetra_Map(Mat1_epet->RowMap().NumGlobalElements(),
+                                         Mat1_epet->RowMap().NumMyElements(),0,
+                                         Mat1_epet->Comm());
+  Epetra_Map* linrangemap = new Epetra_Map(Mat1_epet->OperatorRangeMap().NumGlobalElements(),
+                                           Mat1_epet->OperatorRangeMap().NumMyElements(),0,
+                                           Mat1_epet->Comm());
+  Epetra_Map* lindomainmap = new Epetra_Map(Mat2_epet->OperatorDomainMap().NumGlobalElements(),
+                                            Mat2_epet->OperatorDomainMap().NumMyElements(),0,
+                                            Mat2_epet->Comm());
+  Epetra_CrsMatrix* tmpresult = new Epetra_CrsMatrix(Copy,*linrowmap,500,false);
+  
+
+  // see results as ML_Operator
+  //ML_Operator_Print(Mat2,"Mat2");
+  //ML_Operator_Print(Mat1Mat2,"Mat1Mat2");
+  
+  // warning
+  // when either Mat1 or Mat2 contain empty columns, this routine fails.
+  // This is due to difering philosophies in ML and Epetra w.r.t
+  // local column indices. In case of empty columns, ML keeps those
+  // local column indices while Epetra strips them out.
+  // This appears in serial and in parallel.
+  // I currently do not see any elegant way to fix this easily.
+  // (One fix proposed by Ray would be to add another layer of indirect addressing to
+  // the ML_Epetra_CrsMatrix_getrow to fix this. But this will come at
+  // some price and in most cases will not be needed)
+  
+  //---------------------------------------------------------------------------
+  // The result matrix Mat1Mat2:
+  // - ML created a new row numbering that is a linear map for the rows 
+  //   no matter what the input maps were
+  // - row indices are local
+  // - ML created a column numbering matching the new row map
+  // - col indices are global
+  
+  //---------------------------------------------------------------------------
+  // fill the temporary matrix tmpresult which has linear maps as well
+  int allocated = 0, row_length;
+  int *bindx = NULL;
+  double *val = NULL;
+  int* global_rows = linrowmap->MyGlobalElements();
+  if (Mat1Mat2->getrow->Nrows != Mat1_epet->RowMap().NumMyElements())
+  {
+    std::cout << "Rowmap of ML_Operator and Epetra_CrsMatrix are different!\n";
+    exit(-1);
+  }
+  for (int i=0; i<Mat1Mat2->getrow->Nrows; ++i) 
+  {
+    // get the row
+    ML_get_matrix_row(Mat1Mat2, 1, &i, &allocated, &bindx, &val,&row_length, 0);
+    // ML pads empty rows with a zero, take these out again in the result
+    if (row_length==1 && val[0]==0.0) continue;
+    // the row index i is an ml linear map
+    // the row index global_rows[i] is the true Epetra grid
+    // we have columns bindx which are global but refer to MLs linear map
+    // this matches the map of tmpresult
+    int err = tmpresult->InsertGlobalValues(global_rows[i],row_length, 
+                                            val,bindx);
+    if (err!=0 && err != 1) std::cout << "tmpresult->InsertGlobalValues returned " << err << std::endl;
+  }
+  if (bindx != NULL) ML_free(bindx);
+  if (val != NULL) ML_free(val);
+
+  int err = tmpresult->FillComplete(*lindomainmap,*linrangemap);
+  if (err) 
+  {
+    cerr <<"Error in Epetra_CrsMatrix FillComplete" << err << std::endl;
+    EPETRA_CHK_ERR(err);
+  }
+  delete linrowmap;
+  delete linrangemap;
+  delete lindomainmap;
+
+  //---------------------------------------------------------------------------
+  // compute the global column lookup of the final result matrix
+  // the unknown column map is an overlapping version of the Mat2_epet->OperatorDomainMap()
+  const Epetra_Comm& comm = Mat2_epet->Comm();
+  const Epetra_Map& dommap = Mat2_epet->OperatorDomainMap();
+  std::vector<int> gcolumns(dommap.NumGlobalElements());
+  int countold=0;
+  int count=0;
+  for (int proc=0; proc<comm.NumProc(); ++proc)
+  {
+    if (proc==comm.MyPID())
+      for (int i=0; i<dommap.NumMyElements(); ++i)
+      {
+        //cout << "Proc " << proc << " gcolumns[" << countold << "+" << count << "] = " << dommap.GID(i) << std::endl;
+        gcolumns[countold+count] = dommap.GID(i);
+        if (gcolumns[countold+count]<0) std::cout << "Cannot find gcid for lcid\n";
+        ++count;
+      }
+    comm.Broadcast(&count,1,proc);
+    comm.Broadcast(&gcolumns[countold],count,proc);
+    countold += count;
+    count=0;
+  }
+  
+  //if (comm.MyPID()==0)
+  //for (int i=0; i<(int)gcolumns.size(); ++i) std::cout << "gcolumns[ " << i << "] = " << gcolumns[i] << std::endl;
+  //---------------------------------------------------------------------------
+  // create the final result matrix with the correct row map
+  Epetra_CrsMatrix *Result_epet = new Epetra_CrsMatrix(Copy,Mat1_epet->RowMap(),
+                                                       20,false);
+  //---------------------------------------------------------------------------
+  // fill the final result from the tmpresult
+  std::vector<int> gcid(50);
+  for (int i=0; i<tmpresult->NumMyRows(); ++i)
+  {
+    int lrid = i; // holds for both matrices
+    int grid = Result_epet->GRID(i); // holds for Result_epet
+    if (grid<0) std::cout << "Cannot find grid for lrid\n";
+    int numindices;
+    int* indices;
+    double* values;
+    int err = tmpresult->ExtractMyRowView(lrid,numindices,values,indices);
+    if (err) std::cout << "tmpresult->ExtractMyRowView returned " << err << std::endl;
+    // indices[j] are lcid which is what we wanted
+    if (numindices>(int)gcid.size()) gcid.resize(numindices);
+    for (int j=0; j<numindices; ++j)
+    {
+      // get the gcid in the tmpresult matrix
+      // gcid in tmpresult is from the linear column map
+      int tmpgcid = tmpresult->GCID(indices[j]);
+      if (tmpgcid<0 || tmpgcid>=(int)gcolumns.size()) 
+        std::cout << "Cannot find tmpgcid " << tmpgcid << " for lcid (out of range)\n";
+      // get the gcid from the lookup vector
+      gcid[j] = gcolumns[tmpgcid];
+    }
+    // insert row into final result matrix
+    err = Result_epet->InsertGlobalValues(grid,numindices,values,&(gcid[0]));
+    if (err < 0) std::cout << "Result_epet->InsertGlobalValues returned " << err << std::endl;
+  }
+  int ierr=Result_epet->FillComplete(Mat2_epet->OperatorDomainMap(),
+                                     Mat1_epet->OperatorRangeMap());
+  if (ierr!=0) {
+    cerr <<"Error in Epetra_CrsMatrix FillComplete" << ierr << std::endl;
+    EPETRA_CHK_ERR(ierr);
+  }
+
+  // tidy up
+  delete tmpresult;
+  gcolumns.clear();
+  gcid.clear();
+  
+  // wrap the result
+  ML_Operator_WrapEpetraMatrix((Epetra_RowMatrix *) Result_epet, Result);
+
+  return 1;
+}
+
+// ======================================================================
+
+Epetra_CrsMatrix *Epetra_MatrixMult(Epetra_RowMatrix *B_crs, Epetra_RowMatrix *Bt_crs)
+{
+  ML_Comm *comm, *temp;
+  Epetra_RowMatrix *result;
+
+  temp = global_comm;
+  ML_Comm_Create(&comm);
+#ifdef ML_MPI
+  // Use the same communicator as A if we're using MPI.
+  const Epetra_MpiComm * Mcomm=dynamic_cast<const Epetra_MpiComm*>(&B_crs->Comm());
+  if(Mcomm) ML_Comm_Set_UsrComm(comm,Mcomm->GetMpiComm());
+#endif
+
+  ML_Operator *B_ml, *Bt_ml, *BBt_ml;
+  B_ml  = ML_Operator_Create(comm);
+  Bt_ml = ML_Operator_Create(comm);
+  BBt_ml  = ML_Operator_Create(comm);
+  ML_Operator_WrapEpetraMatrix(B_crs, B_ml);
+  ML_Operator_WrapEpetraMatrix(Bt_crs, Bt_ml);
+  ML_2matmult(B_ml, Bt_ml, BBt_ml, ML_EpetraCRS_MATRIX);
+
+  ML_Comm_Destroy(&comm);
+  global_comm = temp;
+
+  /* Need to blow about BBt_ml but keep epetra stuff */
+
+  result = (Epetra_RowMatrix *) BBt_ml->data;
+  ML_Operator_Destroy(&B_ml);
+  ML_Operator_Destroy(&Bt_ml);
+  ML_Operator_Destroy(&BBt_ml);
+
+  return dynamic_cast<Epetra_CrsMatrix*>(result);
+   
+}
+
+// ====================================================================== 
+
+Epetra_CrsMatrix *Epetra_MatrixAdd(Epetra_RowMatrix *B_crs, Epetra_RowMatrix *Bt_crs, double scalar)
+{
+  ML_Comm *comm, *temp;
+
+  temp = global_comm;
+  ML_Comm_Create(&comm);
+#ifdef ML_MPI
+  // Use the same communicator as A if we're using MPI.
+  const Epetra_MpiComm * Mcomm=dynamic_cast<const Epetra_MpiComm*>(&B_crs->Comm());
+  if(Mcomm) ML_Comm_Set_UsrComm(comm,Mcomm->GetMpiComm());
+#endif
+  ML_Operator *B_ml, *Bt_ml, *BBt_ml;
+  B_ml  = ML_Operator_Create(comm);
+  Bt_ml = ML_Operator_Create(comm);
+  BBt_ml  = ML_Operator_Create(comm);
+  ML_Operator_WrapEpetraMatrix(B_crs, B_ml);
+  ML_Operator_WrapEpetraMatrix(Bt_crs, Bt_ml);
+  Epetra_CrsMatrix *BBt_crs = new Epetra_CrsMatrix(Copy,
+				            B_crs->RowMatrixRowMap(),
+					    B_crs->RowMatrixColMap(), 0);
+  BBt_ml->data = (void *) BBt_crs;
+  ML_Operator_Add(B_ml, Bt_ml, BBt_ml, ML_EpetraCRS_MATRIX, scalar);
+
+  BBt_crs->FillComplete(B_crs->OperatorRangeMap(),
+                        B_crs->OperatorDomainMap());
+
+  ML_Comm_Destroy(&comm);
+  global_comm = temp;
+
+  /* Need to blow about BBt_ml but keep epetra stuff */
+
+  ML_Operator_Destroy(&B_ml);
+  ML_Operator_Destroy(&Bt_ml);
+  ML_Operator_Destroy(&BBt_ml);
+
+  return BBt_crs;
+   
+}
+
+int ML_Epetra_CRSinsert(ML_Operator *A, int row, int *cols, double *vals, int length)
+{
+  int *global_rows;
+  Epetra_CrsMatrix *A_crs = (Epetra_CrsMatrix *) A->data;
+
+  global_rows = A_crs->RowMatrixRowMap().MyGlobalElements();
+  A_crs->InsertGlobalValues(global_rows[row],length, vals, cols);
+
+  return 0;
+}
+
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+extern "C" 
+{
+#endif
+#endif
+
+Epetra_CrsMatrix * Q  = NULL;
+Epetra_FECrsMatrix *  Qt = NULL; 
+
+// ======================================================================
+ML_Operator * ML_BuildQ( int StartingNumElements,
+			 int ReorderedNumElements,
+			 int NumPDEEqns, int NullSpaceDim,
+			 int * reordered_decomposition,
+			 double * StartingNullSpace,
+			 double * ReorderedNullSpace,
+			 int ComputeNewNullSpace,
+			 double * StartingBdry, double * ReorderedBdry,
+			 USR_COMM mpi_communicator,
+			 ML_Comm *ml_communicator ) 
+{
+  
+  ML_Operator * ML_Q2;
+  
+#ifdef ML_MPI
+  Epetra_MpiComm Comm( mpi_communicator );
+#else
+  Epetra_SerialComm Comm;
+#endif
+  
+  Epetra_Map StartingMap(-1,StartingNumElements*NumPDEEqns,0,Comm);
+  Epetra_Map ReorderedMap(-1,ReorderedNumElements*NumPDEEqns,0,Comm);
+  
+  Q = new Epetra_CrsMatrix(Copy,StartingMap,1);
+
+  int * MyGlobalElements = StartingMap.MyGlobalElements();
+
+  // fill Q
+  for( int i=0 ; i<StartingNumElements ; i++ ) {
+    // i and PointCol are for the amalagamated configuration
+    double one = 1.0;
+    int PointCol = reordered_decomposition[i];
+    for( int j=0 ; j<NumPDEEqns ; ++j ) {
+      // GlobalRow and GlobalCol are for the amalgamated conf
+      int GlobalRow = MyGlobalElements[i*NumPDEEqns] + j;
+      int GlobalCol = PointCol*NumPDEEqns + j;
+      Q->InsertGlobalValues(GlobalRow, 1, &one, &GlobalCol );
+      // It appears that this is the safest way to code
+      // the Q operator. If we skip the diagonal values, then
+      // the ML-epetra conversion generally crashes with
+      // Zoltan aggregation. Appearantly, ParMETIS without
+      // Zoltan does not require the diagonal element...
+      // This is just slightly more expensive....
+      GlobalRow = MyGlobalElements[i*NumPDEEqns] + j;
+      GlobalCol = GlobalRow;
+      double zero = 0.0;
+      // NOTE: this function may return a warning
+      // (if the element has already been inserted)
+      Q->InsertGlobalValues(GlobalRow, 1, &zero, &GlobalCol );
+    }
+  }
+  
+  Q->FillComplete(ReorderedMap,StartingMap);
+  
+  {int itemp;
+  Comm.MaxAll(&ComputeNewNullSpace,&itemp,1);
+  if( itemp == 1 ) ComputeNewNullSpace = 1;
+  }
+  
+  if( ComputeNewNullSpace == 1 ) {
+
+    if( NumPDEEqns == NullSpaceDim ) {
+
+      double ** StartArrayOfPointers = new double * [NullSpaceDim];
+      double ** ReordArrayOfPointers = new double * [NullSpaceDim];
+      
+      for( int k=0 ; k<NullSpaceDim ; ++k ) {
+	StartArrayOfPointers[k] = StartingNullSpace+k*StartingNumElements*NumPDEEqns;
+	ReordArrayOfPointers[k] = ReorderedNullSpace+k*ReorderedNumElements*NumPDEEqns;
+      }
+      
+      Epetra_MultiVector startNS(View,StartingMap,StartArrayOfPointers,NullSpaceDim);
+      Epetra_MultiVector reordNS(View,ReorderedMap,ReordArrayOfPointers,NullSpaceDim);
+      
+      Q->Multiply(true,startNS,reordNS);
+      
+      delete [] StartArrayOfPointers;
+      delete [] ReordArrayOfPointers;
+
+    } else {
+      
+      Epetra_Vector startNS2(StartingMap);
+      Epetra_Vector reordNS2(ReorderedMap);
+
+      for( int i=0 ; i<NullSpaceDim ; ++i ) {
+	startNS2.PutScalar(0.0);
+	for( int j=0 ; j<StartingNumElements ; ++j ) {
+	  startNS2[j] = StartingNullSpace[j*NullSpaceDim+i];
+	}
+	Q->Multiply(true,startNS2,reordNS2);
+	for( int j=0 ; j<ReorderedNumElements ; ++j ) {
+	  ReorderedNullSpace[j*NullSpaceDim+i] = reordNS2[j];
+	}
+      }
+    }
+  }
+
+  double * Start = NULL;
+  double * Reord = NULL;
+  
+  if( StartingNumElements != 0 ) Start = new double[StartingNumElements*NumPDEEqns];
+  if( ReorderedNumElements != 0 ) Reord = new double[ReorderedNumElements*NumPDEEqns];
+
+  Epetra_Vector xxx(View,StartingMap,Start);
+  Epetra_Vector yyy(View,ReorderedMap,Reord);
+
+  xxx.PutScalar(0.0);
+  yyy.PutScalar(0.0);
+
+  for( int i=0 ; i<StartingNumElements ; ++i ) {
+    xxx[i*NumPDEEqns] = StartingBdry[i];
+  }
+
+  Q->Multiply(true,xxx,yyy);
+
+  ML_Q2 = ML_Operator_Create( ml_communicator );  
+  
+  ML_Operator_WrapEpetraMatrix(Q, ML_Q2);
+
+  for( int i=0 ; i<ReorderedNumElements ; ++i ) {
+    ReorderedBdry[i] = yyy[i*NumPDEEqns];
+  }
+  
+  if( Start != NULL ) delete [] Start;
+  if( Reord != NULL ) delete [] Reord;
+
+  return ML_Q2;
+}
+
+// ======================================================================
+int ML_ApplyQ(int StartingNumElements,
+	      int ReorderedNumElements,
+	      int NumVectors,
+	      double* StartingVectors,
+	      double* ReorderedVectors)
+{
+
+  int NumPDEEqns = Q->OperatorRangeMap().NumMyElements() / StartingNumElements;
+
+  if (NumPDEEqns == 1) {
+ 
+    // in this case I can go on with pointers
+    double** StartArrayOfPointers = new double * [NumVectors];
+    double** ReordArrayOfPointers = new double * [NumVectors];
+
+    for (int k = 0 ; k < NumVectors ; ++k) {
+      StartArrayOfPointers[k] = StartingVectors + k * StartingNumElements;
+      ReordArrayOfPointers[k] = ReorderedVectors + k * ReorderedNumElements;
+    }
+
+    Epetra_MultiVector startNS(View,Q->OperatorRangeMap(),
+			       StartArrayOfPointers,NumVectors);
+    Epetra_MultiVector reordNS(View,Q->OperatorDomainMap(),
+			       ReordArrayOfPointers,NumVectors);
+    Q->Multiply(true,startNS,reordNS);
+
+    delete [] StartArrayOfPointers;
+    delete [] ReordArrayOfPointers;
+
+  }
+  else {
+    // here instead I must allocate, can be coded better
+    assert (Q->OperatorRangeMap().NumMyElements() == StartingNumElements * NumPDEEqns);
+    assert (Q->OperatorDomainMap().NumMyElements() == ReorderedNumElements * NumPDEEqns);
+
+    Epetra_MultiVector startNS(Q->OperatorRangeMap(), NumVectors);
+    Epetra_MultiVector reordNS(Q->OperatorDomainMap(), NumVectors);
+    startNS.PutScalar(0.0);
+    reordNS.PutScalar(0.0);
+
+    for (int k = 0 ; k < NumVectors ; ++k) {
+      for (int i = 0 ; i < StartingNumElements ; ++i) {
+	startNS[k][i * NumPDEEqns] = StartingVectors[i + k * StartingNumElements];
+      }
+    }
+    for (int k = 0 ; k < NumVectors ; ++k) {
+      for (int i = 0 ; i < ReorderedNumElements ; ++i) {
+	reordNS[k][i * NumPDEEqns] = ReorderedVectors[i + k * ReorderedNumElements];
+      }
+    }
+
+    Q->Multiply(true,startNS,reordNS);
+
+    for (int k = 0 ; k < NumVectors ; ++k) {
+      for (int i = 0 ; i < ReorderedNumElements ; ++i) {
+	ReorderedVectors[i + k * ReorderedNumElements] = reordNS[k][i * NumPDEEqns];
+      }
+    }
+
+  }
+
+  return 0;
+}
+
+void ML_DestroyQ(void) 
+{
+
+  delete Q;
+  Q = NULL;
+
+  return;
+  
+} /* ML_DestroyQ */
+
+#if 0
+// NOTE: this works ONLY if NumPDEEqns == 1. To be changed as
+// done with ML_BuildQ for the general case
+
+ML_Operator * ML_BuildQt( int StartingNumElements,
+			  int ReorderedNumElements,
+			  int reordered_decomposition[],
+			  USR_COMM mpi_communicator,
+			  ML_Comm *ml_communicator ) 
+{
+  
+  ML_Operator * ML_Qt2;
+
+  std::cout << "CHECK MEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE" << std::endl;
+  exit( EXIT_FAILURE );
+  
+#ifndef ML_MPI
+  /* ********************************************************************** */
+  /* ONe should not call this function with one processor only (as he has   */
+  /* nothing to redistributed. I simply return (this is also checked later) */
+  /* ********************************************************************** */
+
+  return NULL;
+#else
+
+  Epetra_MpiComm Comm( mpi_communicator );
+
+  if( Comm.NumProc() == 1 ) return NULL;
+
+  Epetra_Map StartingMap(-1,StartingNumElements,0,Comm);
+  Epetra_Map ReorderedMap(-1,ReorderedNumElements,0,Comm);
+
+  Qt = new Epetra_FECrsMatrix(Copy,ReorderedMap,1);
+
+  int * MyGlobalElements = StartingMap.MyGlobalElements();
+
+  // fill Q
+  for( int i=0 ; i<StartingNumElements ; ++i ) {
+    int row = reordered_decomposition[i];
+    double one = 1.0;
+    int indices = MyGlobalElements[i];
+    Qt->SumIntoGlobalValues(1, &row, 1, &indices, &one );
+  }
+
+  Qt->GlobalAssemble(false);
+
+  // Q will be applied to vectors defined on StartingMap,
+  // and the output vector will be defined on ReorderdMap
+  Qt->FillComplete(ReorderedMap,StartingMap);
+  
+  ML_Qt2 = ML_Operator_Create( ml_communicator );
+
+  ML_Operator_WrapEpetraMatrix( Qt, ML_Qt2);
+
+  return ML_Qt2;
+#endif
+  
+} /* ML_BuildQt */
+
+void ML_DestroyQt( void ) 
+{
+
+  delete Qt;
+  Qt = NULL;
+
+  return;
+  
+} /* ML_DestroyQt */
+#endif
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+#endif
+
+
+// ======================================================================
+int ML_Operator2EpetraCrsMatrix(ML_Operator *Amat, Epetra_CrsMatrix * &
+                                CrsMatrix, int & MaxNumNonzeros,
+                                bool CheckNonzeroRow, double & CPUTime, int base,bool verbose)
+{
+  int    isize_offset, osize_offset;
+  int Nghost;
+  ML_Comm *comm;
+
+  comm = Amat->comm;
+#ifdef ML_MPI
+  MPI_Comm mpi_comm ;
+  mpi_comm = comm->USR_comm; 
+  Epetra_MpiComm EpetraComm( mpi_comm ) ; 
+#else
+  Epetra_SerialComm EpetraComm ; 
+#endif  
+
+  Epetra_Time Time(EpetraComm);
+
+  if (Amat->getrow->post_comm != NULL)  {
+    if (Amat->comm->ML_mypid == 0)
+      pr_error("Error: Please transpose matrix with ML_Operator_Transpose_byrow()\n       before calling ML_Operator2EpetraCrsMatrix().\n");
+  }
+
+  if (Amat->getrow->pre_comm == NULL)
+    Nghost = 0;
+  else {
+    if (Amat->getrow->pre_comm->total_rcv_length <= 0)
+      ML_CommInfoOP_Compute_TotalRcvLength(Amat->getrow->pre_comm);
+    Nghost = Amat->getrow->pre_comm->total_rcv_length;
+  }
+
+  int isize = Amat->invec_leng;
+  int osize = Amat->outvec_leng;
+
+  int g_isize, g_osize;
+  EpetraComm.SumAll(&isize,&g_isize,1);
+  EpetraComm.SumAll(&osize,&g_osize,1);
+  bool isSquare = (g_isize == g_osize);
+
+  EpetraComm.ScanSum(&isize,&isize_offset,1); isize_offset-=isize + base;
+  EpetraComm.ScanSum(&osize,&osize_offset,1); osize_offset-=osize + base;
+
+  std::vector<double> global_isize; global_isize.resize(isize+Nghost+1);
+  std::vector<int>    global_isize_as_int; global_isize_as_int.resize(isize+Nghost+1);
+
+  //vector<double> global_osize(osize);
+  std::vector<int>    global_osize_as_int(osize);
+  
+  for (int i = 0 ; i < isize; i++) {
+          global_isize[i] = (double) (isize_offset + i);
+          global_isize_as_int[i] = isize_offset + i;
+  }
+          
+  for (int i = 0 ; i < osize; i++) {
+    //global_osize[i] = (double) (osize_offset + i);
+    global_osize_as_int[i] = osize_offset + i;
+  }
+  for (int i = 0 ; i < Nghost; i++) global_isize[i+isize] = -1;
+
+  Epetra_Map  rangemap( -1, osize, &global_osize_as_int[0], base, EpetraComm ) ; 
+  Epetra_Map  domainmap( -1, isize, &global_isize_as_int[0], base, EpetraComm ) ; 
+
+
+  /* Build the column map first to make sure we get communication patterns
+     correct */
+  ML_exchange_bdry(&global_isize[0],Amat->getrow->pre_comm, 
+ 		 Amat->invec_leng,comm,ML_OVERWRITE,NULL);
+
+  for ( int j = isize; j < isize+Nghost; j++ ) { 
+    global_isize_as_int[j] = (int) global_isize[j];
+  }
+  
+  Epetra_Map  colmap( -1, isize+Nghost, &global_isize_as_int[0], base, EpetraComm ) ; 
+  
+  CrsMatrix = new Epetra_CrsMatrix( Copy, rangemap, colmap, base ); 
+  
+
+  // MS // introduced variable allocation for colInd and colVal
+  // MS // improved efficiency in InsertGlobalValues
+
+  int allocated = 128;
+  std::vector<int> colInd(allocated);
+  std::vector<double> colVal(allocated);
+  int NumNonzeros;
+  int ierr;
+  int    ncnt;
+
+  MaxNumNonzeros=0;
+  
+  for (int i = 0; i < osize; i++)
+  {
+    ierr = ML_Operator_Getrow(Amat,1,&i,allocated,&colInd[0],&colVal[0],&ncnt);
+
+    if( ierr == 0 ) {
+      do {
+	allocated *= 2;
+        if (allocated > 20000) // would look strange to have such a dense row
+        {
+          cerr << "Row " << i << " on processor " << comm->ML_mypid;
+          cerr << " seems to have more than 20000 nonzeros." << std::endl;
+          cerr << "This looks suspicious, so now I abort..." << std::endl;
+          ML_EXIT(-1);
+        }
+        colInd.resize(allocated);
+        colVal.resize(allocated);
+	ierr = ML_Operator_Getrow(Amat,1,&i,allocated,&colInd[0],&colVal[0],&ncnt);
+      } while( ierr == 0 );
+    }
+
+
+    // Reallocation sanity checks for CheckNonZeroRow - CMS
+    if(ncnt==allocated){
+      allocated *= 2;
+      colInd.resize(allocated);
+      colVal.resize(allocated);      
+    }
+    
+    // MS // check out how many nonzeros we have
+    // MS // NOTE: this may result in a non-symmetric pattern for CrsMatrix
+    
+    NumNonzeros = 0;
+    bool has_diagonal=false;
+    for (int j = 0; j < ncnt; j++) {
+      has_diagonal = has_diagonal || global_osize_as_int[i]==global_isize_as_int[colInd[j]];
+      if (colVal[j] != 0.0) {
+        colInd[NumNonzeros] = global_isize_as_int[colInd[j]];
+        colVal[NumNonzeros] = colVal[j];
+        NumNonzeros++;
+      }
+    }
+    
+    if( NumNonzeros == 0 && CheckNonzeroRow ) {
+      if(verbose)
+        std::cout << "*ML*WRN* in ML_Operator2EpetraCrsMatrix : \n*ML*WRN* Global row "
+             << global_osize_as_int[i]
+             << " has no nonzero elements (and " << ncnt
+             << " zero entries)" << std::endl
+             << "*ML*WRN* Now put 1 on the diagonal...\n";
+      // insert a 1 on the diagonal
+      colInd[NumNonzeros] = global_isize_as_int[i];
+      colVal[NumNonzeros] = 1.0;
+      NumNonzeros++;
+    }
+    else if(NumNonzeros>0 && !has_diagonal && CheckNonzeroRow && isSquare) {
+      if(verbose) printf("Row %d/%d has no diagonal entry\n",i,global_osize_as_int[i]);
+      // insert a 1 on the diagonal
+      colInd[NumNonzeros] = global_isize_as_int[i];
+      colVal[NumNonzeros] = 1.0;
+      NumNonzeros++;
+    }
+      
+    MaxNumNonzeros = EPETRA_MAX(NumNonzeros,MaxNumNonzeros);
+    
+    CrsMatrix->InsertGlobalValues(global_osize_as_int[i], NumNonzeros, 
+				  &colVal[0], &colInd[0]);
+  }
+
+  CrsMatrix->FillComplete(domainmap,rangemap);
+  CrsMatrix->OptimizeStorage();
+
+  CPUTime = Time.ElapsedTime();
+
+  return 0;
+  
+} /* ML_Operator2EpetraCrsMatrix for rectangular matrices*/
+
+
+
+
+
+#if 0
+// FIXME: delete me ???
+int ML_Operator2EpetraCrsMatrix_old(ML_Operator *Ke, Epetra_CrsMatrix * &
+				CrsMatrix, int & MaxNumNonzeros,
+				bool CheckNonzeroRow, double & CPUTime)
+{
+
+  double *global_nodes, *global_rows;
+  int *global_rows_as_int, *global_nodes_as_int;
+  int    Nnodes, node_offset, row_offset;
+  int Nnodes_global, Nrows_global;
+  int Nghost_nodes;
+  int Nrows;
+  ML_Comm *comm;
+
+  comm = Ke->comm;
+#ifdef ML_MPI
+  MPI_Comm mpi_comm ;
+  mpi_comm = comm->USR_comm; 
+  Epetra_MpiComm EpetraComm( mpi_comm ) ; 
+#else
+  Epetra_SerialComm EpetraComm ; 
+#endif  
+
+  Epetra_Time Time(EpetraComm);
+
+  if (Ke->getrow->pre_comm == NULL) 
+    Nghost_nodes = 0;
+  else {
+    if (Ke->getrow->pre_comm->total_rcv_length <= 0)
+      ML_CommInfoOP_Compute_TotalRcvLength(Ke->getrow->pre_comm);
+    Nghost_nodes = Ke->getrow->pre_comm->total_rcv_length;
+  }
+
+  Nnodes = Ke->invec_leng;
+  Nrows = Ke->outvec_leng;
+
+  assert( Nnodes == Nrows );
+
+  // MS // moved to Epetra node_offset = ML_gpartialsum_int(Nnodes, comm);
+  // Nnodes_global = Nnodes;
+  // ML_gsum_scalar_int(&Nnodes_global, &dummy, comm);
+
+  // MS moved to Epetra row_offset = ML_gpartialsum_int(Nrows, comm);
+  //  Nrows_global = Nrows;
+  // ML_gsum_scalar_int(&Nrows_global, &dummy, comm);
+
+  EpetraComm.ScanSum(&Nnodes,&node_offset,1); node_offset-=Nnodes;
+  EpetraComm.ScanSum(&Nrows,&row_offset,1); row_offset-=Nrows;
+
+  EpetraComm.SumAll(&Nnodes,&Nnodes_global,1);
+  EpetraComm.SumAll(&Nrows,&Nrows_global,1);  
+
+  assert( Nnodes_global == Nrows_global ) ; 
+
+  global_nodes = new double[Nnodes+Nghost_nodes+1];
+  global_nodes_as_int = new int[Nnodes+Nghost_nodes+1];
+
+  global_rows = new double[Nrows+1];
+  global_rows_as_int = new int[Nrows+1];
+  
+  for (int i = 0 ; i < Nnodes; i++) global_nodes[i] = (double) (node_offset + i);
+  for (int i = 0 ; i < Nrows; i++) {
+    global_rows[i] = (double) (row_offset + i);
+    global_rows_as_int[i] = row_offset + i;
+  }
+  for (int i = 0 ; i < Nghost_nodes; i++) global_nodes[i+Nnodes] = -1;
+  
+  Epetra_Map  EpetraMap( Nrows_global, Nrows, global_rows_as_int, 0, EpetraComm ) ; 
+  
+  CrsMatrix = new Epetra_CrsMatrix( Copy, EpetraMap, 0 ); 
+  
+  ML_exchange_bdry(global_nodes,Ke->getrow->pre_comm, 
+ 		 Ke->invec_leng,comm,ML_OVERWRITE,NULL);
+
+  for ( int j = 0; j < Nnodes+Nghost_nodes; j++ ) { 
+    global_nodes_as_int[j] = (int) global_nodes[j];
+  }
+
+  // MS // introduced variable allocation for colInd and colVal
+  // MS // improved efficiency in InsertGlobalValues
+
+  {
+  int allocated = 1;
+  int * colInd = new int[allocated];
+  double * colVal = new double[allocated];
+  int NumNonzeros;
+  int ierr;
+  int    ncnt;
+
+  MaxNumNonzeros=0;
+  
+  for (int i = 0; i < Nrows; i++) {
+    ierr = ML_Operator_Getrow(Ke,1,&i,allocated,colInd,colVal,&ncnt);
+
+    if( ierr == 0 ) {
+      do {
+	delete [] colInd;
+	delete [] colVal;
+	allocated *= 2;
+	colInd = new int[allocated];
+	colVal = new double[allocated];
+	ierr = ML_Operator_Getrow(Ke,1,&i,allocated,colInd,colVal,&ncnt);
+      } while( ierr == 0 );
+    }
+
+    // MS // check out how many nonzeros we have
+    // MS // NOTE: this may result in a non-symmetric patter for CrsMatrix
+
+    NumNonzeros = 0;
+    for (int j = 0; j < ncnt; j++) {
+      if (colVal[j] != 0.0) {
+	colInd[NumNonzeros] = global_nodes_as_int[colInd[j]];
+	colVal[NumNonzeros] = colVal[j];
+	NumNonzeros++;
+      }
+    }
+    if( NumNonzeros == 0 && CheckNonzeroRow ) {
+      std::cout << "*ML*WRN* in ML_Operator2EpetraCrsMatrix : \n*ML*WRN* Global row "
+	   << global_rows_as_int[i]
+	   << " has no nonzero elements (and " << ncnt
+	   << " zero entries)" << std::endl
+	   << "*ML*WRN* Now put 1 on the diagonal...\n";
+      // insert a 1 on the diagonal
+      colInd[NumNonzeros] = global_nodes_as_int[i];
+      colVal[NumNonzeros] = 1.0;
+      NumNonzeros++;
+    }
+    MaxNumNonzeros = EPETRA_MAX(NumNonzeros,MaxNumNonzeros);
+    
+    CrsMatrix->InsertGlobalValues( global_rows_as_int[i], NumNonzeros, 
+				   colVal, colInd);
+    
+    //    CrsMatrix->InsertGlobalValues( global_rows_as_int[i], ncnt, 
+    //				   colVal, colInd);
+  }
+
+  delete [] colInd;
+  delete [] colVal;
+  }
+  
+  delete [] global_nodes_as_int;
+  delete [] global_rows_as_int;
+  delete [] global_rows;
+  delete [] global_nodes;
+
+  CrsMatrix->FillComplete();
+
+  CPUTime = Time.ElapsedTime();
+
+  return 0;
+  
+} /* ML_Operator2EpetraCrsMatrix */
+#endif
+
+#ifdef WKC
+int ML_Epetra_matvec_WKC (ML_Operator *data, int in, double *p, int out, double *ap)
+{
+  ML_Operator *mat_in;
+
+  mat_in = data;
+  Epetra_RowMatrix *A = (Epetra_RowMatrix *) ML_Get_MyMatvecData(mat_in);
+  Epetra_MultiVector &X(*(Epetra_MultiVector *)p);
+  Epetra_MultiVector &Y(*(Epetra_MultiVector *)ap);
+
+  A->Multiply(false, X, Y);
+
+  return 1;
+}
+#endif
+
+// ============================================================================
+#include "Epetra_FECrsMatrix.h"
+// FIXME: change my name?
+Epetra_FECrsMatrix* FakeMatrix = 0;
+
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+extern "C" 
+{
+#endif
+#endif
+
+int ML_Operator_DiscreteLaplacian(ML_Operator* Op, int SymmetricPattern,
+				  double* x_coord, double* y_coord,
+				  double* z_coord, double theta,
+				  ML_Operator** NewOp)
+{
+
+  if (Op->invec_leng != Op->outvec_leng) 
+    return(-1); // works only with square matrices
+
+  int NumMyRows = Op->outvec_leng;
+  int NumPDEEqns = 1; // FIXME or DELETEME
+  int NumDimensions = 1;
+
+  if (x_coord == 0)
+    return(-2); // at least one dimension is required
+
+  if (y_coord == 0 && z_coord != 0)
+    return(-3); // cannot be this
+
+  if (y_coord != 0)
+    NumDimensions++;
+
+  if (z_coord != 0)
+    NumDimensions++;
+
+  // need an Epetra_Comm object. This in general exists, but I
+  // don't know an easy way to pass it up to here
+#ifdef ML_MPI
+  Epetra_MpiComm Comm(Op->comm->USR_comm);
+#else
+  Epetra_SerialComm Comm;
+#endif
+
+  // need to create a map. This may may already exist for the finest-level
+  // matrix, but in general it does not
+
+  Epetra_Map Map(-1,NumMyRows,0,Comm);
+  int NumGlobalRows = Map.NumGlobalElements();
+  
+  // create the auxiliary matrix as VBR matrix. This should help
+  // to save memory with respect to the creation of "pure" VBR
+  // matrices.
+
+  int MaxNnzRow = Op->max_nz_per_row;
+  assert(MaxNnzRow > 0);
+  // FIXME: I can compute it in this case
+
+  FakeMatrix = new Epetra_FECrsMatrix(Copy,Map, MaxNnzRow);
+  
+  if (FakeMatrix == 0)
+    return(-10); // problems occur
+
+  if (ML_Get_PrintLevel() > 8) {
+    std::cout << std::endl;
+    std::cout << "Creating discrete Laplacian..." << std::endl;
+    std::cout << "Number of dimensions = " << NumDimensions << std::endl;
+    std::cout << "theta = " << theta;
+    if (SymmetricPattern == 1)
+      std::cout << ", using symmetric pattern" << std::endl;
+    else
+      std::cout << ", using original pattern" << std::endl;
+    std::cout << std::endl;
+  }
+
+  // create the auxiliary matrix
+
+  int allocated = 1;
+  int * colInd = new int[allocated];
+  double * colVal = new double[allocated];
+  int NnzRow;
+
+  double coord_i[3], coord_j[3];
+  for( int i = 0; i<3 ; ++i ) {
+    coord_i[i] = 0.0; coord_j[i] = 0.0;
+  }
+
+  // get global column number
+ 
+  int Nghost;
+
+  if (Op->getrow->pre_comm == NULL) 
+    Nghost = 0;
+  else {
+    if (Op->getrow->pre_comm->total_rcv_length <= 0)
+      ML_CommInfoOP_Compute_TotalRcvLength(Op->getrow->pre_comm);
+    Nghost = Op->getrow->pre_comm->total_rcv_length;
+  }
+
+  std::vector<double> global;        
+  std::vector<int>    global_as_int; 
+  global.resize(NumMyRows+Nghost+1);
+  global_as_int.resize(NumMyRows+Nghost+1);
+
+  int offset;
+  Comm.ScanSum(&NumMyRows,&offset,1); 
+  offset -= NumMyRows;
+
+  for (int i = 0 ; i < NumMyRows; i++) {
+    global[i] = (double) (offset + i);
+    global_as_int[i] = offset + i;
+  }
+
+  for (int i = 0 ; i < Nghost; i++) 
+    global[i+NumMyRows] = -1;
+
+  ML_exchange_bdry(&global[0],Op->getrow->pre_comm,
+                  Op->invec_leng,Op->comm,ML_OVERWRITE,NULL);
+
+  for ( int j = 0; j < NumMyRows+Nghost; j++ ) {
+    global_as_int[j] = (int) global[j];
+  }
+  
+  // =================== //
+  // cycle over all rows //
+  // =================== //
+
+  for (int i = 0; i < NumMyRows ; i += NumPDEEqns ) {
+
+    int GlobalRow = global_as_int[i];
+
+    assert( GlobalRow != -1 );
+
+    if( i%NumPDEEqns == 0 ) { // do it just once for each block row
+      switch( NumDimensions ) {
+      case 3:
+	coord_i[2] = z_coord[i/NumPDEEqns];
+      case 2:
+	coord_i[1] = y_coord[i/NumPDEEqns];
+      case 1:
+	coord_i[0] = x_coord[i/NumPDEEqns];
+      }
+    }
+
+    int ierr = ML_Operator_Getrow(Op,1,&i,allocated,colInd,colVal,&NnzRow);
+
+    if( ierr == 0 ) {
+      do {
+	delete [] colInd;
+	delete [] colVal;
+	allocated *= 2;
+	colInd = new int[allocated];
+	colVal = new double[allocated];
+	ierr = ML_Operator_Getrow(Op,1,&i,allocated,colInd,colVal,&NnzRow);
+      } while( ierr == 0 );
+    }
+
+    // NOTE: for VBR matrices, the "real" value that will be used in
+    // the subsequent part of the code is only the one for the first
+    // equations. For each block, I replace values with the sum of
+    // the abs of each block entry.
+
+    for (int j = 0 ; j < NnzRow ; j += NumPDEEqns) {
+      colVal[j] = fabs(colVal[j]);
+      for (int k = 1 ; k < NumPDEEqns ; ++k) {
+	colVal[j] += fabs(colVal[j+k]);
+      }
+    }
+
+    // work only on the first equations. Theta will blend the
+    // coordinate part with the sub of abs of row elements.
+
+    int GlobalCol;
+    double total = 0.0;
+
+    for (int j = 0 ; j < NnzRow ; j += NumPDEEqns) {
+
+     if (colInd[j]%NumPDEEqns == 0) { 
+
+      // insert diagonal later
+      if (colInd[j] != i) {
+	if (colInd[j]%NumPDEEqns == 0) { // do it only once
+	  switch(NumDimensions) {
+	  case 3:
+	    coord_j[2] = z_coord[colInd[j]/NumPDEEqns];
+	  case 2:
+	    coord_j[1] = y_coord[colInd[j]/NumPDEEqns];
+	  case 1:
+	    coord_j[0] = x_coord[colInd[j]/NumPDEEqns];
+	  }
+	}
+
+	double tmp1=coord_i[0]-coord_j[0];
+	double tmp2=coord_i[1]-coord_j[1];
+	double tmp3=coord_i[2]-coord_j[2];
+	double d2 = tmp1*tmp1 + tmp2*tmp2 + tmp3*tmp3;
+	if( d2 == 0.0 ) {
+	  cerr << std::endl;
+	  cerr << "distance between node " << i/NumPDEEqns << " and node " 
+	    << colInd[j]/NumPDEEqns << std::endl
+	    << "is zero. Coordinates of these nodes are" << std::endl
+	    << "x_i = " << coord_i[0] << ", x_j = " << coord_j[0] << std::endl  
+	    << "y_i = " << coord_i[1] << ", y_j = " << coord_j[1] << std::endl  
+	    << "z_i = " << coord_i[2] << ", z_j = " << coord_j[2] << std::endl  
+	    << "Now proceeding with distance = 1.0" << std::endl;
+	  cerr << std::endl;
+	  d2 = 1.0;
+	}
+
+	double val = -(1.0-theta)*(1.0/d2) + theta*(colVal[j]);
+
+	GlobalCol = global_as_int[colInd[j]];
+	assert( GlobalCol != -1 );
+	
+	// insert this value on all rows
+	for( int k=0 ; k<NumPDEEqns ; ++k ) {
+	  int row = GlobalRow+k;
+	  int col = GlobalCol+k;
+	  if( row >= NumGlobalRows || col >= NumGlobalRows ) {
+	    cerr << "trying to insert element (" << row 
+	         << "," << col << "), " << std::endl
+		 << "while NumGlobalRows = " << NumGlobalRows << std::endl
+		 << "(GlobalRow = " << GlobalRow << ", GlobalCol = " << GlobalCol << ")" << std::endl
+		 << "(file " << __FILE__ << ", line " << __LINE__ << ")" << std::endl;
+	  }
+	    
+	  // FakeMatrix->InsertGlobalValues(row,1,&val,&col);
+	  if( FakeMatrix->SumIntoGlobalValues(1,&row,1,&col,&val) != 0 ) {
+	    int ierr = FakeMatrix->InsertGlobalValues(1,&row,1,&col,&val);
+	    if( ierr ) {
+	      cerr << "InsertGlobalValues return value = " << ierr << std::endl
+		<< "for element (" << row << "," << col << ")" << std::endl
+		<< "(file " << __FILE__ << ", line " << __LINE__
+		<< ")" << std::endl;
+	    }
+	  }
+	}
+
+	total -= val;
+
+	// put (j,i) element as well. this works also for
+	// off-process elements. 
+	if( SymmetricPattern == 1 ) {
+	  for( int k=0 ; k<NumPDEEqns ; ++k ) {
+	    int row = GlobalCol+k;
+	    int col = GlobalRow+k;
+	    if( row >= NumGlobalRows || col >= NumGlobalRows ) {
+	      cerr << "trying to insert element (" << row 
+		<< "," << col << "), " << std::endl
+		<< "while NumGlobalRows = " << NumGlobalRows << std::endl
+		<< "(GlobalRow = " << GlobalRow << ", GlobalCol = " << GlobalCol << ")" << std::endl
+		<< "(file " << __FILE__ << ", line " << __LINE__ << ")" << std::endl;
+	    }
+	    if( FakeMatrix->SumIntoGlobalValues(1,&row,1,&col,&val) != 0 ) { 
+	      int ierr = FakeMatrix->InsertGlobalValues(1,&row,1,&col,&val);
+	      if( ierr ) {
+		cerr << "InsertGlobalValues return value = " << ierr << std::endl
+		  << "for element (" << row << "," << col << ")" << std::endl
+		  << "(file " << __FILE__ << ", line " << __LINE__
+		  << ")" << std::endl;
+	      }
+	    }
+	  }
+	  total -= val;
+	}
+      } 
+    }
+
+    }
+
+    // create lines with zero-row sum
+    for( int k=0 ; k<NumPDEEqns ; ++k ) {
+      int row = GlobalRow+k;
+      assert( row < NumGlobalRows );
+      if( FakeMatrix->SumIntoGlobalValues(1,&row,1,&row,&total) != 0) {
+	int ierr = FakeMatrix->InsertGlobalValues(1,&row,1,&row,&total);
+	if( ierr ) {
+	  cerr << "InsertGlobalValues return value = " << ierr << std::endl
+	    << "for element (" << row << "," << row << ")" << std::endl
+	    << "(file " << __FILE__ << ", line " << __LINE__
+	    << ")" << std::endl;
+	}
+      }
+   }
+  }
+
+  FakeMatrix->GlobalAssemble();
+
+  delete [] colInd;
+  delete [] colVal;
+
+  // create a new ML_Operator from this Epetra Matrix.
+
+  *NewOp = ML_Operator_Create(Op->comm);
+  ML_Operator_WrapEpetraMatrix(FakeMatrix,*NewOp);
+  
+  return(0);
+}
+
+int ML_Operator_Destroy_DiscreteLaplacian() 
+{
+
+  if (FakeMatrix != 0) {
+    delete FakeMatrix;
+    FakeMatrix = 0;
+  }
+
+  return 0;
+
+}
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+} // extern "C"
+#endif
+#endif
+
+
+string ML_toString(const int& x) {
+  char s[100];
+  sprintf(s, "%d", x);
+  return string(s);
+}
+
+string ML_toString(const double& x) {
+  char s[100];
+  sprintf(s, "%g", x);
+  return string(s);
+}
+
+
+/*----------------------------------------------------------------------*
+ |                                                           m.gee 03/05|
+ |                                                                      |
+ | reads an update vector from file and creates an Epetra_Map from it.  |
+ |                                                                      |
+ | the file has the following format:                                   |
+ | first line: <number_global_elements>  <number_of_procs>              |
+ | following lines: <rownumber> <proc_number> -1                        |
+ |                                                                      |
+ | the file has to have <number_global_elements> + 1 rows               |
+ |                                                                      |
+ | Input:  char* filename        name of file to read from              |
+ |         Epetra_Comm& comm     a valid Epetra_Comm                    |
+ |                                                                      |
+ | Output: Epetra_Map*           an allocated Epetra_Map class          |
+ |                               (the calling user is responsible       |
+ |                                for destroying this)                  |
+ |                                                                      |
+ | returns Epetra_Map* on success, NULL otherwise                       |
+ |                                                                      |
+ |                                                                      |
+ *----------------------------------------------------------------------*/
+Epetra_Map* Epetra_ML_readupdatevector(char* filename, Epetra_Comm& comm)
+{
+  char  buffer[200];
+  char* bptr      = 0;
+  int numeq_total = 0;
+  int numeq       = 0;
+  Epetra_Map* map = 0;
+  int proc        = comm.MyPID();
+  int nproc       = comm.NumProc();
+  
+  FILE *fp = fopen(filename,"r");
+  if (!fp) return 0;
+  if (proc) 
+  {
+    fclose(fp);
+    fp = 0;
+  }
+
+  int ok = 1;
+  if (proc==0)
+  {
+     fgets(buffer,199,fp);
+     numeq_total = strtol(buffer,&bptr,10); // read number of global rows
+     int j = strtol(bptr,&bptr,10);
+     if (j != nproc) ok = 0;
+     else            ok = numeq_total;
+     fgets(buffer,199,fp);
+  }
+  comm.Broadcast(&ok,1,0);
+  if (!ok) return 0;
+  else numeq_total = ok;
+  
+  int* gupdate = new int[numeq_total];
+  if (proc==0)
+  {
+     for (int i=0; i<numeq_total; i++)
+     {
+        int row = strtol(buffer,&bptr,10);
+        int thisproc = strtol(bptr,&bptr,10);
+        gupdate[row] = thisproc;
+        fgets(buffer,199,fp);
+     }
+     fclose(fp); fp = 0;
+  }
+   
+  comm.Broadcast(gupdate,numeq_total,0);
+  for (int i=0; i< numeq_total; i++)
+     if (gupdate[i]==proc) numeq++;
+     
+  int* update = new int[numeq];
+  
+  int counter=0;
+  for (int i=0; i<numeq_total; i++)
+  {
+     if (gupdate[i]==proc)
+     {
+        update[counter] = i;
+        ++counter;
+     }
+  }   
+  delete [] gupdate; gupdate = 0;
+  
+  map = new Epetra_Map(numeq_total,numeq,update,0,comm);
+  
+  return map;
+}
+
+/*----------------------------------------------------------------------*
+ |                                                           m.gee 03/05|
+ |                                                                      |
+ | reads a matrix in aztec format                                       |
+ |                                                                      |
+ | the file has the following format:                                   |
+ | first line: <number_global_rows>                                     |
+ | following lines:                                                     |
+ | <globalrownumb> <val_main_diag> <globalcolnumb> <value> ... -1       |
+ |                                                                      |
+ | the file has to have <number_global_rows> + 1 rows                   |
+ |                                                                      |
+ | Input:  char* filename        name of file to read from              |
+ |         Epetra_Map& dmap       a valid Epetra_Map used as RowMap     |
+ |         Epetra_Comm& comm     a valid Epetra_Comm                    |
+ |                                                                      |
+ | Output: Epetra_CrsMatrix*      an allocated Epetra_CrsMatrix class   |
+ |                               (the calling user is responsible       |
+ |                                for destroying this)                  |
+ |                                                                      |
+ | returns Epetra_CrsMatrix* on success, NULL otherwise                 |
+ |                                                                      |
+ *----------------------------------------------------------------------*/
+Epetra_CrsMatrix* Epetra_ML_readaztecmatrix(char* filename,Epetra_Map& map,Epetra_Comm& comm)
+{
+   char  buffer[10000];
+   char* bptr      = 0;
+
+   int  numeq_total = map.NumGlobalElements();
+   int  nproc       = comm.NumProc();
+   int  proc        = comm.MyPID();
+   
+   Epetra_CrsMatrix* A = new Epetra_CrsMatrix(Copy,map,map,0);
+   
+   for (int activeproc=0; activeproc<nproc; activeproc++)
+   {
+      int ok=0;
+      FILE* fp = 0;
+      if (activeproc==proc)
+      {
+         std::cout << "Proc " << proc << " is reading the Epetra_CrsMatrix .."; fflush(stdout);
+         fp = fopen(filename,"r");
+         if (fp) 
+         {
+            ok=1;
+            fgets(buffer,9999,fp);
+            int readnumeq = strtol(buffer,&bptr,10);
+            if (readnumeq != numeq_total)
+               ok = 0;
+         }
+         else ok = 0;
+      }
+      comm.Broadcast(&ok,1,activeproc);
+      if (!ok)
+      {
+         delete A;
+         return 0;
+      }
+      if (activeproc==proc)
+      {
+         for (int i=0; i<numeq_total; i++)
+         {
+            fgets(buffer,9999,fp);
+            int row = i;
+            if (!map.MyGID(row)) // it's not one of my rows 
+               continue;
+            else                 // this row belongs to me, read it
+            {
+               std::cout << "."; fflush(stdout);
+               // read row and insert them
+               bptr = buffer;
+               int column = 0;
+               while (column != -1)
+               {
+                  column = strtol(bptr,&bptr,10);
+                  if (column == -1) break;
+                  double value = strtod(bptr,&bptr);
+                  A->InsertGlobalValues(row,1,&value,&column);
+               }
+            }
+         }
+         std::cout << std::endl;   
+         fclose(fp); fp = 0;
+      }
+      comm.Barrier();
+   }
+   A->FillComplete();
+   
+   return A;
+}
+
+
+
+/*----------------------------------------------------------------------*
+ |                                                           m.gee 03/05|
+ |                                                                      |
+ | reads a vector in aztec format                                       |
+ |                                                                      |
+ | the file has the following format:                                   |
+ | first line: <number_global_rows>                                     |
+ | following lines:                                                     |
+ | <globalrownumb> <val_> -1                                            |
+ |                                                                      |
+ | the file has to have <number_global_rows> + 1 rows                   |
+ |                                                                      |
+ | Input:  char* filename             name of file to read from         |
+ | Output: Epetra_MultiVector& Vector valid Epetra_MultiVector          |
+ |                                     matching the map                 |
+ | Input:  Epetra_Map& map            a valid Epetra_Map                |
+ |         Epetra_Comm& comm          a valid Epetra_Comm               |
+ |         int ivec                   indice of vector to put values in |
+ |                                                                      |
+ | returns true on success, false otherwise                             |
+ |                                                                      |
+ *----------------------------------------------------------------------*/
+bool Epetra_ML_readaztecvector(char* filename, Epetra_MultiVector& Vector, 
+                               Epetra_Map& map,Epetra_Comm& comm, int ivec)
+{
+  char  buffer[200];
+  char* bptr      = 0;
+
+  int  numeq_total = map.NumGlobalElements();
+  int  nproc       = comm.NumProc();
+  int  proc        = comm.MyPID();
+   
+  FILE *fp = fopen(filename,"r");
+  if (!fp) return false;
+  if (proc) 
+  {
+    fclose(fp);
+    fp = 0;
+  }
+
+  int ok = 0;
+  if (proc==0)
+  {
+     fgets(buffer,199,fp);
+     int tmp = strtol(buffer,&bptr,10); // read number of global rows
+     if (tmp != numeq_total) ok = 0;
+     else                    ok = 1;
+     fclose(fp); fp = 0;
+  }
+  comm.Broadcast(&ok,1,0);
+  if (!ok) return false;
+
+  for (int activeproc=0; activeproc<nproc; activeproc++)
+  {
+     int ok = 0;
+     FILE* fp = 0;
+     if (activeproc==proc)
+     {
+        fp = fopen(filename,"r");
+        if (fp)
+        {
+           ok = 1;
+           fgets(buffer,199,fp);
+        }
+        else ok = 0;
+     }
+     comm.Broadcast(&ok,1,activeproc);
+     if (!ok)
+        return false;
+     if (activeproc==proc)
+     {
+        for (int i=0; i<numeq_total; i++)
+        {
+           fgets(buffer,199,fp);
+           int row = strtol(buffer,&bptr,10);
+           if (!map.MyGID(row))
+              continue;
+           else
+           {
+              double value = strtod(bptr,&bptr);
+              Vector.ReplaceGlobalValue(row,ivec,value);
+           }
+        }
+        fclose(fp); fp = 0;
+     }
+     comm.Barrier();
+  }
+  
+
+  return true;
+}                               
+
+
+/*----------------------------------------------------------------------*
+ |                                                           m.gee 03/05|
+ |                                                                      |
+ | reads variable block information                                     |
+ |                                                                      |
+ | the file has the following format:                                   |
+ | first line: <number_global_blocks>                                   |
+ | following lines:                                                     |
+ | <blocksize> <globalrownumber1> <pde_number1>  ...                    |
+ |                                                                      |
+ | the file has to have <number_global_blocks> + 1 rows                 |
+ |                                                                      |
+ | Input:  char* filename             name of file to read from         |
+ |         Epetra_Map& map            a valid Epetra_Map                |
+ |         Epetra_Comm& comm          a valid Epetra_Comm               |
+ | Output  int** blocks               *blocks points to allocated       |
+ |                                    vector matching map holding       |
+ |                                    global block indices              |
+ |         int** block_pde            *block_pde points to allocated    |
+ |                                    vector matching map holding       |
+ |                                    number of pde equation each entry |
+ |                                    in *blocks belongs to             |
+ |                                                                      |
+ |                                                                      |
+ | WARNING: The routine expects the map not to cut a single block onto  |
+ |          several processors! It will return false if otherwise       |
+ |                                                                      |
+ | Returns true and allocated *blocks / *block_pde on success,          |
+ | returns false and *blocks=NULL / *block_pde=NULL otherwise           |
+ |                                                                      |
+ *----------------------------------------------------------------------*/
+bool Epetra_ML_readvariableblocks(char* filename, Epetra_Map& map,
+                                  Epetra_Comm& comm, 
+                                  int**blocks, int** block_pde)
+{
+  char  buffer[1000];
+  char* bptr      = 0;
+
+  int  numeq       = map.NumMyElements();
+  int  nproc       = comm.NumProc();
+  int  proc        = comm.MyPID();
+
+  FILE *fp = fopen(filename,"r");
+  if (!fp) return false;
+  if (proc) 
+  {
+    fclose(fp);
+    fp = 0;
+  }
+
+  int nblocks = 0;
+  if (proc==0)
+  {
+     fgets(buffer,199,fp);
+     nblocks = strtol(buffer,&bptr,10); // read number of global blocks
+     fclose(fp); fp = 0;
+  }
+  comm.Broadcast(&nblocks,1,0);
+  if (!nblocks) return false;
+
+  *blocks    = new int[numeq];
+  *block_pde = new int[numeq];
+  
+  int block_counter=0;
+  int numeq_counter=0;
+  for (int activeproc=0; activeproc<nproc; activeproc++)
+  {
+     int   ok = 0;
+     FILE *fp = 0;
+     if (activeproc==proc)
+     {
+        fp = fopen(filename,"r");
+        if (fp)
+        {
+           ok = 1;
+           fgets(buffer,999,fp);
+        }
+        else ok = 0;
+     }
+     comm.Broadcast(&ok,1,activeproc);
+     if (!ok)
+     {
+        delete [] *blocks;    *blocks = 0;
+        delete [] *block_pde; *block_pde = 0;
+        return false;
+     }
+     ok = 1;
+     if (activeproc==proc)
+     {
+        for (int i=0; i<nblocks; i++)
+        {
+           fgets(buffer,199,fp);
+           int blocksize = strtol(buffer,&bptr,10);
+           if (!blocksize)
+           {
+              ok = 0;
+              break;
+           }
+           int myblock = 0;
+           for (int j=0; j<blocksize; j++)
+           {
+              int row = strtol(bptr,&bptr,10);
+              int pde = strtol(bptr,&bptr,10);
+              if (map.MyGID(row)==true)
+              {
+                 ++myblock;
+                 (*blocks)[numeq_counter]    = block_counter;
+                 (*block_pde)[numeq_counter] = pde;
+                 ++numeq_counter;
+              }
+              else if (j==0 && map.MyGID(row)==false)
+                 break;
+              else if (j>0 && map.MyGID(row)==false)
+              {
+                 std::cout << "**ERR** block split among several procs, abort reading\n";
+                 ok = 0;
+                 break;
+              }
+           }
+           if (myblock) ++block_counter;
+        if (!ok) break;
+        }
+        std::cout << "numeq " << numeq << std::endl;
+        std::cout << "numeq_counter " << numeq_counter << std::endl;
+     }
+     comm.Broadcast(&ok,1,activeproc);
+     if (!ok)
+     {
+        delete [] *blocks;    *blocks = 0;
+        delete [] *block_pde; *block_pde = 0;
+        return false;
+     }
+     comm.Broadcast(&block_counter,1,activeproc);
+  }
+  
+  if (nblocks != block_counter)
+  {
+     std::cout << "**ERR**  Something went wrong, final number of blocks: " << block_counter << std::endl
+          << "**ERR** not equal number of blocks from head of file : " << nblocks << std::endl;
+     throw -1;
+  }
+
+  return true;
+}                                  
+
+/*----------------------------------------------------------------------*
+ |                                                           m.gee 03/05|
+ |                                                                      |
+ | writes column of Epetra_Multivecotr to GID viz                       |
+ |                                                                      |
+ *----------------------------------------------------------------------*/
+bool Epetra_ML_writegidviz(char* filename, int label, 
+                           Epetra_MultiVector& vector, int ivec, 
+                           Epetra_Map& map, Epetra_Comm& comm)
+{
+  char* bptr;
+  char buffer[1000];
+  char filename2[1000];
+  
+  int  numeq_total = map.NumGlobalElements();
+  int  numeq       = map.NumMyElements();
+  int  proc        = comm.MyPID();
+
+  //----------------- reduce content of ivec Vector in vector to proc 0    
+  double* values  = vector[ivec];
+  double* send    = new double[numeq_total];
+  double* gvalues = new double[numeq_total];
+  for (int i=0; i<numeq_total; i++) send[i] = 0.0;
+  for (int i=0; i<numeq; i++) 
+  {
+     int gID = map.GID(i);
+     if (gID==-1) {
+        std::cout << "**ERR Cannot find GID\n"; throw -1; }
+     send[gID] = values[i];
+  }
+  comm.SumAll(send,gvalues,numeq_total);
+  delete [] send;
+  if (proc) delete [] gvalues;
+  
+  // ---------------------------------------------------open all files
+  // copy filename not to modify it 
+  strcpy(filename2,filename);
+  int   ok    = 0;
+  FILE* fin   = 0;
+  FILE* foutr = 0;
+  FILE* foutm = 0;
+  if (proc==0)
+  {
+     fin = fopen(filename2,"r");
+     if (fin) ok = 1;
+  }
+  comm.Broadcast(&ok,1,0);
+  if (!ok)
+  {
+     delete [] gvalues;
+     return false;
+  } 
+  bool newresfile=true;
+  if (proc==0)
+  {
+     // try to open the mesh file for read to see whether it exists
+     foutm = fopen("data.flavia.msh","r");
+     if (foutm) // mesh exists, don't have to recreate
+     {
+        fclose(foutm); foutm = 0;
+     }
+     else // mesh file does not exist, create      
+        foutm = fopen("data.flavia.msh","w");
+     
+     // try to open the mesh file for read to see whether it exists
+     foutr = fopen("data.flavia.res","r");
+     if (foutr) // result file exists, attach to it
+     {
+        fclose(foutr);
+        foutr = fopen("data.flavia.res","a+w");
+        newresfile=false;
+     }
+     else // result file does nopt exist yet, create it
+     {
+        foutr = fopen("data.flavia.res","w");
+        newresfile=true;
+     }
+  }
+  
+  
+  //----------------------------------- read the grid file
+  int nnode      = 0;
+  int dofpernode = 0; 
+  int readnumeq  = 0;
+  bool isshell=false;
+  if (proc==0)
+  {
+     // read the grid file
+     fgets(buffer,999,fin);
+     while (strpbrk(buffer,"#"))
+        fgets(buffer,999,fin);
+     nnode      = strtol(buffer,&bptr,10);
+     dofpernode = strtol(bptr,&bptr,10);
+     readnumeq  = strtol(bptr,&bptr,10);
+     if (strncmp(" SHELL",bptr,6)==0) 
+        isshell=true;
+     else                            
+        isshell=false;
+     if (readnumeq==numeq_total) ok=1;
+     else                        ok=0;  
+  }
+  comm.Broadcast(&ok,1,0);
+  if (!ok)
+  {
+     delete [] gvalues;
+     return false;
+  }
+  
+  //-------------------------- read nodal coordinates and dofs
+  double* x   = 0;
+  double* y   = 0;
+  double* z   = 0;
+  int**   dof = 0;
+  if (proc==0)
+  {
+     // allocate vectors for nodal coordinates
+     x = new double[nnode];
+     y = new double[nnode];
+     z = new double[nnode];
+     // create array for dofs on each node
+     dof    = new int* [nnode];
+     dof[0] = new int[nnode*dofpernode];
+     for (int i=1; i<nnode; i++)
+        dof[i] = &(dof[0][i*dofpernode]);
+     // read the nodes
+     for (int i=0; i<nnode; i++)
+     {
+        fgets(buffer,999,fin);
+        int node    = strtol(buffer,&bptr,10);
+        x[node-1]   = strtod(bptr,&bptr);
+        y[node-1]   = strtod(bptr,&bptr);
+        z[node-1]   = strtod(bptr,&bptr);
+        for (int j=0; j<dofpernode; j++)
+           dof[node-1][j] = strtol(bptr,&bptr,10); 
+     }
+     // check whether we arrived at the line, were the elements begin
+     fgets(buffer,999,fin);
+     if (!(strpbrk(buffer,"#")))
+     {
+        ok = 0;
+        delete [] x; delete [] y; delete [] z;
+        delete [] dof[0]; delete [] dof;
+     }
+     else ok = 1;
+  }     
+  comm.Broadcast(&ok,1,0);
+  if (!ok)
+  {
+     delete [] gvalues;
+     return false;
+  }
+
+  //---------------------------- read the element topology
+  int   nelement    = 0;
+  int   nodesperele = 0;
+  int** top         = 0;
+  if (proc==0)
+  {
+     // read the elements
+     fgets(buffer,999,fin);
+     nelement    = strtol(buffer,&bptr,10);
+     nodesperele = strtol(bptr,&bptr,10);
+     // allocate array for topology
+     top    = new int* [nelement];
+     top[0] = new int[nelement*nodesperele];
+     for (int i=1; i<nelement; i++)
+        top[i] = &(top[0][i*nodesperele]);
+     // read the elements
+     for (int i=0; i<nelement; i++)
+     {
+        fgets(buffer,999,fin);
+        int element    = strtol(buffer,&bptr,10);
+        for (int j=0; j<nodesperele; j++)
+          top[element-1][j] = strtol(bptr,&bptr,10);
+     }
+     // check for end of elements marker
+     fgets(buffer,999,fin);
+     if (!(strpbrk(buffer,"#")))
+     {
+        ok = 0;
+        delete [] x; delete [] y; delete [] z;
+        delete [] dof[0]; delete [] dof;
+        delete [] top[0]; delete [] top;        
+     }
+     else ok = 1;
+     fclose(fin);   fin   = 0;
+  }  
+  comm.Broadcast(&ok,1,0);
+  if (!ok)
+  {
+     delete [] gvalues;
+     return false;
+  }
+
+  //------------------------- printf the .flavia.msh file
+  if (proc==0 && foutm)
+  {
+     // print nodal coordinates
+     fprintf(foutm,"%s","#-------------------------------------------------------------------------------\n");
+     fprintf(foutm,"%s","# visualization using GID\n");
+     fprintf(foutm,"%s","#-------------------------------------------------------------------------------\n");
+     fprintf(foutm,"%s","MESH datamesh DIMENSION 3 ELEMTYPE Hexahedra NNODE 8\n");
+     fprintf(foutm,"%s","COORDINATES\n");
+     for (int i=0; i<nnode; i++)
+     fprintf(foutm,"%6d   %20.10f   %20.10f   %20.10f\n",i+1,x[i],y[i],z[i]);
+     fprintf(foutm,"%s","END COORDINATES\n");
+     
+     // print elements
+     fprintf(foutm,"%s","ELEMENTS\n");
+     for (int i=0; i<nelement; i++)
+     {
+        fprintf(foutm,"%6d   ",i+1);
+        for (int j=0; j<nodesperele; j++)
+           fprintf(foutm,"%6d   ",top[i][j]);
+        fprintf(foutm,"%s","\n");
+     }
+     fprintf(foutm,"%s","END ELEMENTS\n");
+     fflush(foutm);
+     fclose(foutm); foutm = 0;
+  }
+
+  //------------- printf the .flavia.res file with the vector
+  if (proc==0)
+  {
+     char sign='"';
+     if (newresfile)
+     {
+     fprintf(foutr,"%s","Gid Post Results File 1.0\n");
+     fprintf(foutr,"%s","#-------------------------------------------------------------------------------\n");
+     fprintf(foutr,"%s","# visualization using GID\n");
+     fprintf(foutr,"%s","#-------------------------------------------------------------------------------\n");
+     fprintf(foutr,"RESULTRANGESTABLE %cstandard%c\n",sign,sign);
+     fprintf(foutr,"            - -1000000.0 : %cvery small%c\n",sign,sign);
+     fprintf(foutr," -1000000.0 -  1000000.0 : %cnormal%c\n",sign,sign);
+     fprintf(foutr,"  1000000.0 -            : %cvery large%c\n",sign,sign);
+     fprintf(foutr,"%s","END RESULTRANGESTABLE\n");
+     fprintf(foutr,"%s","#-------------------------------------------------------------------------------\n");
+     fprintf(foutr,"GAUSSPOINTS %cdatamesh%c ELEMTYPE Hexahedra %cdatamesh%c\n",sign,sign,sign,sign);
+     fprintf(foutr,"%s","NUMBER OF GAUSS POINTS: 8\n");
+     fprintf(foutr,"%s","NATURAL COORDINATES: Internal\n");
+     fprintf(foutr,"%s","END GAUSSPOINTS\n");
+     fprintf(foutr,"%s","#-------------------------------------------------------------------------------\n");
+     }
+     fprintf(foutr,"%s","#===============================================================================\n");
+     fprintf(foutr,"%s","#===============================================================================\n");
+     fprintf(foutr,"RESULT %cdisplacement%c %cML%c %d VECTOR ONNODES\n",sign,sign,sign,sign,label);
+     fprintf(foutr,"RESULTRANGESTABLE %cstandard%c\n",sign,sign);
+     fprintf(foutr,"COMPONENTNAMES %cx-displ%c,%cy-displ%c,%cz-displ%c\n",sign,sign,sign,sign,sign,sign);
+     fprintf(foutr,"%s","VALUES\n"); fflush(foutr);
+     if (!isshell) // result does not come from a shell element
+     {
+        for (int i=0; i<nnode; i++)
+        {
+           fprintf(foutr," %6d   ",i+1);
+           for (int j=0; j<dofpernode; j++)
+           {
+              int thisdof = dof[i][j];
+              double val  = 0.0;
+              if (thisdof<numeq_total)
+                 val = gvalues[thisdof];
+              else
+                 val = 0.0;
+              fprintf(foutr,"%20.10e   ",val); 
+           }
+           fprintf(foutr,"%s","\n"); 
+        }
+     }
+     else // results come from a shell element
+     {
+        int realnnode = nnode/2;
+        for (int i=0; i<realnnode; i++)
+        {
+           int node_lower = i;
+           int node_upper = i+realnnode;
+           // print the lower surface node
+           fprintf(foutr," %6d   ",node_lower+1);
+           for (int j=0; j<dofpernode; j++)
+           {
+              int thisdof = dof[node_lower][j];
+              double val = 0.0;
+              if (thisdof<numeq_total)
+                 val = gvalues[thisdof];
+              else
+                 val = 0.0;
+              // this is mid surface displacement, subtract the relativ displacement
+              int reldof  = dof[node_upper][j];
+              double val2 = 0.0;
+              if (reldof<numeq_total)
+                 val2 = gvalues[reldof];
+              else
+                 val2 = 0.0;
+              val -= val2;
+              fprintf(foutr,"%20.10e   ",val); 
+           }
+           fprintf(foutr,"%s","\n"); fflush(foutr);
+           // print the upper surface node
+           fprintf(foutr," %6d   ",node_upper+1);
+           for (int j=0; j<dofpernode; j++)
+           {
+              int thisdof = dof[node_upper][j];
+              double val = 0.0;
+              if (thisdof<numeq_total)
+                 val = gvalues[thisdof];
+              else
+                 val = 0.0;
+              // this is a relativ displcement, add mid surface displacement to get upper total displ.
+              int middof  = dof[node_lower][j];
+              double val2 = 0.0;
+              if (middof<numeq_total)
+                 val2 = gvalues[middof];
+              else
+                 val2 = 0.0;
+              val += val2;
+              fprintf(foutr,"%20.10e   ",val); 
+           }
+           fprintf(foutr,"%s","\n"); fflush(foutr);
+        }
+     }
+     fprintf(foutr,"%s","END VALUES\n");
+  }
+  // clean up
+  if (proc==0)
+  {
+     delete [] x; delete [] y; delete [] z;
+     delete [] dof[0]; delete [] dof;
+     delete [] top[0]; delete [] top;        
+     delete [] gvalues; 
+     fflush(foutr); fclose(foutr);
+  }
+  return true;
+}                           
+
+// ============================================================================
+
+void ML_BreakForDebugger(const Epetra_Comm &Comm)
+{
+  // print out some junk for debugging (copied from code in
+  // Utils/ml_utils.c, suggested by Jonathan)
+  // LAM/MPI has some difficulties related to environmental variables.
+  // The problem is that LAM/MPI uses ssh to log in, and on some
+  // machine "export ML_BREAK_FOR_DEBUGGER" does not work. So, we
+  // allow two options:
+  // 1.) export ML_BREAK_FOR_DEBUGGER=1
+  // 2.) create a file in the executable directory, called ML_debug_now
+
+  char * str = (char *) getenv("ML_BREAK_FOR_DEBUGGER");
+  int i = 0, j = 0;
+  char buf[80];
+  char go = ' ';
+  char hostname[80];
+  if (str != NULL) i++;
+
+  FILE * ML_capture_flag;
+  ML_capture_flag = fopen("ML_debug_now","r");
+  if(ML_capture_flag) {
+    i++;
+    fclose(ML_capture_flag);
+  }
+
+  Comm.SumAll(&i, &j, 1);
+
+  if (j != 0)
+  {
+    if (Comm.MyPID()  == 0) std::cout << "Host and Process Ids for tasks" << std::endl;
+    for (i = 0; i <Comm.NumProc() ; i++) {
+      if (i == Comm.MyPID() ) {
+#if defined(TFLOP) || defined(JANUS_STLPORT) || defined(COUGAR)
+    sprintf(buf, "Host: %s   PID: %d", "janus", getpid());
+#else
+    gethostname(hostname, sizeof(hostname));
+    int pid = getpid();
+    sprintf(buf, "Host: %s\tComm.MyPID(): %d\tPID: %d\n\tattach %d\n\tcontinue\n",
+        hostname, Comm.MyPID(), pid, pid);
+#endif
+    printf("%s\n",buf);
+    fflush(stdout);
+#ifdef ICL
+    Sleep(1);
+#else
+    sleep(1);
+#endif
+      }
+    }
+     if(Comm.MyPID() == 0) {
+       printf("\n");
+       printf("** Pausing because environment variable ML_BREAK_FOR_DEBUGGER has been set,\n");
+       puts("** or file ML_debug_now has been created");
+       printf("**\n");
+       printf("** You may now attach debugger to the processes listed above.\n");
+       printf( "**\n");
+       printf( "** Enter a character to continue > "); fflush(stdout);
+       scanf("%c",&go);
+     }
+     Comm.Barrier();
+   }
+
+} //BreakForDebugger()
+
+
+// ============================================================================
+#ifdef HAVE_ML_TEUCHOS
+int ML_Epetra::UpdateList(Teuchos::ParameterList &source, Teuchos::ParameterList &dest, bool OverWrite){
+  for(Teuchos::ParameterList::ConstIterator param=source.begin(); param!=source.end(); param++)
+    if ( dest.isParameter(source.name(param)) == false || OverWrite )
+      dest.setEntry(source.name(param),source.entry(param));
+  return 0;
+}
+#endif
+
+// ============================================================================
+
+#ifdef HAVE_ML_TEUCHOS
+/*
+  Utility that from an existing Teuchos::ParameterList creates a new list, in
+  which level-specific parameters are replaced with sublists.
+
+  Currently, level-specific parameters that begin with "smoother:"
+  or "aggregation:" are placed in sublists. Coarse options are also placed
+  in a coarse list.
+
+  Example:
+   Input:
+    smoother: type (level 0) = symmetric Gauss-Seidel  
+    smoother: sweeps (level 0) = 1  
+   Output:
+    smoother: list (level 0) -> 
+     smoother: type = symmetric Gauss-Seidel  
+     smoother: sweeps = 1  
+*/
+void ML_CreateSublists(const ParameterList &List, ParameterList &newList)
+{
+  newList.setName(List.name());
+  
+  // Copy general (= not level-specific) options and sublists to the new list.
+  // - Coarse and level-specific parameters are not copied yet. They will be moved to sublists later.
+  // - Already existing level-specific lists are copied to the new list but the coarse list is not copied 
+  //   yet because it has to be modified before copy (s/coarse/smoother/)
+  for (ParameterList::ConstIterator param=List.begin(); param!=List.end(); ++param)
+    {
+      const string & pname=List.name(param);
+
+      if ((pname.find(" (level",0)  == string::npos || pname.find("smoother: list (level",0) == 0 || pname.find("aggregation: list (level",0) == 0) &&
+          (pname.find("coarse: ",0) == string::npos))
+        {
+          newList.setEntry(pname,List.entry(param));
+        }
+    } // for
+
+  // Copy of the sublist "coarse: list" to the new list. Change "coarse:" to "smoother:" along the way.
+  if (List.isSublist("coarse: list")) {
+    const ParameterList &coarseList = List.sublist("coarse: list");
+    ParameterList &newCoarseList = newList.sublist("coarse: list");
+    for (ParameterList::ConstIterator param=coarseList.begin(); param!=coarseList.end() ; ++param) {
+      const string & pname=coarseList.name(param);
+      
+      if (pname.find("coarse:",0) == 0) {
+        // change "coarse: " to "smoother:"
+        newCoarseList.setEntry("smoother: "+pname.substr(8),coarseList.entry(param));
+      } else {
+        newCoarseList.setEntry(pname,coarseList.entry(param));
+      }
+    }
+  } // if
+
+    // Copy of level-specific parameters and coarse parameters to sublist
+  for (ParameterList::ConstIterator param=List.begin(); param!=List.end(); ++param)
+    {
+      const string & pname=List.name(param);
+      if (pname.find(" (level",0) != string::npos && pname.find("smoother: list (level",0) != 0 && pname.find("aggregation: list (level",0) != 0)
+        {
+          // Copy level-specific parameters (smoother and aggregation)
+              
+          // Scan pname (ex: pname="smoother: type (level 2)")
+          string type, option;  
+          int levelID=-1;
+          {
+            typedef Teuchos::ArrayRCP<char>::size_type size_type;    // (!)
+            Teuchos::Array<char> ctype  (size_type(pname.size()+1));
+            Teuchos::Array<char> coption(size_type(pname.size()+1));
+              
+            int matched = sscanf(pname.c_str(),"%s %[^(](level %d)", ctype.getRawPtr(), coption.getRawPtr(), &levelID); // use [^(] instead of %s to allow for strings with white-spaces (ex: "ifpack list")
+            type = string(ctype.getRawPtr());
+            option = string(coption.getRawPtr()); option.resize(option.size () - 1); // remove final white-space
+              
+            if (matched != 3 || (type != "smoother:" && type != "aggregation:")) {
+              std::cout << "ML_CreateSublist(), Line " << __LINE__ << ". "
+                        << "Error in creating level-specific sublists" << std::endl
+                        << "Offending parameter: " << pname << std::endl;
+#          ifdef ML_MPI
+              MPI_Finalize();
+#          endif
+              exit(EXIT_FAILURE);
+            }
+          }
+            
+          // Create/grab the corresponding sublist of newList
+          ParameterList &newSubList = newList.sublist(type + " list (level " + Teuchos::toString(levelID) + ")");
+          // Shove option w/o level number into sublist
+          newSubList.setEntry(type + " " + option,List.entry(param));
+            
+        } else if (pname.find("coarse:",0) == 0 && pname != "coarse: list") {
+        // Copy coarse parameters
+        ParameterList &newCoarseList = newList.sublist("coarse: list"); // the coarse sublist is created only if there is at least one "coarse:" parameter
+        newCoarseList.setEntry("smoother: "+pname.substr(8),List.entry(param)); // change "coarse: " to "smoother:"
+      } // end if
+        
+    } // for
+    
+} //ML_CreateSublist()
+
+#endif
+
+/*
+  // -------------------------------------------------------------------
+  // Epetra_CrsMatrix matvec, modified to return timing information.  If
+  // you want timing of the user's Epetra_CrsMatrix matvec, replace the
+  // function of the same name in epetra/src/Epetra_CrsMatrix.cpp with
+  // the code below.
+  // -------------------------------------------------------------------
+
+#include "Epetra_Time.h"
+
+int Epetra_CrsMatrix::Multiply(bool TransA, const Epetra_Vector& x, Epetra_Vector& y,  double *compTime, double *allTime) const {
+
+#ifdef EPETRA_CRSMATRIX_TEUCHOS_TIMERS
+  TEUCHOS_FUNC_TIME_MONITOR("Epetra_CrsMatrix::Multiply(TransA,x,y)");
+#endif
+  //
+  // This function forms the product y = A * x or y = A' * x
+  //
+
+  double apply_only_time = 0.0, total_time = 0.0;
+
+  if(!Filled()) 
+    EPETRA_CHK_ERR(-1); // Matrix must be filled.
+
+  Epetra_Time TotalTime(Comm());
+
+  double* xp = (double*) x.Values();
+  double* yp = (double*) y.Values();
+
+  Epetra_Vector * xcopy = 0;
+  if (&x==&y && Importer()==0 && Exporter()==0) {
+    xcopy = new Epetra_Vector(x);
+    xp = (double *) xcopy->Values();
+  }
+  UpdateImportVector(1); // Refresh import and output vectors if needed
+  UpdateExportVector(1);
+
+  if(!TransA) {
+
+    // If we have a non-trivial importer, we must import elements that are permuted or are on other processors
+    if(Importer() != 0) {
+      EPETRA_CHK_ERR(ImportVector_->Import(x, *Importer(), Insert));
+      xp = (double*) ImportVector_->Values();
+    }
+		
+    // If we have a non-trivial exporter, we must export elements that are permuted or belong to other processors
+    if(Exporter() != 0)  yp = (double*) ExportVector_->Values();
+		
+    // Do actual computation
+    Epetra_Time ApplyTime(Comm());
+    GeneralMV(xp, yp);
+    apply_only_time += ApplyTime.ElapsedTime();
+
+    if(Exporter() != 0) {
+      y.PutScalar(0.0); // Make sure target is zero
+      EPETRA_CHK_ERR(y.Export(*ExportVector_, *Exporter(), Add)); // Fill y with Values from export vector
+    }
+    // Handle case of rangemap being a local replicated map
+    if (!Graph().RangeMap().DistributedGlobal() && Comm().NumProc()>1) EPETRA_CHK_ERR(y.Reduce());
+  }
+	
+  else { // Transpose operation
+
+    // If we have a non-trivial exporter, we must import elements that are permuted or are on other processors
+    if(Exporter() != 0) {
+      EPETRA_CHK_ERR(ExportVector_->Import(x, *Exporter(), Insert));
+      xp = (double*) ExportVector_->Values();
+    }
+
+    // If we have a non-trivial importer, we must export elements that are permuted or belong to other processors
+    if(Importer() != 0) yp = (double*) ImportVector_->Values();
+
+    // Do actual computation
+    Epetra_Time ApplyTime(Comm());
+    GeneralMTV(xp, yp);
+    apply_only_time += ApplyTime.ElapsedTime();
+
+    if(Importer() != 0) {
+      y.PutScalar(0.0); // Make sure target is zero
+      EPETRA_CHK_ERR(y.Export(*ImportVector_, *Importer(), Add)); // Fill y with Values from export vector
+    }
+    // Handle case of rangemap being a local replicated map
+    if (!Graph().DomainMap().DistributedGlobal() && Comm().NumProc()>1) EPETRA_CHK_ERR(y.Reduce());
+  }
+  total_time += TotalTime.ElapsedTime();
+
+  if (compTime) *compTime = apply_only_time;
+  if (allTime)  *allTime  = total_time;
+
+  UpdateFlops(2 * NumGlobalNonzeros());
+  if (xcopy!=0) {
+    delete xcopy;
+    EPETRA_CHK_ERR(1); // Return positive code to alert the user about needing extra copy of x
+    return(1);
+  }
+  return(0);
+}
+*/
+
+#else
+
+  /*noop for certain compilers*/
+  int ML_EPETRA_EMPTY;
+
+#endif /*ifdef ML_WITH_EPETRA*/
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_epetra_utils.cpp.rej trilinos-11.4.3/packages/ml/src/Utils/ml_epetra_utils.cpp.rej
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_epetra_utils.cpp.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_epetra_utils.cpp.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,38 @@
+--- packages/ml/src/Utils/ml_epetra_utils.cpp	2013-11-04 12:27:10.000000000 -0700
++++ packages/ml/src/Utils/ml_epetra_utils.cpp	2014-01-09 21:23:38.695744600 -0700
+@@ -39,8 +39,10 @@
+ #ifdef HAVE_ML_TEUCHOS
+ #include "Teuchos_ParameterList.hpp"
+ #endif
+-#ifdef _MSC_VER
++#if defined(_MSC_VER)
+ # include "winprocess.h"
++#elif defined(__MINGW32__)
++# include "windows.h"
+ #endif
+ 
+ #ifdef HAVE_ML_TEUCHOS
+@@ -3515,6 +3517,11 @@
+       if (i == Comm.MyPID() ) {
+ #if defined(TFLOP) || defined(JANUS_STLPORT) || defined(COUGAR)
+     sprintf(buf, "Host: %s   PID: %d", "janus", getpid());
++#elif defined(__MINGW32__)
++// getpid not present for mingw
++    sprintf(buf, "Host: %s   PID: %d", "mingw32", 0);
++#elif defined(_MSC_VER)
++    sprintf(buf, "Host: %s   PID: %d", "msvc", getpid());
+ #else
+     gethostname(hostname, sizeof(hostname));
+     int pid = getpid();
+@@ -3523,8 +3530,10 @@
+ #endif
+     printf("%s\n",buf);
+     fflush(stdout);
+-#ifdef ICL
++#if defined(ICL)
+     Sleep(1);
++#elif defined(__MINGW32__)
++    Sleep(1000.);  // Windows sleep is in milliseconds
+ #else
+     sleep(1);
+ #endif
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.c trilinos-11.4.3/packages/ml/src/Utils/ml_utils.c
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.c	2014-02-06 15:46:27.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_utils.c	2014-02-06 15:48:40.000000000 -0700
@@ -1956,13 +1956,15 @@
       if (i == mypid) {
 #if defined(TFLOP) || defined(JANUS_STLPORT) || defined(COUGAR)
         sprintf(buf, "Host: %s   PID: %d", "janus", getpid());
+#elif defined(__MINGW32__)
+        sprintf(buf, "Host: %s   PID: %d", "mingw", getpid());
 #else
         gethostname(hostname, sizeof(hostname));
         sprintf(buf, "Host: %s   PID: %d (mpi task %d)", hostname, getpid(),mypid);
 #endif
         printf("%s\n",buf);
         fflush(stdout);
-#ifdef ICL
+#if defined(ICL) || defined(__MINGW32__)
         Sleep(1);
 #else
         sleep(1);
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.c.orig trilinos-11.4.3/packages/ml/src/Utils/ml_utils.c.orig
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_utils.c.orig	2013-11-21 13:12:26.000000000 -0700
@@ -0,0 +1,2675 @@
+/* the file COPYRIGHT for a complete copyright notice, contact      */
+/* person and disclaimer.                                               */        
+/* ******************************************************************** */
+
+/* ******************************************************************** */
+/* Miscellaneous functions for efficient searching and sorting          */
+/* ******************************************************************** */
+/* Author        : Charles Tong (LLNL) and Raymond Tuminaro (SNL)       */
+/* Date          : September, 1998                                      */
+/* ******************************************************************** */
+
+/*
+Current revision: $Revision$
+Branch:           $Branch$
+Last modified:    $Date$
+Modified by:      $Author$
+*/
+
+#include <math.h>
+#include <stdlib.h>
+#include "ml_utils.h"
+#include "ml_comm.h"
+#include "ml_lapack.h"
+#include <time.h>
+#include "ml_viz_stats.h"
+#ifdef _MSC_VER
+#pragma comment(lib, "Ws2_32.lib") 
+# include <Winsock2.h>
+# include <process.h>
+void sleep(int sec)
+{
+  Sleep(sec * 1000);
+}
+#endif
+
+/* For hashing macro defined in ml_utils.h. */
+uint32_t ml_unew_val;
+
+
+#ifdef ML_WITH_EPETRA
+extern int ML_Epetra_RowMatrix_getrow(ML_Operator *data, int N_requested_rows, 
+                               int requested_rows[], int allocated_space, 
+                               int columns[], double values[],
+                               int row_lengths[]);
+  
+extern int ML_Epetra_CrsMatrix_getrow(ML_Operator *data, int N_requested_rows,
+			       int requested_rows[], int allocated_space, 
+			       int columns[], double values[],
+                               int row_lengths[]);
+
+extern int ML_Epetra_VbrMatrix_getrow(ML_Operator *data, int N_requested_rows,
+			       int requested_rows[], int allocated_space, 
+			       int columns[], double values[],
+                               int row_lengths[]);
+
+extern int Epetra_ML_GetCrsDataptrs(ML_Operator *data, double **values, int **cols, int **rowptr);
+#endif
+
+
+
+/* ******************************************************************** */
+/* Timer subroutine                                                     */
+/* ******************************************************************** */
+
+/* Generic timer ... I hope it works on lots of different machines */
+#ifdef AZTEC
+
+#ifdef __cplusplus
+extern "C" 
+{
+#endif
+extern double machine_dependent_second(void);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+double GetClock(void)
+{
+#ifdef AZTEC
+return( machine_dependent_second());
+#else
+#ifdef SMOS
+  double dclock();
+  return (dclock());
+#else
+  static clock_t last_num_ticks = 0;
+  static double  inv_clocks_per_sec = 1./(double)CLOCKS_PER_SEC;
+  static double  clock_width =
+    (double)(1L<<((int)sizeof(clock_t)*8-2))*4./(double)CLOCKS_PER_SEC;
+  static int     clock_rollovers = 0;
+  double value;
+  clock_t num_ticks = clock();
+  if(num_ticks < last_num_ticks) clock_rollovers++;
+  value = num_ticks * inv_clocks_per_sec;
+  if(clock_rollovers) value += clock_rollovers * clock_width;
+  last_num_ticks = num_ticks;
+  return(value);
+#endif
+#endif
+}
+
+
+/* Random Numbers */
+static int ml_random_seed = 0;
+static int ml_random_start = 1;
+
+
+
+/* ******************************************************************** */
+/* StartTimer                                                           */
+/*   t0   (out) start time                                              */ 
+/* ******************************************************************** */
+void StartTimer(double* t0)
+{
+#ifdef ML_TIMING
+  *t0 = GetClock();
+#else
+  return;
+#endif
+}
+
+/* ******************************************************************** */
+/* StopTimer                                                            */
+/*   t0   (in/out) On entry, the start time recorded by a previous call */
+/*                 to either StartTimer() or StopTimer().               */
+/*                 On exit, the stop time.                              */ 
+/*   delta (out)   Difference between current time and that passed      */
+/*                 in via t0.                                           */
+/* ******************************************************************** */
+
+void StopTimer(double* t0, double *delta)
+{
+#ifdef ML_TIMING
+  double now;
+
+  now = GetClock();
+  *delta = now - *t0;
+  *t0 = now;
+#else
+  return;
+#endif
+}
+
+/* ******************************************************************** */
+/* ReportTimer                                                          */
+/*   Reports average time over all processors & standard deviation.     */
+/*   Nothing prints if the ML print level is 0.                         */
+/*                                                                      */
+/*   t0        (in) The time to report.  This will be averaged over all */
+/*                  processors.                                         */
+/*   msgString (in) Pointer to message to print with time reported.     */ 
+/*   comm      (in) Pointer to an ML communicator.                      */
+/* ******************************************************************** */
+
+void ReportTimer(double t0, const char *msgString, ML_Comm *comm)
+{
+#ifdef ML_TIMING
+  double t1;
+#ifdef ML_MPI
+  ml_DblLoc srct,mint,maxt;
+#endif
+  if (ML_Get_PrintLevel() == 0)
+    return;
+  t1 = ML_gsum_double(t0, comm);
+  t1 = t1/((double) comm->ML_nprocs);
+# ifdef ML_MPI
+  srct.value = t0; 
+  srct.rank = comm->ML_mypid;
+  MPI_Reduce(&srct,&maxt,1,MPI_DOUBLE_INT,MPI_MAXLOC,0,comm->USR_comm);
+  MPI_Reduce(&srct,&mint,1,MPI_DOUBLE_INT,MPI_MINLOC,0,comm->USR_comm);
+  if (comm->ML_mypid==0 && comm->ML_nprocs > 1)
+    printf("%s \t avg = %1.3e seconds, min = %1.3e (%d), max = %1.3e (%d)\n",
+           msgString, t1, mint.value, mint.rank, maxt.value, maxt.rank);
+# endif /*ifdef ML_MPI*/
+  if (comm->ML_nprocs == 1)
+    printf("%s  = %1.3e seconds\n",msgString,t1);
+#else
+  return;
+#endif /*ifdef ML_TIMING*/
+}
+
+/* ******************************************************************** */
+/* Given an unsorted list of indices and the key, see whether the key   */
+/* is in the list                                                       */
+/* -------------------------------------------------------------------- */
+
+int ML_crude_search(int key, int nlist, int *list) 
+{
+   int  i, found=0;
+
+   for ( i = 0; i < nlist; i++ )
+   {
+      if ( list[i] == key ) 
+      {
+         found = 1;
+         break;
+      }
+   }
+   if ( found == 1 ) return 0;
+   else              return -1;
+}
+
+/* ******************************************************************** */
+/* Given a sorted list of indices and the key, find the position of the */
+/* key in the list.  If not found, return the index of the position     */
+/* corresponding to where it would have been stored.                    */
+/* -------------------------------------------------------------------- */
+
+int ML_fastsorted_search(int key, int nlist, int *list, int init_guess) 
+{
+   int  nfirst, nlast, nmid, found, index = 0;
+
+   if (nlist <= 0) return -1;
+   if (list[init_guess] == key) return init_guess;
+   if (list[init_guess] > key ) {
+     nlast = init_guess;
+     nfirst = init_guess - 5;
+     if (nfirst < 0) nfirst = 0;
+     while ( list[nfirst] > key) {
+       nfirst -= 5;
+       if (nfirst < 0) nfirst = 0;
+     }
+   }
+   else {
+     nfirst = init_guess;
+     nlast = init_guess + 5;
+     if (nlast > nlist-1) nlast = nlist-1;
+     while ( list[nlast] < key) {
+       nlast += 5;
+       if (nlast > nlist-1) nlast = nlist-1;
+     }
+   }
+   if (key > list[nlast])  return -(nlast+1);
+   if (key < list[nfirst]) return -(nfirst+1);
+   found = 0;
+   while ((found == 0) && ((nlast-nfirst)>1)) {
+      nmid = (nfirst + nlast) / 2;
+      if (key == list[nmid])     {index  = nmid; found = 1;}
+      else if (key > list[nmid])  nfirst = nmid;
+      else                        nlast  = nmid;
+   }
+   if (found == 1)               return index;
+   else if (key == list[nfirst]) return nfirst;
+   else if (key == list[nlast])  return nlast;
+   else                          return -(nfirst+1);
+}
+/* ******************************************************************** */
+/* Given a sorted list of indices and the key, find the position of the */
+/* key in the list.  If not found, return the index of the position     */
+/* corresponding to where it would have been stored.                    */
+/* -------------------------------------------------------------------- */
+
+int ML_sorted_search(int key, int nlist, int *list) 
+{
+   int  nfirst, nlast, nmid, found, index = 0;
+
+   if (nlist <= 0) return -1;
+   nfirst = 0;  
+   nlast  = nlist-1;
+   if (key > list[nlast])  return -(nlast+1);
+   if (key < list[nfirst]) return -(nfirst+1);
+   found = 0;
+   while ((found == 0) && ((nlast-nfirst)>1)) {
+      nmid = (nfirst + nlast) / 2;
+      if (key == list[nmid])     {index  = nmid; found = 1;}
+      else if (key > list[nmid])  nfirst = nmid;
+      else                        nlast  = nmid;
+   }
+   if (found == 1)               return index;
+   else if (key == list[nfirst]) return nfirst;
+   else if (key == list[nlast])  return nlast;
+   else                          return -(nfirst+1);
+}
+
+/* ******************************************************************** */
+/* This is another search subroutine which saves space by using a bit   */
+/* map to store where a given key has been accessed before.  It only    */
+/* returns a success if the key is found and it has never been accessed */
+/* before.                                                              */
+/* -------------------------------------------------------------------- */
+
+int ML_sorted_search2(int key,int nlist,int *list,int cnum,int **map) 
+{
+   int  nfirst, nlast, nmid, found, index = 0, retdata = 0, col, digit, mask;
+   int  nbit_int=sizeof(int)*8;
+
+   nfirst = 0;  
+   nlast  = nlist-1;
+   found = 0;
+   while ((found == 0) && ((nlast-nfirst)>1)) {
+      nmid = (nfirst + nlast) / 2;
+      if (key == list[nmid])     {index  = nmid; found = 1;}
+      else if (key > list[nmid])  nfirst = nmid;
+      else                        nlast  = nmid;
+   }
+   if (found == 1)               retdata = index;
+   else if (key == list[nfirst]) retdata = nfirst;
+   else if (key == list[nlast])  retdata = nlast;
+   col   = cnum / nbit_int;
+   digit = cnum % nbit_int;
+   mask  = 1 << digit;
+   if ((map[retdata][col] & mask) == 0) {
+      map[retdata][col] = map[retdata][col] | mask;
+      return retdata;
+   } else return -1;   
+}
+
+/* ******************************************************************** */
+/* Given a sorted list of indices and the key, this subroutine finds    */
+/* the the position of the key in the list.  If not found, insert the   */
+/* key at the appropriate place. (This will be slow.)                   */
+/* -------------------------------------------------------------------- */
+
+int ML_search_insert_sort(int key, int *list, int *nlist, int *cnt_list)
+{
+   int  i, index, n;
+
+   n = (*nlist);
+   index = ML_sorted_search(key, *nlist, list);
+   if (index < 0) {
+      index = - (index + 1);
+      if ( n == 0 ) { 
+         index = 0; 
+         list[0] = key; 
+         if ( cnt_list != 0 ) cnt_list[0] = 1;
+      } else {
+         for ( i = n-1; i > index; i-- ) list[i+1] = list[i];
+         if ( cnt_list != 0 ) 
+            for ( i = n-1; i > index; i-- ) cnt_list[i+1] = cnt_list[i];
+         if (key > list[index]) {
+            index++;
+            list[index] = key;
+            if ( cnt_list != 0 ) cnt_list[index] = 1; 
+         } else {
+            list[index+1] = list[index]; 
+            list[index] = key;
+            if ( cnt_list != 0 ) {
+               cnt_list[index+1] = cnt_list[index];
+               cnt_list[index] = 1;
+            }
+         }
+      }
+      (*nlist)++;
+   } else {
+      if ( cnt_list != 0 ) cnt_list[index]++;
+   }
+   return index;
+}
+
+/* ******************************************************************** */
+/* Check a given object to see what it is.                              */
+/* -------------------------------------------------------------------- */
+
+int ML_Check_Context( void *obj )
+{
+   int     id;
+   ML_Comm *comm;
+
+   comm = (ML_Comm *) obj;
+   
+   id = comm->ML_id;
+   switch ( id ) {
+      case ML_ID_ML : printf("It is a ML object.\n");
+                      break;
+      case ML_ID_SL : printf("It is a SL object.\n");
+                      break;
+      default :       printf("Object not recognized. \n");
+   }
+   return id;
+}
+
+/* ******************************************************************** */
+/* sort a given list in increasing order                                */
+/* -------------------------------------------------------------------- */
+
+int ML_sort(int nlist, int *list) 
+{
+   int  i, key, *cnt1_array, *cnt2_array, begin, count1, count2;
+
+   if ( nlist <= 1 ) return 0;
+   if ( nlist == 2 ) 
+   {
+      if ( list[0] > list[1] ) 
+      {
+         key = list[0];
+         list[0] = list[1];
+         list[1] = key;
+      }
+      return 0;
+   }
+   key = list[0];
+   count1 = 0;
+   count2 = 0;
+   cnt1_array = (int*) ML_allocate( nlist * sizeof(int) );
+   cnt2_array = (int*) ML_allocate( nlist * sizeof(int) );
+   for ( i = 1; i < nlist; i++ ) 
+   {
+      if ( list[i] <  key ) cnt1_array[count1++] = list[i];
+      if ( list[i] >= key ) cnt2_array[count2++] = list[i];
+   }
+   for ( i = 0; i < count1; i++ ) list[i] = cnt1_array[i];
+   list[count1] = key;
+   for ( i = 0; i < count2; i++ ) list[count1+1+i] = cnt2_array[i];
+   ML_free( cnt1_array );
+   ML_free( cnt2_array );
+   ML_sort( count1, list );
+   begin = count1+1;
+   for ( i = count1+1; i < nlist; i++ ) 
+   {
+      if ( list[i] != key ) break;
+      else                  { begin++; count2--; }
+   }
+   ML_sort( count2, &list[begin] );
+   return 0;
+}
+
+/* ******************************************************************** */
+/* sort a given list in increasing order                                */
+/* -------------------------------------------------------------------- */
+
+int ML_split_dsort(double *dlist, int nlist, int *ilist, int limit) 
+{
+   int    itemp, *iarray1, *iarray2, count1, count2, i;
+   double dtemp, *darray1, *darray2;
+
+   if ( nlist <= 1 ) return 0;
+   if ( nlist == 2 ) 
+   {
+      if ( dlist[0] < dlist[1] ) 
+      {
+         dtemp = dlist[0]; dlist[0] = dlist[1]; dlist[1] = dtemp;
+         itemp = ilist[0]; ilist[0] = ilist[1]; ilist[1] = itemp;
+      }
+      return 0;
+   }
+   count1 = 0;
+   count2 = 0;
+   iarray1 = (int *)   ML_allocate( 2 * nlist * sizeof(int) );
+   iarray2 = iarray1 + nlist;
+   darray1 = (double*) ML_allocate( 2 * nlist * sizeof(double) );
+   darray2 = darray1 + nlist;
+
+   if ( darray2 == NULL )
+   {
+      printf("ERROR : malloc\n");
+      exit(1);
+   }
+   dtemp  = dlist[0];
+   itemp  = ilist[0];
+   for ( i = 1; i < nlist; i++ ) 
+   {
+      if (dlist[i] >= dtemp  ) 
+      {
+         darray1[count1] = dlist[i];
+         iarray1[count1++] = ilist[i];
+      } 
+      else if (dlist[i] <  dtemp) 
+      {
+         darray2[count2] = dlist[i];
+         iarray2[count2++] = ilist[i];
+      }
+   }
+   dlist[count1] = dtemp;
+   ilist[count1] = itemp;
+   for ( i = 0; i < count1; i++ ) 
+   {
+      dlist[i] = darray1[i];
+      ilist[i] = iarray1[i];
+   }
+   for ( i = 0; i < count2; i++ ) 
+   {
+      dlist[count1+1+i] = darray2[i];
+      ilist[count1+1+i] = iarray2[i];
+   }
+   ML_free( darray1 );
+   ML_free( iarray1 );
+   if ( count1+1 == limit ) return 0;
+   else if ( count1+1 < limit )
+      ML_split_dsort(&(dlist[count1+1]),count2,&(ilist[count1+1]),limit-count1-1);
+   else
+      ML_split_dsort( dlist, count1, ilist, limit );
+   return 0;
+}
+
+/* ******************************************************************** */
+/* selection sort                                                       */
+/* -------------------------------------------------------------------- */
+
+int ML_selection_dsort(double *vals, int length, int *cols, int limit)
+{
+   int    i, k, ind1, ind2, ind3, loopcnt, base, level, newcount;
+   double *darray, *darray1, *darray2, **treeArray;
+   int    expLeng, tmpLeng, *treeLengs, **treeIArray, *iarray, *iarray1, *iarray2;
+   int    col1, col2;
+   double val1, val2;
+
+   level = (int) (log( 2.0 * length ) / log( 2.0 ));
+   printf("level = %d\n", level);
+
+   /* set up data structure */
+
+   expLeng    = (int) pow(2.0, (double) (level+1));
+   iarray     = (int    *)  ML_allocate(expLeng   * sizeof(int));
+   darray     = (double *)  ML_allocate(expLeng   * sizeof(double));
+   treeLengs  = (int *)     ML_allocate((level+1) * sizeof(int));
+   treeArray  = (double **) ML_allocate((level+1) * sizeof(double*));
+   treeIArray = (int **)    ML_allocate((level+1) * sizeof(int*));
+   treeLengs[level]  = length;
+   base              = expLeng >> 1;
+   treeArray[level]  = &(darray[base]);
+   treeIArray[level] = &(iarray[base]);
+   for ( k = level-1; k >= 0; k-- )
+   {
+      base = base >> 1;
+      treeArray[k] = &(darray[base]);
+      treeIArray[k] = &(iarray[base]);
+      treeLengs[k] = ( treeLengs[k+1] + 1 ) / 2;
+   }
+   darray1 = treeArray[level];
+   iarray1 = treeIArray[level];
+   for ( i = 0; i < length; i++ )
+   {
+      darray1[i] = vals[i];
+      iarray1[i] = cols[i];
+   }
+   if ( length < expLeng )
+   {
+      darray1[length] = 0.0;
+      iarray1[length] = 0;
+   }
+
+   /* pre-sort */
+
+   for ( k = level; k > 0; k-- )
+   {
+      darray1 = treeArray[k];
+      iarray1 = treeIArray[k];
+      darray2 = treeArray[k-1];
+      iarray2 = treeIArray[k-1];
+      tmpLeng = treeLengs[k];
+      for ( i = 0; i < tmpLeng; i+=2 )
+      {
+         ind1 = i + 1;
+         ind2 = i >> 1;
+         if ( darray1[i] > darray1[ind1] )
+         {
+            iarray2[ind2] = iarray1[i];
+            darray2[ind2] = darray1[i];
+         }
+         else
+         {
+            iarray2[ind2] = iarray1[ind1];
+            darray2[ind2] = darray1[ind1];
+         }
+      }
+      if ( tmpLeng % 2 == 1 )
+      {
+         iarray2[treeLengs[k-1]-1] = iarray1[tmpLeng-1];
+         darray2[treeLengs[k-1]-1] = darray1[tmpLeng-1];
+      }
+   }
+
+   /* post-sort */
+
+   loopcnt = limit;
+   newcount = 0;
+   while ( loopcnt > 0 )
+   {
+      if ( loopcnt % 100000 == 0 ) printf("loopcnt = %d\n", loopcnt);
+      vals[newcount] = darray[1];
+      cols[newcount++] = iarray[1];
+      darray1 = treeArray[level];
+      darray1[iarray[1]] = 0.0;
+      ind3 = iarray[1] >> 1;
+      ind1 = ind3 << 1;
+      ind2 = ind1 + 1;
+      for ( k = level; k > 0; k-- )
+      {
+         iarray2 = treeIArray[k-1];
+         darray2 = treeArray[k-1];
+         col1 = treeIArray[k][ind1];
+         col2 = treeIArray[k][ind2];
+         val1 = treeArray[k][ind1];
+         val2 = treeArray[k][ind2];
+         if ( val1 > val2 )
+         {
+            iarray2[ind3] = col1;
+            darray2[ind3] = val1;
+         }
+         else
+         {
+            iarray2[ind3] = col2;
+            darray2[ind3] = val2;
+         }
+         ind3 = ind3 >> 1;
+         ind1 = ind3 << 1;
+         ind2 = ind1 + 1;
+      }
+      loopcnt--;
+   }
+
+   ML_free(darray);
+   ML_free(treeArray);
+   ML_free(treeLengs);
+   return 0;
+}
+
+/* ******************************************************************** */
+/* randomize an integer array                                           */
+/* -------------------------------------------------------------------- */
+
+int ML_random_init() 
+{
+/*
+   double stime;
+   stime = GetClock();
+*/
+   return 0;
+}
+
+/* ******************************************************************** */
+/* randomize an integer array                                           */
+/* -------------------------------------------------------------------- */
+int ML_randomize(int nlist, int *list) 
+{
+   int    i, nm1, iran1, iran2, itmp;
+
+   nm1    = nlist - 1;
+   for ( i = 0; i < 3*nlist; i++ )
+   {
+      iran1 = (int) ( nm1 * ML_srandom1(&ml_random_seed) );
+      iran2 = (int) ( nm1 * ML_srandom1(&ml_random_seed) );
+      if ( iran1 != iran2 )
+      {
+         itmp        = list[iran2];
+         list[iran2] = list[iran1];
+         list[iran1] = itmp;
+      }
+   }
+   return 0;
+}
+
+/*************************************************************************/
+/*************************************************************************/
+/*************************************************************************/
+
+/**************************************************************************
+
+  This routine was taken from Knuth: Sorting and Searching. It puts the input
+  data list into a heap and then sorts it.
+
+  Author:          Ray Tuminaro, SNL, 1422
+  =======
+
+  Return code:     double, maximum value in vector 'vec'
+  ============
+
+  Parameter list:
+  ===============
+
+  list:            On input, values to be sorted. On output, sorted values
+                   (i.e., list[i] <= list[i+1]).
+
+  N:               length of vector 'vec'.
+
+  list2:           If on input,
+                   a) list2 = NULL: it is unchanged on output,
+                   b) list2 is a list associated with 'list':
+                   on output, if list[k] on input is now element 'j' on output,
+                   list2[j] on output is list2[k].
+
+  list3:           If on input,
+                   a) list3 = NULL: it is unchanged on output,
+                   b) list3 is a list associated with 'list':
+                   on output, list3[j] is assigned the input value of list3[k],
+                   if list[j] has been assigned the input value of list[k].
+
+**************************************************************************/
+
+void ML_az_dsort(double list[], int N)
+{
+
+  /* local variables */
+
+  int    l, r, j, i, flag;
+  double RR, K;
+
+  /*********************** execution begins ******************************/
+
+  if (N <= 1) return;
+
+  l   = N / 2 + 1;
+  r   = N - 1;
+  l   = l - 1;
+  RR  = list[l - 1];
+  K   = list[l - 1];
+
+    while (r != 0) {
+      j = l;
+      flag = 1;
+
+      while (flag == 1) {
+        i = j;
+        j = j + j;
+
+        if (j > r + 1)
+          flag = 0;
+        else {
+          if (j < r + 1)
+            if (list[j] > list[j - 1]) j = j + 1;
+
+          if (list[j - 1] > K) {
+            list[ i - 1] = list[ j - 1];
+          }
+          else {
+            flag = 0;
+          }
+        }
+      }
+
+      list[ i - 1] = RR;
+
+      if (l == 1) {
+        RR  = list [r];
+
+        K = list[r];
+        list[r ] = list[0];
+        r = r - 1;
+      }
+      else {
+        l   = l - 1;
+        RR  = list[ l - 1];
+        K   = list[l - 1];
+      }
+    }
+
+    list[ 0] = RR;
+
+} 
+
+/* ******************************************************************** */
+/* sort an integer array                                                */
+/* -------------------------------------------------------------------- */
+
+void ML_az_sort(int list[], int N, int list2[], double list3[])
+{
+
+  /* local variables */
+
+  int    l, r, RR, K, j, i, flag;
+  int    RR2;
+  double RR3;
+
+  /*********************** execution begins ******************************/
+
+  if (N <= 1) return;
+
+  l   = N / 2 + 1;
+  r   = N - 1;
+  l   = l - 1;
+  RR  = list[l - 1];
+  K   = list[l - 1];
+
+  if ((list2 != NULL) && (list3 != NULL)) {
+    RR2 = list2[l - 1];
+    RR3 = list3[l - 1];
+    while (r != 0) {
+      j = l;
+      flag = 1;
+
+      while (flag == 1) {
+        i = j;
+        j = j + j;
+
+        if (j > r + 1)
+          flag = 0;
+        else {
+          if (j < r + 1)
+            if (list[j] > list[j - 1]) j = j + 1;
+
+          if (list[j - 1] > K) {
+            list[ i - 1] = list[ j - 1];
+            list2[i - 1] = list2[j - 1];
+            list3[i - 1] = list3[j - 1];
+          }
+          else {
+            flag = 0;
+          }
+        }
+      }
+
+      list[ i - 1] = RR;
+      list2[i - 1] = RR2;
+      list3[i - 1] = RR3;
+
+      if (l == 1) {
+        RR  = list [r];
+        RR2 = list2[r];
+        RR3 = list3[r];
+
+        K = list[r];
+        list[r ] = list[0];
+        list2[r] = list2[0];
+        list3[r] = list3[0];
+        r = r - 1;
+      }
+      else {
+        l   = l - 1;
+        RR  = list[ l - 1];
+        RR2 = list2[l - 1];
+        RR3 = list3[l - 1];
+        K   = list[l - 1];
+      }
+    }
+
+    list[ 0] = RR;
+    list2[0] = RR2;
+    list3[0] = RR3;
+  }
+  else if (list2 != NULL) {
+    RR2 = list2[l - 1];
+    while (r != 0) {
+      j = l;
+      flag = 1;
+
+      while (flag == 1) {
+        i = j;
+        j = j + j;
+
+        if (j > r + 1)
+          flag = 0;
+        else {
+          if (j < r + 1)
+            if (list[j] > list[j - 1]) j = j + 1;
+
+          if (list[j - 1] > K) {
+            list[ i - 1] = list[ j - 1];
+            list2[i - 1] = list2[j - 1];
+          }
+          else {
+            flag = 0;
+          }
+        }
+      }
+
+      list[ i - 1] = RR;
+      list2[i - 1] = RR2;
+
+      if (l == 1) {
+        RR  = list [r];
+        RR2 = list2[r];
+
+        K = list[r];
+        list[r ] = list[0];
+        list2[r] = list2[0];
+        r = r - 1;
+      }
+      else {
+        l   = l - 1;
+        RR  = list[ l - 1];
+        RR2 = list2[l - 1];
+        K   = list[l - 1];
+      }
+    }
+
+    list[ 0] = RR;
+    list2[0] = RR2;
+  }
+  else if (list3 != NULL) {
+    RR3 = list3[l - 1];
+    while (r != 0) {
+      j = l;
+      flag = 1;
+
+      while (flag == 1) {
+        i = j;
+        j = j + j;
+
+        if (j > r + 1)
+          flag = 0;
+        else {
+          if (j < r + 1)
+            if (list[j] > list[j - 1]) j = j + 1;
+
+          if (list[j - 1] > K) {
+            list[ i - 1] = list[ j - 1];
+            list3[i - 1] = list3[j - 1];
+          }
+          else {
+            flag = 0;
+          }
+        }
+      }
+
+      list[ i - 1] = RR;
+      list3[i - 1] = RR3;
+
+      if (l == 1) {
+        RR  = list [r];
+        RR3 = list3[r];
+
+        K = list[r];
+        list[r ] = list[0];
+        list3[r] = list3[0];
+        r = r - 1;
+      }
+      else {
+        l   = l - 1;
+        RR  = list[ l - 1];
+        RR3 = list3[l - 1];
+        K   = list[l - 1];
+      }
+    }
+
+    list[ 0] = RR;
+    list3[0] = RR3;
+
+  }
+  else {
+    while (r != 0) {
+      j = l;
+      flag = 1;
+
+      while (flag == 1) {
+        i = j;
+        j = j + j;
+
+        if (j > r + 1)
+          flag = 0;
+        else {
+          if (j < r + 1)
+            if (list[j] > list[j - 1]) j = j + 1;
+
+          if (list[j - 1] > K) {
+            list[ i - 1] = list[ j - 1];
+          }
+          else {
+            flag = 0;
+          }
+        }
+      }
+
+      list[ i - 1] = RR;
+
+      if (l == 1) {
+        RR  = list [r];
+
+        K = list[r];
+        list[r ] = list[0];
+        r = r - 1;
+      }
+      else {
+        l   = l - 1;
+        RR  = list[ l - 1];
+        K   = list[l - 1];
+      }
+    }
+
+    list[ 0] = RR;
+  }
+
+} 
+
+/* ******************************************************************** */
+/* sort a double array                                                  */
+/* -------------------------------------------------------------------- */
+
+void ML_az_dsort2(double dlist[], int N, int list2[])
+{
+  int    l, r, j, i, flag;
+  int    RR2;
+  double dRR, dK;
+
+  if (N <= 1) return;
+
+  l    = N / 2 + 1;
+  r    = N - 1;
+  l    = l - 1;
+  dRR  = dlist[l - 1];
+  dK   = dlist[l - 1];
+
+  if (list2 != NULL) {
+     RR2 = list2[l - 1];
+     while (r != 0) {
+        j = l;
+        flag = 1;
+
+        while (flag == 1) {
+           i = j;
+           j = j + j;
+
+           if (j > r + 1)
+              flag = 0;
+           else {
+              if (j < r + 1)
+                 if (dlist[j] > dlist[j - 1]) j = j + 1;
+
+              if (dlist[j - 1] > dK) {
+                 dlist[ i - 1] = dlist[ j - 1];
+                 list2[i - 1] = list2[j - 1];
+              }
+              else {
+                 flag = 0;
+              }
+           }
+        }
+        dlist[ i - 1] = dRR;
+        list2[i - 1] = RR2;
+
+        if (l == 1) {
+           dRR  = dlist [r];
+           RR2 = list2[r];
+           dK = dlist[r];
+           dlist[r ] = dlist[0];
+           list2[r] = list2[0];
+           r = r - 1;
+         }
+         else {
+            l   = l - 1;
+            dRR  = dlist[ l - 1];
+            RR2 = list2[l - 1];
+            dK   = dlist[l - 1];
+         }
+      }
+      dlist[ 0] = dRR;
+      list2[0] = RR2;
+   }
+   else {
+      while (r != 0) {
+         j = l;
+         flag = 1;
+         while (flag == 1) {
+            i = j;
+            j = j + j;
+            if (j > r + 1)
+               flag = 0;
+            else {
+               if (j < r + 1)
+                  if (dlist[j] > dlist[j - 1]) j = j + 1;
+               if (dlist[j - 1] > dK) {
+                  dlist[ i - 1] = dlist[ j - 1];
+               }
+               else {
+                  flag = 0;
+               }
+            }
+         }
+         dlist[ i - 1] = dRR;
+         if (l == 1) {
+            dRR  = dlist [r];
+            dK = dlist[r];
+            dlist[r ] = dlist[0];
+            r = r - 1;
+         }
+         else {
+            l   = l - 1;
+            dRR  = dlist[ l - 1];
+            dK   = dlist[l - 1];
+         }
+      }
+      dlist[ 0] = dRR;
+   }
+
+}
+
+/******************************************************************************/
+
+void ML_gsum_scalar_int(int vals[], int vals2[], ML_Comm *comm)
+{
+#ifdef ML_MPI
+  MPI_Allreduce((void *) vals,(void *) vals2, 1, MPI_INT, MPI_SUM,
+                comm->USR_comm);
+  *vals = *vals2;
+#endif
+  return;
+} /* ML_gsum_scalar_int */
+
+/*************************************************************************/
+/*************************************************************************/
+/*************************************************************************/
+
+/**************************************************************************
+
+  For each element in vals[], perform a global sum with the other processors.
+  That is, on output vals[i] is equal to the sum of the input values in vals[i]
+  on all the processors.
+
+  Author:          Ray Tuminaro, SNL, 1422
+  =======
+
+  Return code:     void
+  ============
+
+  Parameter list:
+  ===============
+
+  tvals:           On input, vals[i] on this processor is to be summed with
+                   vals[i] on all the other processors.
+                   On output, vals[i] is the sum of the input values in val[i]
+                   defined on all processors.
+
+  tvals2:          Work space of size 'length'.
+
+  node:            Current processor number.
+
+  nprocs:          Number of processors in the current machine configuration.
+
+  length:          Number of values in 'vals' (i.e. number of global sums).
+
+**************************************************************************/
+
+void ML_gsum_vec_int(int **tvals, int **tvals2, int length, ML_Comm *comm)
+{
+#ifdef ML_MPI
+  int *tmpptr;
+  MPI_Allreduce((void *) *tvals,(void *) *tvals2, length, MPI_INT, MPI_SUM,
+                comm->USR_comm);
+  tmpptr = *tvals;
+  *tvals = *tvals2;
+  *tvals2 = tmpptr;
+#endif
+  return;
+} /* ML_gsum_vec_int */
+
+
+
+/* Just like the  ML_gsum_vec_int but for double vectors */
+
+void ML_gsum_vec_double(double **tvals, double **tvals2, int length, ML_Comm *comm)
+{
+#ifdef ML_MPI
+  double *tmpptr;
+
+  MPI_Allreduce((void *) *tvals,(void *) *tvals2, length, MPI_DOUBLE, MPI_SUM,
+                comm->USR_comm);
+  tmpptr = *tvals;
+  *tvals = *tvals2;
+  *tvals2 = tmpptr;
+#endif
+  return;
+} /* ML_gsum_vec_double */
+
+/***************************************************************************/
+/***************************************************************************/
+/***************************************************************************/
+void ML_rm_duplicates(int array[], int *N)
+{
+/*
+ * remove any duplicates that might appear in the SORTED
+ * array 'array'.
+ *
+ */
+  int k, kk;
+
+  kk = 0;
+  for (k = 1; k < *N; k++) {
+    if (array[kk] != array[k]) {
+      kk++;
+      array[kk] = array[k];
+    }
+  }
+  if (*N != 0) kk++;
+
+  *N= kk;
+}
+
+/*************************************************************************/
+/*************************************************************************/
+/*************************************************************************
+
+   Author:        John Shadid, SNL, 1421 Date: 8/1/94
+  =======
+
+  Return code:    (void).
+  ============
+
+  Parameter list:
+  ===============
+
+  num_neighbors:      total number of neighbors to communicate with
+  buffer:             on input  - buffer that holds the information to be sent
+                      on output - buffer contains the recieve information
+  start_send_proc:    contains index of start of information that is to be
+                      sent to each processor
+  actual_send_length: contains number of double precision entries to be sent to
+                      each processor
+  actual_recv_length: number of entries to be recieve from each processor
+  proc_num_neighbor:  contains the processor number for each neighbor
+  type:               the message type to be used in the mesage
+  total_num_recv:     on output - total number of actual recvieved entried
+
+**************************************************************************/
+void ML_splitup_big_msg(int num_neighbors, char *ibuffer, char *obuffer,
+			unsigned int element_size, int *start_send_proc,
+                        int *actual_send_length, int *actual_recv_length, int
+                        *proc_num_neighbor, int type, int *total_num_recv,
+                        ML_Comm *comm)
+{
+
+  /*
+   * This function handshakes big messages between all the neighbors.  The
+   * length of the messages are calculated conservatively to not allow overflow
+   * of the message buffers.
+   */
+
+  int     m, n, rtype, j, dummy_int;
+  int     max_neighbors, messg_size_doubles, doubles_sent;
+  int     total_doubles_to_send, dest, messg_from, messg_type;
+  int     total_doubles_to_recv, total_send_size;
+  int     *finished_send_messg;
+  int     *finished_recv_messg;
+  int     number_of_messages, *start_recv_proc;
+  int     allowed_buff_size, num_recv;
+  int     max_buffer_size = 0, max_messg_size;
+  char    *send_buffer;
+  char   *char_ptr;
+  char   *yo = "ML_splitup_big_msg ";
+  int     split_up = ML_FALSE;
+  int     dummy_add;
+  int     debug = ML_FALSE;
+  unsigned int length, size;
+  
+  
+  USR_REQ     *request;  /* Message handle */
+
+  /**************************** execution begins ****************************/
+
+  finished_send_messg = (int *) ML_allocate( (num_neighbors+10)*sizeof(int));
+  finished_recv_messg = (int *) ML_allocate( (num_neighbors+10)*sizeof(int));
+  start_recv_proc     = (int *) ML_allocate( (num_neighbors+10)*sizeof(int));
+  request             = (USR_REQ *) ML_allocate( (num_neighbors+10)*sizeof(USR_REQ));
+  if ( (request == NULL) || (start_recv_proc == NULL))
+     pr_error("ML_splitup_big_msg: out of space\n");
+
+  /* Compute the global maximum message buffer size needed */
+
+  
+  for (n = 0; n < num_neighbors; n++) {
+    max_buffer_size += actual_recv_length[n];
+  }
+  max_buffer_size = ML_gmax_int(max_buffer_size, comm);
+
+  /* Determine if splitting of messages is necessary */
+
+  /* Too big for message buffers */
+  /*  10/31/03  This code causes setup scaling problems.  You should only
+       uncomment it if you're encountering MPI buffer overflow problems. */
+  /*
+  if (max_buffer_size > (int) (ML_MAX_MSG_BUFF_SIZE / (2 * element_size))) {
+     split_up = ML_TRUE;
+  }
+  */
+
+  if (split_up == ML_TRUE) {
+
+    /*
+     * Compute maximum total message size in bytes that any processor will
+     * recieve and the maximum number of neighbors that any proc must
+     * communicate with. Also initalize some logical arrays.
+     */
+
+    max_messg_size = 0;
+    for (n = 0; n < num_neighbors; n++) {
+      max_messg_size = ML_max(max_messg_size, actual_recv_length[n]);
+      finished_send_messg[n] = finished_recv_messg[n] = ML_FALSE;
+    }
+    max_messg_size = ML_gmax_int(max_messg_size, comm);
+    max_neighbors  = ML_gmax_int(num_neighbors,  comm);
+
+    /*
+     * Total received nonzeros and starting location for each processors
+     * message that will be received
+     */
+
+    num_recv = 0;
+    for (n = 0; n < num_neighbors; n++) {
+      start_recv_proc[n] = num_recv;
+      num_recv          += actual_recv_length[n];
+    }
+    *total_num_recv = num_recv;
+
+    /*
+     * Compute the global maximum allowed message size and the maximum number of
+     * messages to send all the required information.
+     */
+
+    allowed_buff_size  = (int) floor(((double) ML_MAX_MSG_BUFF_SIZE /
+                                      (double) (3*element_size)));
+
+    messg_size_doubles = (int) floor((double) allowed_buff_size / 
+                                      (double) max_neighbors);
+
+    number_of_messages = (int) ceil((double) max_messg_size /
+                                    (double) (messg_size_doubles));
+
+    if (comm->ML_mypid == 0 && debug == ML_TRUE) {
+      (void) printf("\n\t\tSplitting up messages in splitup_big_msg\n");
+      (void) printf("\t\tmax_buffer_size required  (bytes): %d\n",
+                    max_buffer_size*element_size);
+      (void) printf("\t\tmax_buffer_size allocated (bytes): %d\n",
+                    allowed_buff_size*element_size);
+      (void) printf("\t\tindividual message size   (bytes): %d\n",
+                    messg_size_doubles*element_size);
+      (void) printf("\t\ttotal number of split messages to be sent: %d\n\n",
+                    number_of_messages);
+    }
+
+    if (ibuffer == obuffer) {
+       /*
+        * The input and output buffers are the same. Allocate a temporary 
+        * send buffer that can hold all out going messages.
+        * Then copy all info to this buffer.
+        */
+
+        total_send_size = 0;
+        for (n = 0; n < num_neighbors; n++) {
+           total_send_size += actual_send_length[n];
+        }
+
+        send_buffer =(char *) ML_allocate((total_send_size+1)*element_size);
+        if (send_buffer == NULL) {
+           (void) fprintf(stderr,
+                          "no space in ML_splitup_big_msg: send_buffer \n");
+           exit(-1);
+        }
+        for (n = 0; n < (int) (total_send_size*element_size) ; n++)
+          send_buffer[n] = ibuffer[n];
+    }
+    else send_buffer = ibuffer;
+
+    /*
+     * Send and receive messages in a series of communications. Each set of
+     * exchanges is followed by a syncronization to not allow message buffers to
+     * overflow.
+     */
+
+    doubles_sent = 0;
+
+    for (m = 0; m < number_of_messages; m++) {
+      type++;
+
+      /* post recieves for split messages */
+
+      for (n = 0; n < num_neighbors; n++) {
+
+        total_doubles_to_recv = actual_recv_length[n];
+        messg_from            = proc_num_neighbor[n];
+        dummy_int             = type;
+
+        if (doubles_sent + messg_size_doubles < total_doubles_to_recv ) {
+
+          /* read messg_size_doubles bytes */
+
+          length = messg_size_doubles*element_size;
+
+          char_ptr = (char *) (&obuffer[start_recv_proc[n]*element_size] + 
+                                       doubles_sent*element_size);
+          comm->USR_irecvbytes((void *) char_ptr, length, &messg_from, 
+                               &dummy_int,  comm->USR_comm, request+n);
+        }
+        else if (doubles_sent+messg_size_doubles >= total_doubles_to_recv &&
+                 finished_recv_messg[n] == ML_FALSE) {
+
+          /* read actual_recv_length[n] - doubles_sent bytes */
+
+          length = (total_doubles_to_recv - doubles_sent)*element_size;
+
+          char_ptr = (char *) (&obuffer[start_recv_proc[n]*element_size] + 
+                               doubles_sent*element_size);
+          comm->USR_irecvbytes((void *) char_ptr, length, &messg_from, 
+                               &dummy_int,  comm->USR_comm, request+n);
+        }
+        else if (finished_recv_messg[n] == ML_TRUE) {
+
+          /* read integer dummy message */
+
+          length = sizeof(int);
+          comm->USR_irecvbytes((void *) &dummy_add, length, &messg_from, 
+                                &dummy_int,  comm->USR_comm, request+n);
+        }
+      }
+
+      /* write split messages */
+
+      for (n = 0; n < num_neighbors; n++) {
+        total_doubles_to_send = actual_send_length[n];
+        dest                  = proc_num_neighbor[n];
+
+        if (doubles_sent + messg_size_doubles < total_doubles_to_send) {
+
+          /* send out messg_size_doubles bytes */
+
+          length = messg_size_doubles*element_size;
+          char_ptr = (char *) (&send_buffer[element_size*start_send_proc[n]] + 
+                               doubles_sent*element_size);
+          (void) comm->USR_sendbytes((void *) char_ptr, length, dest, type,
+				     comm->USR_comm);
+        }
+        else if (doubles_sent + messg_size_doubles >= total_doubles_to_send &&
+                 finished_send_messg[n] == ML_FALSE) {
+
+          /* send out actual_send_length[n] - doubles_sent bytes */
+
+          length = (total_doubles_to_send - doubles_sent)*element_size;
+
+          char_ptr = (char *) (&send_buffer[start_send_proc[n]*element_size] + 
+                               doubles_sent*element_size);
+          (void) comm->USR_sendbytes((void *) char_ptr, length, dest, type, 
+				     comm->USR_comm);
+
+          finished_send_messg[n] = ML_TRUE;
+        }
+        else if (finished_send_messg[n] == ML_TRUE) {
+
+          /* send out integer dummy message */
+
+          length = sizeof(int);
+          (void) comm->USR_sendbytes((void *) &dummy_add, length, dest, type, 
+				     comm->USR_comm);
+        }
+      }
+
+      /* read split messages */
+
+      for (n = 0; n < num_neighbors; n++) {
+        total_doubles_to_recv = actual_recv_length[n];
+        messg_from            = proc_num_neighbor[n];
+        messg_type            = type;
+
+        if (doubles_sent + messg_size_doubles < total_doubles_to_recv ) {
+
+          /* read messg_size_doubles bytes */
+
+          length = messg_size_doubles*element_size;
+          char_ptr = (char *) (&obuffer[start_recv_proc[n]*element_size] + 
+                               doubles_sent*element_size);
+          size =  comm->USR_waitbytes((void *) char_ptr, length, &messg_from,
+                             &messg_type, comm->USR_comm, request+n); 
+
+          if (length > size) {
+           (void) fprintf(stderr,"%sE4ROR on node %d\nwait failed, message type = %d    %d %d (%d)\n", yo, comm->ML_mypid, 
+                          messg_type,length,size,messg_from);
+           exit(-1);
+          }
+        }
+        else if (doubles_sent+messg_size_doubles >= total_doubles_to_recv &&
+                 finished_recv_messg[n] == ML_FALSE) {
+
+          /* read actual_recv_length[n] - doubles_sent bytes */
+
+          length = (total_doubles_to_recv - doubles_sent)*element_size;
+          char_ptr = (char *) (&obuffer[start_recv_proc[n]*element_size] + 
+                               doubles_sent*element_size);
+          size =  comm->USR_waitbytes((void *) char_ptr, length, &messg_from,
+                                      &messg_type, comm->USR_comm, request+n); 
+
+          if (length > size) {
+           (void) fprintf(stderr,"%sE3ROR on node %d\nwait failed, message type = %d   %d %d  (%d)\n", yo, comm->ML_mypid, 
+                          messg_type,length,size,messg_from);
+           exit(-1);
+          }
+
+          finished_recv_messg[n] = ML_TRUE;
+        }
+        else if (finished_recv_messg[n] == ML_TRUE) {
+
+          /* read integer dummy message */
+
+          length = sizeof(int);
+          size =  comm->USR_waitbytes((void *) &dummy_add, length, &messg_from,
+                             &messg_type, comm->USR_comm, request+n); 
+
+          if (length > size) {
+           (void) fprintf(stderr,"%sE2ROR on node %d\nwait failed, message type = %d %d %d (%d)\n", yo, comm->ML_mypid, 
+                          messg_type,length,size,messg_from);
+           exit(-1);
+          }
+
+        }
+      }
+
+      doubles_sent += messg_size_doubles;
+
+
+      j = 3; j = ML_gmax_int(j, comm); /* synchronize procs */
+    }
+
+    if (ibuffer == obuffer) {ML_free(send_buffer); send_buffer = NULL;}
+    ML_free(request);
+    ML_free(start_recv_proc);
+    ML_free(finished_recv_messg);
+    ML_free(finished_send_messg);
+    return;
+  }
+
+  else {
+     type++;
+     
+     if (ibuffer == obuffer ) {
+        /* Allocate a send buffer, if the input */
+        /* and output buffers are the same.     */
+        total_send_size = 0;
+        for (n = 0; n < num_neighbors; n++) {
+           total_send_size += actual_send_length[n];
+        }
+        send_buffer = (char *) ML_allocate((total_send_size+1)*element_size);
+        if (send_buffer == NULL) {
+           (void) fprintf(stderr,"no space ML_splitup_big_msg: send_buffer \n");
+           exit(-1);
+        }
+   
+        for (n = 0; n < (int) (total_send_size*element_size) ; n++) 
+           send_buffer[n] = ibuffer[n];
+     }
+     else send_buffer = ibuffer;
+     
+     /* post receives for message */
+     
+     j = 0;
+     for (n = 0; n < num_neighbors; n++) {
+        messg_from = proc_num_neighbor[n];
+        dummy_int = type;
+        size      = actual_recv_length[n]*element_size;
+
+        comm->USR_irecvbytes((void *) &obuffer[j], size, &messg_from, 
+                             &dummy_int, comm->USR_comm, request+n);
+        j += actual_recv_length[n]*element_size;
+     }
+
+     /* send messages to each neighbor */
+
+     for (n = 0; n < num_neighbors; n++) {
+        size = actual_send_length[n]*element_size;
+        (void) comm->USR_sendbytes((void *) &send_buffer[start_send_proc[n]*
+                             element_size], size, proc_num_neighbor[n], type, 
+			     comm->USR_comm);
+     }             
+
+     /* wait for all messages */
+
+     j = 0;
+     for (n = 0; n < num_neighbors; n++) {
+        messg_from = proc_num_neighbor[n];
+        rtype     = type;
+        size      = actual_recv_length[n]*element_size;
+        length =  comm->USR_waitbytes((void *) &obuffer[j], size, &messg_from,
+                                      &rtype, comm->USR_comm, request+n); 
+        if ((length != size) && (size !=0) ) {
+           (void) fprintf(stderr, "%sERROR on node %d\nwait failed, message type = %d    %d %d (%d)\n", yo, comm->ML_mypid, 
+                          rtype,length,size,messg_from);
+           exit(-1);
+        }
+        j += length;
+     }
+     *total_num_recv = j/element_size;
+     if (ibuffer == obuffer) {ML_free(send_buffer); send_buffer = NULL;}
+  }
+  ML_free(request);
+  ML_free(start_recv_proc);
+  ML_free(finished_recv_messg);
+  ML_free(finished_send_messg);
+
+} /* ML_splitup_big_msg */
+
+/*************************************************************************/
+/*************************************************************************/
+/*************************************************************************/
+/**************************************************************************
+
+  Routine to perform dot product of r and z with unit stride. This routine call
+  the BLAS routine ddot to do the local vector dot product and then uses the
+  global summation routine ML_gsum_double to obtain the reguired global result.
+
+  Author:          John N. Shadid, SNL, 1421
+  =======
+
+  Return code:     double, dot product of vectors 'r' and 'z'
+  ============
+
+  Parameter list:
+  ===============
+
+  N:               Length of vector 'vec'.
+
+  r, z:            Vectors of length 'N'.
+
+**************************************************************************/
+
+double ML_gdot(int N, double r[], double z[], ML_Comm *comm)
+{
+
+  static int one = 1;
+  int        add_N;
+
+  add_N = N;
+
+  return ML_gsum_double(DDOT_F77(&add_N, r, &one, z, &one), comm);
+
+} /* dot */
+
+/**************************************************************************
+
+  Global double sum.
+
+  Author:
+  =======
+
+  Return code:     double, result of global sum.
+  ============
+
+  Parameter list:
+  ===============
+
+  val:             Individual processor value to be summed.
+
+**************************************************************************/
+
+double ML_gsum_double(double val, ML_Comm *comm)
+{
+#ifdef ML_MPI
+  double val2;          /* arriving value to add */
+  MPI_Allreduce((void *) &val,(void *) &val2, 1, MPI_DOUBLE, MPI_SUM,
+                comm->USR_comm);
+  return val2;
+#else
+  return val;
+#endif
+} /* ML_gsum_double */
+
+/**************************************************************************
+
+  Global double max.
+
+  Author:
+  =======
+
+  Return code:     double, result of global sum.
+  ============
+
+  Parameter list:
+  ===============
+
+  val:             Individual processor value to be summed.
+
+**************************************************************************/
+
+double ML_gmax_double(double val, ML_Comm *comm)
+{
+#ifdef ML_MPI
+  double val2;          /* arriving value to add */
+  MPI_Allreduce((void *) &val,(void *) &val2, 1, MPI_DOUBLE, MPI_MAX,
+                comm->USR_comm);
+  return val2;
+#else
+  return val;
+#endif
+} /* ML_gmax_double */
+
+/*************************************************************************/
+/*************************************************************************/
+/*************************************************************************/
+/**************************************************************************
+
+  Global max of type int.
+
+  Author:
+  =======
+
+  Return code:     int, maximum value across all processors.
+  ============
+
+  Parameter list:
+  ===============
+
+  val:             Individual processor value.
+
+
+**************************************************************************/
+
+int ML_gmax_int(int val, ML_Comm *comm)
+{
+#ifdef ML_MPI
+  int   val2;                     /* arriving value to add */
+  MPI_Allreduce((void *) &val,(void *) &val2, 1, MPI_INT, MPI_MAX,
+                comm->USR_comm);
+  return val2;
+#else
+  return val;
+#endif
+} /* ML_gmax_int */
+
+/*************************************************************************/
+/*************************************************************************/
+/*************************************************************************/
+/**************************************************************************
+
+  Find 'key' in 'list' and return the index number.
+
+  Author:          Ray Tuminaro, SNL, 1422
+  =======
+
+  Return code:     int, -1 = key not found, i = list[i] = key
+  ============
+
+  Parameter list:
+  ===============
+
+  key:             Element to be search for in list.
+
+  list:            List to be searched.
+
+  length:          Length of list.
+
+**************************************************************************/
+
+int ML_find_index(int key, int list[], int length)
+{
+
+  /* local variables */
+
+  int start, end;
+  int mid;
+
+  /*********************** execution begins ******************************/
+  if (length == 0) return -1;
+
+  start = 0;
+  end   = length - 1;
+
+  while (end - start > 1) {
+    mid = (start + end) / 2;
+    if (list[mid] < key) start = mid;
+    else end = mid;
+  }
+
+  if (list[start] == key) return start;
+  if (list[end] == key)   return end;
+  return -1;
+
+} /* ML_find_index */
+
+/******************************************************************************/
+
+
+int ML_get_random_seed(){
+/*******************************************************************************
+
+  Returns the random seed
+
+  Author:          Chris Siefert
+  =======
+*******************************************************************************/
+
+
+  return ml_random_seed;
+}
+
+
+void ML_set_random_seed(int seed){
+/*******************************************************************************
+
+  Sets the random seed for the ML
+
+  Author:          Chris Siefert
+  =======
+
+  Parameter list:
+  ===============
+
+  seed:            New seed to use
+*******************************************************************************/
+
+  ml_random_seed=seed;
+  ml_random_start=0;
+}
+
+
+
+void ML_random_vec(double u[], int N, ML_Comm *comm) 
+
+/*******************************************************************************
+
+  Set u to a random vector.
+
+  Author:          Ray Tuminaro
+  =======
+
+  Parameter list:
+  ===============
+
+  u:               On output, vector is initialized to random numbers.
+
+  N:               On input, length of 'u'.
+
+*******************************************************************************/
+{
+
+  /* local variables */
+  int        i;
+  int maxint = 2147483647; /* 2^31 -1 */
+
+  /*********************** BEGIN EXECUTION *********************************/
+
+  /* Distribute the seeds evenly in [1,maxint-1].  This guarantees nothing
+   * about where in random number stream we are, but avoids overflow situations
+   * in parallel when multiplying by a PID.  It would be better to use
+   * a good parallel random number generator. */
+
+  if (ml_random_start) {
+    ml_random_seed = (int)((maxint-1) * (1.0 -(comm->ML_mypid+1)/(comm->ML_nprocs+1.0)) );
+    ml_random_start = 0;
+  }
+  if (ml_random_seed < 1 || ml_random_seed == maxint)
+    pr_error("ML*ERR* Problem detected in ML_random_vec with seed = %d.\nML*ERR* It should be in the interval [1,2^31-2].\n",ml_random_seed);
+
+  for (i = 0; i < N; i++) u[i] = ML_srandom1(&ml_random_seed);
+
+} /* ML_random_vec */
+
+/******************************************************************************/
+double ML_srandom1(int *seed)
+
+/*******************************************************************************
+  Random number generator.
+  From Park, S. K. and Miller, K. W. 1988. "Random number generators: good ones
+  are hard to find." Commun. ACM 31, 10 (Oct. 1988), 1192-1201.
+
+  Parameter list:
+  ===============
+  seed:            Random number seed.
+
+  Return value:
+  ===============
+  scalar double in interval (0,1)
+
+*******************************************************************************/
+{
+  int    a = 16807, m = 2147483647, q = 127773, r = 2836;
+  int    lo, hi, test;
+  double rand_num;
+
+  /**************************** execution begins ******************************/
+
+  hi   = *seed / q;
+  lo   = *seed % q;
+  test = a * lo - r * hi;
+
+  if (test > 0) *seed = test;
+  else *seed = test + m;
+
+  rand_num = (double) *seed / (double) m;
+  return rand_num;
+
+} /* ML_srandom1 */
+
+
+/* Essentially, like printf , but we exit at the end */
+#include <stdarg.h>
+void pr_error(const char *fmt,  ... ) 
+{
+  char ml_message_string[800];
+  va_list ap;
+  va_start(ap, fmt);
+  vsprintf(ml_message_string,fmt, ap);
+  /*
+  char *p;
+  int  ival;
+  double dval;
+
+  va_start(ap, fmt);
+  for (p = fmt; *p; p++) {
+     if (*p != '%') { putchar(*p); continue; }
+     switch (*++p) {
+     case 'd':
+        ival = va_arg(ap, int);
+        printf("%d",ival);
+        break;
+     case 'e':
+        dval = va_arg(ap,double);
+        printf("%e",dval);
+        break;
+     default:
+        putchar(*p);
+        break;
+     }
+  }
+  */
+  va_end(ap);
+  fprintf(stderr,"\n%sn",ml_message_string);
+# ifdef ML_MPI
+  MPI_Abort(MPI_COMM_WORLD,1);
+# endif
+  exit(EXIT_FAILURE);
+}
+
+#define SERIAL_TYPE 790331
+void ML_serial_start(ML_Comm *comm)
+{
+   int data = 0, type = SERIAL_TYPE, neighbor;
+   USR_REQ   request;
+
+   if (comm->ML_mypid != 0) {
+       neighbor = comm->ML_mypid-1;
+       comm->USR_irecvbytes((void *) &data, sizeof(int), &neighbor, &type,
+                comm->USR_comm, &request);
+       comm->USR_cheapwaitbytes((void *) &data, sizeof(int), &neighbor, &type,
+                        comm->USR_comm, &request);
+   }
+}
+void ML_serial_end(ML_Comm *comm) 
+{
+   int data = 0, type = SERIAL_TYPE, neighbor;
+
+   neighbor = comm->ML_mypid + 1;
+   if (neighbor != comm->ML_nprocs) {
+      comm->USR_sendbytes((void *) &data, sizeof(int), neighbor, type,
+                          comm->USR_comm);
+   }
+}
+
+/* ******************************************************************** */
+/* Routine that pauses execution, prints out process id's, and allows   */
+/* the developer to attach a debugger if desired.                       */
+/* (Based on code from ALEGRA).                                         */
+/* ******************************************************************** */
+#ifndef ICL
+#include <unistd.h>
+#endif
+void ML_BreakForDebugger(ML_Comm *comm)
+{
+  int i,j;
+  int mypid = comm->ML_mypid;
+  int nproc = comm->ML_nprocs;
+  char buf[80];
+  char hostname[80];
+  char go = ' ';
+  char *str;
+  FILE * ML_capture_flag;
+
+  str = (char *) getenv("ML_BREAK_FOR_DEBUGGER");
+  i = 0;
+  if (str != NULL) i++;
+
+  ML_capture_flag = fopen("ML_debug_now","r");
+  if(ML_capture_flag) {
+    i++;
+    fclose(ML_capture_flag);
+  }
+
+  ML_gsum_scalar_int(&i, &j, comm);
+  if (i != 0)
+  {
+    if (mypid == 0) printf("Host and Process Ids for tasks\n");
+    for (i = 0; i < nproc; i++) {
+      if (i == mypid) {
+#if defined(TFLOP) || defined(JANUS_STLPORT) || defined(COUGAR)
+        sprintf(buf, "Host: %s   PID: %d", "janus", getpid());
+#else
+        gethostname(hostname, sizeof(hostname));
+        sprintf(buf, "Host: %s   PID: %d (mpi task %d)", hostname, getpid(),mypid);
+#endif
+        printf("%s\n",buf);
+        fflush(stdout);
+#ifdef ICL
+        Sleep(1);
+#else
+        sleep(1);
+#endif
+      }
+    }
+    if(mypid == 0) {
+      printf("\n");
+      printf("** Pausing because environment variable ML_BREAK_FOR_DEBUGGER\n");
+      printf("** has been set, or file ML_debug_now exists.\n");
+      printf("**\n");
+      printf("** You may now attach debugger to the processes listed above.\n");
+      printf( "**\n");
+      printf( "** Enter a character to continue > "); fflush(stdout);
+	  scanf("%c",&go);
+    }
+  }
+}
+
+/* Function to sync up processors and execute one line at a time. */
+                                                                                
+void ML_Pause(ML_Comm *comm)
+{
+  char go = ' ';
+
+  ML_Comm_Barrier(comm);
+                                                                                
+  if (comm->ML_mypid == 0) {
+      printf( "** Press enter to continue > "); fflush(stdout);
+      scanf("%c",&go);
+  }
+  ML_Comm_Barrier(comm);
+}
+
+
+void ML_use_param(void *data, int junk)
+{
+  if ( (junk == -365) && (data == NULL)) printf("ML_avoid_unused_param\n");
+}
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*****************************************************************************/
+
+void ML_print_line (const char *charstr, int ntimes)
+
+{
+  int i;
+  for (i = 0; i < ntimes; i++) printf("%c", *charstr);
+  printf("\n");
+}
+
+/*MS*/
+int ML_gsum_int(int val, ML_Comm *comm)
+{
+
+  int i;
+  ML_gsum_scalar_int(&val, &i,comm);
+  return val;
+}
+
+int ML_gmin_int(int val, ML_Comm *comm)
+{
+  int min;
+#ifdef HAVE_MPI
+  MPI_Allreduce(&val, &min, 1, MPI_INT, MPI_MIN, comm->USR_comm );
+#else
+  min = val;
+#endif
+  return min;
+}
+
+double ML_gmin_double(double val, ML_Comm *comm)
+{
+  double min;
+#ifdef HAVE_MPI
+  MPI_Allreduce(&val, &min, 1, MPI_DOUBLE, MPI_MIN, comm->USR_comm );
+#else
+  min = val;
+#endif
+  return min;
+}
+
+#include "ml_operator.h"
+
+/* ******************************************************************** */
+/* print a ML_Operator into MATLAB format. Only one file is generated   */
+/* using global ordering.                                               */
+/*                                                                      */
+/* Parameter list:                                                      */
+/* matrix :             ML_Operator, distributed among processes.       *
+ *                      The matrix may be square or rectangular.        *
+ *                                                                      *
+ * label :              matrix will be written in MATLAB (i,j,k) format *
+ *                      to file "label.m". Note that only ONE file will *
+ *                      be created that contains the ENTIRE operator.   *
+ *                                                                      *
+ * global_row_ordering: optional global row numbering.                  *
+ * global_col_ordering: optional global column numbering.               *
+ *                      If either of these are null, they will be cal-  *
+ *                      culated in this function.                       *
+ *                                                                      */
+/* Albuquerque, 30-Oct-03                                               */
+/* ******************************************************************** */
+
+int ML_Operator_Print_UsingGlobalOrdering( ML_Operator *matrix, 
+                                           const char label[],
+                                           int *global_row_ordering,
+                                           int *global_col_ordering)
+{
+
+   int    i, j, iproc;
+   int    *bindx;
+   int    MyPID, NumProc;
+   double *val;
+   int    allocated, row_length;
+   char   filename[80];
+   FILE   *fid;
+   int    Nrows, NglobalRows, NglobalCols=0;
+   int    is_globalRows_allocated = 0;
+   int    is_globalCols_allocated = 0;
+   int    length=0;
+   ML_Comm * comm = matrix->comm;
+   
+   NglobalRows = matrix->outvec_leng;
+   ML_gsum_scalar_int(&NglobalRows,&i, comm);
+   NglobalCols = matrix->invec_leng;
+   ML_gsum_scalar_int(&NglobalCols,&i, comm);
+
+   if( global_row_ordering == NULL ) {
+     length = ML_build_global_numbering(matrix, &global_row_ordering,"rows");
+     is_globalRows_allocated = 1;
+   }
+
+   if( global_col_ordering == NULL ) {
+     if (NglobalRows == NglobalCols)
+       global_col_ordering = global_row_ordering; 
+     else {
+       length = ML_build_global_numbering(matrix, &global_col_ordering,"cols");
+       is_globalCols_allocated = 1;
+     }
+   }
+ 
+   if ( matrix->getrow == NULL) return(1);
+
+   MyPID = comm->ML_mypid;
+   NumProc = comm->ML_nprocs;
+
+   allocated = matrix->max_nz_per_row;
+   bindx = (int    *)  ML_allocate( allocated*sizeof(int   ));
+   val   = (double *)  ML_allocate( allocated*sizeof(double));
+
+   Nrows = matrix->outvec_leng;
+
+   if( label != NULL ) {
+     sprintf( filename, "%s.m", label );
+     if( MyPID == 0 ) printf("Writing matrix to file %s...\n",filename);
+   } else {
+     if( MyPID == 0 ) printf("Writing matrix to stdout...\n");
+   }
+
+   for ( iproc=0 ; iproc<NumProc ; iproc++ ) {
+
+     if ( MyPID == iproc )
+     {
+       if( label != NULL ) {
+         if( MyPID == 0 ) fid = fopen(filename,"w");
+         else             fid = fopen(filename,"a");
+       } else {
+         fid = stdout;
+       }
+ 
+       if( MyPID == 0 ) {
+         fprintf(fid,"%%N_global_rows = %d\n", NglobalRows );
+         fprintf(fid,"%%N_global_cols = %d\n", NglobalCols );
+         fprintf(fid,"%%Number of processors = %d\n", NumProc );
+         fprintf(fid,"%% To load this data into Matlab:\n");
+         fprintf(fid,"%%    load(filename); A = spconvert(filename);\n");
+         fprintf(fid,"%% This ordering may be different than the application's matrix ordering!\n\n");
+         fprintf(fid,"%% NOTE: If there are no entries in column %d or row %d,\n",NglobalCols,NglobalRows);
+         fprintf(fid,"%% Matlab may get the matrix dimensions wrong.\n");
+       }
+       
+       fprintf( fid,
+		"%%Writing data for processor %d\n%%N_rows = %d\n%%outvec_leng = %d\n%%invec_leng = %d\n",
+		iproc,
+		Nrows,
+        matrix->outvec_leng,
+        matrix->invec_leng );
+       fprintf(fid,"%%\n");
+       for (i=0; i<length;i++)
+         fprintf(fid,"%%global_row_ordering[%d] = %d\n",i,global_row_ordering[i]);
+       fprintf(fid,"%%\n");
+
+       for (i = 0 ; i < Nrows; i++) {
+         ML_get_matrix_row(matrix, 1, &i, &allocated, &bindx, &val,
+                 &row_length, 0);
+         for  (j = 0; j < row_length; j++)
+           fprintf(fid,"%d  %d  %20.13e\n",
+                   global_row_ordering[i]+1,
+                   global_col_ordering[bindx[j]]+1,
+                   val[j]);
+       }
+       if( label != NULL ) fclose(fid);
+     } /*if ( MyPID == iproc ) */
+#ifdef ML_MPI
+     ML_Comm_Barrier( matrix->comm);
+#endif
+   } /*for ( iproc=0 ; iproc<NumProc ; iproc++ ) */
+
+   /* free memory and return */
+   
+   fflush(stdout);
+   ML_free(val);
+   ML_free(bindx);
+
+   if( is_globalRows_allocated == 1 ) ML_free( global_row_ordering );
+   if( is_globalCols_allocated == 1 ) ML_free( global_col_ordering );
+
+   return 0;
+}
+
+/* ******************************************************************** *
+ * Create global numbering for a ML_Operator. I suppose that ML uses a  *
+ * linear decomposition among the processes (that is, proc 0 is assigned*
+ * the first Nrows elements, and so on). This is enough to define the   *
+ * global numbering of local nodes. For the ghost nodes (columns), I use*
+ * ML_exchange_bdry.                                                    *
+ *
+ * This now supports global numbering for either rows or columns, which *
+ * may be of interest for rectangular matrices.  If the 3rd input arg   *
+ * is either "columns" or "cols", global column numbers are found.      *
+ * Otherwise, global row numbers are found.                             *
+ *                                                                      *
+ * Albuquerque, 30-Oct-03                                               *
+ * ******************************************************************** */
+
+int ML_build_global_numbering( ML_Operator *Amat,
+			       int **pglobal_numbering,
+                   const char *rowsOrCols )
+{
+
+  int    i;
+  int    Nloc, Nghosts, offset;
+  double * dtemp = NULL;
+  int * global_numbering;
+  ML_Comm *comm = Amat->comm;
+  int NglobalRows, NglobalCols;
+  int findingRows;
+
+  NglobalRows = Amat->outvec_leng;
+  ML_gsum_scalar_int(&NglobalRows,&i, comm);
+  NglobalCols = Amat->invec_leng;
+  ML_gsum_scalar_int(&NglobalCols,&i, comm);
+  
+  if (strcmp(rowsOrCols,"cols") == 0 ||  strcmp(rowsOrCols,"columns") == 0) {
+    Nloc = Amat->invec_leng;
+    findingRows = 0;
+  }
+  else {
+    Nloc = Amat->outvec_leng;
+    findingRows = 1;
+  }
+
+  if (findingRows && NglobalRows != NglobalCols) {
+#ifdef ML_MPI
+    MPI_Scan ( &Nloc, &offset, 1, MPI_INT, MPI_SUM,
+	       Amat->comm->USR_comm );
+    offset -= Nloc;
+#else
+    offset = 0;
+#endif
+    global_numbering = (int *)ML_allocate(sizeof(int)*(Nloc+1));
+    for (i=0; i<Nloc; i++) global_numbering[i] = i+offset;
+    *pglobal_numbering = global_numbering;
+    return Nloc;
+  }
+
+  if (Amat->getrow->pre_comm == NULL) Nghosts = 0;
+  else {
+    if (Amat->getrow->pre_comm->total_rcv_length <= 0)
+      ML_CommInfoOP_Compute_TotalRcvLength(Amat->getrow->pre_comm);
+    Nghosts = Amat->getrow->pre_comm->total_rcv_length;
+  }
+  
+  /* allocate +1 because it is possible that some procs will have
+     no rows at all (with ParMETIS) */
+
+  dtemp = (double *) ML_allocate( sizeof(double) * (Nloc+Nghosts+1));
+  if( dtemp == NULL )
+    pr_error("*ML*ERR* not enough memory to allocated %d bytes\n*ML*ERR* (file %s, line %d)\n",
+	     (Nloc+Nghosts) * (int)sizeof(double),
+	     __FILE__,
+	     __LINE__ );
+
+#ifdef ML_MPI
+  MPI_Scan ( &Nloc, &offset, 1, MPI_INT, MPI_SUM,
+	     Amat->comm->USR_comm );
+  offset -= Nloc;
+#else
+  offset = 0;
+#endif
+
+  /* global numbering for local nodes. Note that ML always
+     supposes to have contiguous local nodes (that is, the
+     global set of nodes has been subdivided into contiguous
+     chunks). This may not be true for the first level
+     (ML uses an order which is not the physical one). So, don't
+     be surprised that a tridiagonal matrix (before AZ_transform)
+     is no longer tridiagonal, for instance... */
+    
+  for( i=0 ; i<Nloc ; i++ ) dtemp[i] = 1.0*(i+offset);
+  for (i=0 ; i<Nghosts; i++) dtemp[i+Nloc] = -1;
+
+  /* I exchange this information using ML_exchange_bdry,
+     which is coded for double vectors. */
+
+  ML_exchange_bdry(dtemp,Amat->getrow->pre_comm, Nloc,
+		   comm, ML_OVERWRITE,NULL);
+
+  /* allocates memory for global_ordering (+1 as before) */
+  
+  global_numbering = (int *)ML_allocate(sizeof(int)*(Nloc+Nghosts+1));
+       
+  if( global_numbering == NULL )
+    pr_error("*ML*ERR* not enough memory to allocated %d bytes\n*ML*ERR* (file %s, line %d)\n",
+	     (Nloc+Nghosts) * (int)sizeof(int),
+	     __FILE__,
+	     __LINE__ );
+
+  /* put the received double vectors in the integer vector */
+
+  for( i=0 ; i<Nloc+Nghosts ; i++ )
+    global_numbering[i] = (int)dtemp[i];
+
+  *pglobal_numbering = global_numbering;
+  
+  ML_free( dtemp ); dtemp = NULL;
+
+  return Nloc+Nghosts;
+    
+} /* ML_build_global_numbering() */
+
+/*******************************************************************************
+ * ML_Operator_Lump is intended to create a lumped matrix, e.g., a lumped
+ * mass matrix.   It does the obvious thing. Let v = [1,1,...1]' and
+ * d = A*v.  Then A'=diag(d) is the lumped version of A.
+ *
+ * To create the lumped matrix, I do a half clone, then populate the getrow,
+ * matvec, and data fields of the new matrix.
+ *
+ * This works in serial, but hasn't been tested in parallel.
+ *
+ * JJH, 3/5/2004
+ ******************************************************************************/
+
+int ML_Operator_Lump(ML_Operator *A, ML_Operator **B)
+{
+  double *vin,*vout;
+  int mm,nn,i;
+  struct ML_CSR_MSRdata *csr_data;
+
+  mm = A->invec_leng;
+  nn = A->outvec_leng;
+  vin = (double *) ML_allocate(mm * sizeof(double) );
+  vout = (double *) ML_allocate((nn+1) * sizeof(double) );
+  for (i=0;i<mm;i++) vin[i] = 1.0;
+  ML_Operator_Apply(A,mm,vin,nn,vout);
+
+  *B = ML_Operator_halfClone(A);
+  (*B)->halfclone = ML_FALSE;
+  (*B)->N_nonzeros = nn;
+  ML_Operator_Set_Getrow(*B, nn, MSR_getrows);
+
+  csr_data = (struct ML_CSR_MSRdata *)
+               ML_allocate(sizeof(struct ML_CSR_MSRdata));
+
+  csr_data->rowptr = NULL;
+  csr_data->values = vout;
+  csr_data->columns = (int *) ML_allocate((nn+1) * sizeof(int));
+  for (i=0; i<nn+1; i++) csr_data->columns[i] = nn+1;
+
+  ML_Operator_Set_ApplyFuncData( *B, mm, nn,
+                  csr_data, nn, MSR_matvec, 0);
+
+  ML_free(vin);
+  return 0;
+}
+
+/*******************************************************************************
+ Calculate standard deviation based on the formula
+
+        sigma = ( 1 / (n-1) * sum( (a_i - a)^2 ) )^(0.5)
+
+ where a_i are the samples & a is the average of the a_i's.
+
+     sample     -- value to be analyzed
+     n          -- number of samples
+     activeflag -- nonzero if this processor is participating
+     comm       -- ML communicator
+
+ Note: there are more efficient formulas to calculate this.
+*******************************************************************************/
+
+
+double ML_Global_Standard_Deviation(double sample, int n,
+                                    int activeflag, ML_Comm *comm)
+{
+  double avg = 0.0;
+  double sum = 0.0;;
+
+  if (n <= 0) return -999.0;
+  if (n == 1) return 0.0;
+
+/*  printf("(%d) sample = %e, n = %d active = %d\n",comm->ML_mypid, sample, n,
+   activeflag);*/
+  if (activeflag == 0)
+     sample = 0.0;
+  avg = ML_gsum_double(sample, comm) / n;
+  /* printf("(%d) avg = %e\n",comm->ML_mypid, avg); */
+  if (activeflag)
+    sample -= avg;
+
+  sample = sample*sample;
+  sum = ML_gsum_double(sample, comm);
+ 
+  return sqrt(sum / (n-1));
+}
+
+/* ************************************************************************ * */
+
+int ML_SetupCoordinates(ML *ml_ptr, int level, int NumPDEEqns,
+                        double *in_x_coord, double *in_y_coord,
+                        double *in_z_coord)
+{
+  int    NumDimensions, n, i, Nghost;
+  double *x_coord, *y_coord, *z_coord, *tmp;
+  ML_Operator* AAA;
+  ML_Aggregate_Viz_Stats *grid_info;
+  
+  NumDimensions  = 0;
+
+  if (!(in_x_coord == 0 && in_y_coord == 0 && in_z_coord == 0))
+  {
+    grid_info = (ML_Aggregate_Viz_Stats *) ml_ptr->Grid[level].Grid;
+    AAA = &(ml_ptr->Amat[level]);
+
+    n = AAA->invec_leng;
+    Nghost = 0;
+
+    if (AAA->getrow->pre_comm) 
+    {
+      if (AAA->getrow->pre_comm->total_rcv_length <= 0)
+        ML_CommInfoOP_Compute_TotalRcvLength(AAA->getrow->pre_comm);
+      Nghost = AAA->getrow->pre_comm->total_rcv_length;
+    }
+
+    tmp = (double *) ML_allocate(sizeof(double) * (Nghost+n));
+    for (i = 0 ; i < Nghost + n ; ++i)
+      tmp[i] = 0.0;
+
+    n /= NumPDEEqns;
+    Nghost /= NumPDEEqns;
+
+    if (in_x_coord) 
+    {
+      NumDimensions++;
+      x_coord = (double *) ML_allocate(sizeof(double) * (Nghost+n));
+
+      for (i = 0 ; i < n ; ++i)
+        tmp[i * NumPDEEqns] = in_x_coord[i];
+
+      ML_exchange_bdry(&tmp[0],AAA->getrow->pre_comm, NumPDEEqns * n, 
+                       AAA->comm, ML_OVERWRITE,NULL);
+
+      for (i = 0 ; i < n + Nghost ; ++i)
+        x_coord[i] = tmp[i * NumPDEEqns];
+
+      grid_info->x = x_coord;
+    } /* if (in_x_coord) */
+
+    if (in_y_coord) 
+    {
+      NumDimensions++;
+      y_coord = (double *) ML_allocate(sizeof(double) * (Nghost+n));
+
+      for (i = 0 ; i < n ; ++i)
+        tmp[i * NumPDEEqns] = in_y_coord[i];
+
+      ML_exchange_bdry(&tmp[0],AAA->getrow->pre_comm, NumPDEEqns * n, 
+                       AAA->comm, ML_OVERWRITE,NULL);
+
+      for (i = 0 ; i < n + Nghost ; ++i)
+        y_coord[i] = tmp[i * NumPDEEqns];
+
+      grid_info->y = y_coord;
+    } /* if (in_y_coord) */
+
+    if (in_z_coord) 
+    {
+      NumDimensions++;
+      z_coord = (double *) ML_allocate(sizeof(double) * (Nghost+n));
+
+      for (i = 0 ; i < n ; ++i)
+        tmp[i * NumPDEEqns] = in_z_coord[i];
+
+      ML_exchange_bdry(&tmp[0],AAA->getrow->pre_comm, NumPDEEqns * n, 
+                       AAA->comm, ML_OVERWRITE,NULL);
+
+      for (i = 0 ; i < n + Nghost ; ++i)
+        z_coord[i] = tmp[i * NumPDEEqns];
+
+      grid_info->z = z_coord;
+    } /* if (in_z_coord) */
+
+    grid_info->Ndim = NumDimensions;
+    ML_free(tmp);
+
+  } /* if (!(in_x_coord == 0 && in_y_coord == 0 && in_z_coord == 0)) */
+
+  return(0);
+} /* ML_SetupCoordinates() */
+
+/* ************************************************************************ * */
+
+int ML_hash_init(int hash_list[], int hash_length, int *hash_used)
+{
+  int i;
+
+  for (i = 0; i < hash_length; i++) hash_list[i] = -1;
+  *hash_used = 0;
+  return 0;
+}
+
+/* ************************************************************************ * */
+
+#ifndef ML_UseInlinedHashFunction
+void ML_hash_it( int new_val, int hash_list[], int hash_length,int *hash_used,
+                 int *index)
+{
+  int ui;
+
+  ui = new_val<<1;
+  if (ui < 0) ui = new_val;
+  *index = ui % hash_length;
+  while ( hash_list[*index] != new_val) {
+    if (hash_list[*index] == -1) { (*hash_used)++; break;}
+    (*index)++;
+    *index = (*index) % hash_length;
+  }
+}
+
+/* ************************************************************************ * */
+/*
+   Important: If you want to use ML_fast_hash, the table size must be 2^k for
+   a positive integer k.
+*/
+
+void ML_fast_hash(int new_val, int hash_list[], int hlm1,int *hash_used,
+                  int *index)
+{
+
+  uint32_t ui;
+
+  ui = new_val;
+  ml_hash_function(ui);
+  /* fast mod because hash_length = 2^k */
+  *index = ((int) ui) & hlm1;
+
+  while ( hash_list[*index] != new_val) {
+    if (hash_list[*index] == -1) { (*hash_used)++; break;}
+    (*index)++;
+    *index = (*index) & hlm1;
+  }
+}
+#endif /*ifndef ML_UseInlinedHashFunction*/
+
+/* ************************************************************************* */
+/*
+  Takes an integer as input, and returns a character array containing a space that
+  is the same print length (i.e., the same number of characters on the screen.)
+  For example, '-12345' would return '      ' (6 spaces).  Useful for aligning
+  prints.
+*/
+void ML_print_align(int int2match, char *space, int pad)
+{
+  int jj;
+  double dtemp;
+  if (int2match < 0) pad++;
+  dtemp=fabs((double)int2match);
+  for (jj=0; jj<pad; jj++) space[jj]=' ';
+  jj=pad;
+  while (dtemp>=1) {space[jj++]=' '; dtemp /= 10;}
+  if (int2match == 0) space[jj++]=' ';
+  space[jj] = '\0';
+}
+
+
+/* ************************************************************************* */
+/* Estimates the average NNZ per row in a matrix, using the rowptr if we can */
+/* and probing a few rows if that isn't an option.  Does not consider        */
+/* submatrices, which is why this is a static function.  This should only be */
+/* called by ML_estimate_avg_nz_per_row.                                     */
+/* ************************************************************************* */
+static int ML_estimate_avg_nz_per_row_nosubmatrix(ML_Operator * matrix, double * total_nz, int * total_rows) {
+  int N,*rowptr, *bindx;
+  double * values;
+  struct ML_CSR_MSRdata * ptr;
+  int rv=-1;
+  int first_row=0, last_row=matrix->getrow->Nrows;
+  if(matrix->sub_matrix) first_row=matrix->sub_matrix->getrow->Nrows;
+  N=last_row-first_row;
+  (*total_rows)=N;
+  (*total_nz)=0;
+  if(N==0) return 0;
+
+  if (matrix->getrow->func_ptr == CSR_getrow){
+    /* Case #1: CSR Matrix */
+    ptr   = (struct ML_CSR_MSRdata *) matrix->data;
+    (*total_nz) = ptr->rowptr[N]-ptr->rowptr[0];
+    rv=0;
+  }
+  else if (matrix->getrow->func_ptr == MSR_getrows) {
+    /* Case #2: MSR Matrix */
+    ptr   = (struct ML_CSR_MSRdata *) matrix->data;
+    (*total_nz) = N + ptr->columns[N]-ptr->columns[0];
+    rv=0;
+  }
+#ifdef ML_WITH_EPETRA
+  else if (matrix->getrow->func_ptr == ML_Epetra_CrsMatrix_getrow) {
+    /* Case #3: EpetraCrsMatrix */
+    rv=Epetra_ML_GetCrsDataptrs(matrix,&values,&bindx,&rowptr);
+    if(rv == 0) 
+      (*total_nz) = N + rowptr[N]-rowptr[0];
+  }
+#endif
+
+  return rv;
+}
+
+/* ************************************************************************* */
+/* Estimates the average NNZ per row in a matrix, using the rowptr if we can */
+/* and probing a few rows if that isn't an option                            */
+/* ************************************************************************* */
+int ML_estimate_avg_nz_per_row(ML_Operator * matrix, double * avg_nz) {
+  ML_Operator *next;
+  int rv=0,sub_rows=0, total_rows=0;
+  double sub_nz=0.0,total_nz=0.0;
+  int row, allocated, i,j,k;
+  int *cols;
+  double *vals;
+  (*avg_nz)=0.0;
+
+
+  /* Sanity Check & Get Num Rows*/
+  if(!matrix->getrow) {
+    printf("[%4d] CMS: matrix has no getrow.\n",matrix->comm->ML_mypid);
+    return -1;
+  }
+
+  /* Count the parent matrix */
+  rv=ML_estimate_avg_nz_per_row_nosubmatrix(matrix,&sub_nz,&sub_rows);
+  total_rows += sub_rows;
+  total_nz   += sub_nz;    
+  
+  /* Loop through all the submatrices, if any */
+  next = matrix->sub_matrix;
+  while ( rv==0 && (next != NULL) ) {
+    rv=ML_estimate_avg_nz_per_row_nosubmatrix(next,&sub_nz,&sub_rows);
+
+    /* Short circuit if some submatrix failed */
+    if(rv!=0) break;
+
+    /* Running statistics */
+    total_rows+= sub_rows;
+    total_nz  += sub_nz;    
+    next       = next->sub_matrix;
+  }
+
+  if(rv) {
+    /* If any of the getrows failed, we just default to ML_get_matrix_row on the whole thing */
+    allocated = matrix->max_nz_per_row + 1;
+    cols  = (int    *) ML_allocate(allocated * sizeof(int) );
+    vals  = (double *) ML_allocate(allocated * sizeof(double));
+
+    row = 0; 
+    ML_get_matrix_row(matrix,1,&row,&allocated, &cols, &vals, &i, 0);
+    row = (matrix->getrow->Nrows-1)/2;
+    ML_get_matrix_row(matrix,1,&row,&allocated, &cols, &vals, &j, 0);
+    row = matrix->getrow->Nrows-1;
+    ML_get_matrix_row(matrix,1,&row,&allocated, &cols, &vals, &k, 0);
+    (*avg_nz) = ((double)i+j+k)/3.0;
+
+    /* Sanity checking in case one row is really, really different from the other two.
+       This is an attempt to avoid allocated an absurd amount of memory for the MMM if 
+       the problem has one really long row.  Rows of length 1 don't count for this purpose. */
+    if(i > 1 && j > 1 && (*avg_nz) > 10*(i+j))  (*avg_nz) = ((double)i+j)/2.0;
+    if(j > 1 && k > 1 && (*avg_nz) > 10*(j+k))  (*avg_nz) = ((double)j+k)/2.0;
+    if(i > 1 && k > 1 && (*avg_nz) > 10*(i+k))  (*avg_nz) = ((double)i+k)/2.0;
+
+    ML_free(cols);
+    ML_free(vals);
+  }
+  else{
+    /* All of the parent/submatrix getrows worked, so calculate the nz that way.*/
+    if (total_rows>0) 
+      (*avg_nz)= total_nz / total_rows;
+  }
+  return 0;
+}
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.c.rej trilinos-11.4.3/packages/ml/src/Utils/ml_utils.c.rej
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.c.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_utils.c.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,19 @@
+--- packages/ml/src/Utils/ml_utils.c	2013-11-04 12:27:11.000000000 -0700
++++ packages/ml/src/Utils/ml_utils.c	2014-01-09 21:23:38.851746600 -0700
+@@ -1935,13 +1935,15 @@
+       if (i == mypid) {
+ #if defined(TFLOP) || defined(JANUS_STLPORT) || defined(COUGAR)
+         sprintf(buf, "Host: %s   PID: %d", "janus", getpid());
++#elif defined(__MINGW32__)
++        sprintf(buf, "Host: %s   PID: %d", "mingw", getpid());
+ #else
+         gethostname(hostname, sizeof(hostname));
+         sprintf(buf, "Host: %s   PID: %d (mpi task %d)", hostname, getpid(),mypid);
+ #endif
+         printf("%s\n",buf);
+         fflush(stdout);
+-#ifdef ICL
++#if defined(ICL) || defined(__MINGW32__)
+         Sleep(1);
+ #else
+         sleep(1);
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.h.orig trilinos-11.4.3/packages/ml/src/Utils/ml_utils.h.orig
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_utils.h.orig	2013-11-21 13:12:26.000000000 -0700
@@ -0,0 +1,250 @@
+/* ******************************************************************** */
+/* See the file COPYRIGHT for a complete copyright notice, contact      */
+/* person and disclaimer.                                               */        
+/* ******************************************************************** */
+
+/* ******************************************************************** */
+/* Miscellaneous functions for efficient searching and sorting          */
+/* ******************************************************************** */
+/* Author        : Charles Tong (LLNL) and Raymond Tuminaro (SNL)       */
+/* Date          : September, 1998                                      */
+/* ******************************************************************** */
+
+#ifndef __MLUTILH__
+#define __MLUTILH__
+
+#ifndef __cplusplus
+#if defined(ICL) || defined(_MSC_VER)
+#include <time.h>
+#else
+#include <sys/time.h>
+#endif
+#endif
+
+#ifndef ICL
+#ifndef _WIN32
+#include <unistd.h>
+#endif
+#endif
+
+/*#include "ml_struct.h"*/
+#include "ml_config.h"
+#include "ml_common.h"
+#include "ml_defs.h"
+#include "ml_comm.h"
+#include "ml_operator.h"
+
+#define ML_dabs(x) (((x) > 0.) ? x : (-(x)))
+#define ML_abs(x) (((x) > 0) ? x : (-(x)))
+#define ML_min(a,b) (((a) <= (b)) ? (a) : (b))
+#define ML_max(x,y) (((x) > (y)) ? (x) : (y))
+#define ML_avoid_unused_param(x) ML_use_param(x,0)
+
+/* A fast integer hash function written by Bob Jenkins. */
+#define ml_hash_function(a) \
+{ \
+  a = (a+0x7ed55d16) + (a<<12); \
+  a = (a^0xc761c23c) ^ (a>>19); \
+  a = (a+0x165667b1) + (a<<5); \
+  a = (a+0xd3a2646c) ^ (a<<9); \
+  a = (a+0xfd7046c5) + (a<<3); \
+  a = (a^0xb55a4f09) ^ (a>>16); \
+}
+
+#define ML_UseInlinedHashFunction
+
+#ifdef ML_UseInlinedHashFunction
+/* work around for compiling on qt (ax_create_stdint_h.m4 didn't work) */
+#ifdef _MSC_VER
+typedef __int32 int32_t;
+typedef unsigned __int32 uint32_t;
+typedef __int64 int64_t;
+typedef unsigned __int64 uint64_t;
+#endif
+
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+typedef unsigned int uint32_t;
+#endif
+
+extern uint32_t ml_unew_val;
+/* Important: If you want to use ML_fast_hash, the table size must be 2^k for a
+   positive integer k. */
+#define ML_fast_hash(new_val, hash_table, hlm1, used, hash_index) \
+{ \
+  ml_unew_val = new_val; \
+  ml_hash_function(ml_unew_val); \
+  *hash_index = ((int) ml_unew_val) & hlm1; \
+  while ( hash_table[*hash_index] != new_val) { \
+    if (hash_table[*hash_index] == -1) { (*used)++; break;} \
+    (*hash_index)++; \
+    *hash_index = (*hash_index) & hlm1; \
+  } \
+}
+
+#define ML_hash_it(new_val,hash_table,hash_length,used, hash_index) \
+{ \
+  *hash_index = new_val<<1; \
+  if (*hash_index < 0) *hash_index = new_val; \
+  *hash_index = (*hash_index) % hash_length; \
+  while ( hash_table[*hash_index] != new_val) { \
+    if (hash_table[*hash_index] == -1) { (*used)++; break;} \
+    (*hash_index)++; \
+    *hash_index = (*hash_index) % hash_length; \
+  } \
+}
+#endif /*ifdef ML_UseInlinedHashFunction */
+
+/* JJH FIXME
+#ifdef __GNUC__
+
+#define ML_Enter() \
+ if(ML_DebugLocation()) { if( NEVADA::comm.rank() ==
+NEVADA::comm.IO_processor()) printf("+++ Entering: %s\n",__PRETTY_FUNCTION__);}
+
+ #define ML_Leave() \
+ if(ML_DebugLocation()) { if( NEVADA::comm.rank() ==
+NEVADA::comm.IO_processor()) printf("--- Leaving: %s\n",__PRETTY_FUNCTION__);}
+
+ #else
+ #define MLEnter()
+ #define MLLeave()
+ #endif
+ */
+
+ /*
+ #define MLEnter() \
+ if(Debug_Location()){ if( NEVADA::comm.rank() == NEVADA::comm.IO_processor())
+std::cout << "+++
+ Entering: " << __FILE__ << ":" << __LINE__  << std::endl;}
+                                                                                 
+ #define MLLeave() \
+ if(Debug_Location()){ if( NEVADA::comm.rank() == NEVADA::comm.IO_processor())
+std::cout << "--- Leaving:
+ " << __FILE__ << ":" << __LINE__ << std::endl;}
+*/
+
+
+/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
+/* The following is included in the siesta SUN4 environment to solve    */
+/* the random number generation problem                                 */
+/* -------------------------------------------------------------------- */
+#if defined(SUN4) || defined(SUN5)
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+   extern "C" {
+#endif
+#endif
+
+     double drand48();
+     void srand48(long seedval);
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+   }
+#endif
+#endif
+
+#endif
+
+#define million  0.1e7
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+   extern "C" {
+#endif
+#endif
+
+   void   pr_error(const char *fmt,  ... );
+   double GetClock(void);
+   void StartTimer(double* t0);
+   void StopTimer(double* t0, double* delta);
+   void ReportTimer(double t0, const char *msgString, ML_Comm *comm);
+
+   int    ML_crude_search( int, int, int * ); 
+   int    ML_sorted_search( int, int, int * ); 
+   int    ML_fastsorted_search( int, int, int * , int); 
+   int    ML_sorted_search2( int, int, int *, int, int ** ); 
+   int    ML_search_insert_sort( int, int *, int *, int * );
+   int    ML_split_dsort(double list[], int N, int *, int);
+   int    ML_selection_dsort(double list[], int N, int *, int);
+   int    ML_sort( int, int * ); 
+   void   ML_dsort2(double *, int N, int *);
+
+   int    ML_Check_Context( void * );
+   int    ML_randomize( int , int * ); 
+   int    ML_random_init(void);
+   int    ML_get_random_seed();     
+   void   ML_set_random_seed(int seed);
+   void   ML_random_vec(double u[], int N, ML_Comm *comm);
+   double ML_srandom1(int *seed);
+
+   void   ML_serial_start(ML_Comm *comm);
+   void   ML_serial_end(ML_Comm *comm);
+   int    ML_Coord2RBM(int Nnodes, double x[], double y[], double z[], double rbm[], int Ndof, int NscalarDof);
+   void ML_az_dsort2(double dlist[], int N, int list2[]);
+
+   /* these are functions used by Ray in his RAP thing */
+
+   void   ML_az_sort(int list[], int N, int list2[], double list3[]);
+   void   ML_az_dsort(double list[], int N);
+   void   ML_gsum_scalar_int(int vals[], int vals2[], ML_Comm *comm);
+   void   ML_gsum_vec_int(int *vals[], int *vals2[], int, ML_Comm *comm);
+   void   ML_rm_duplicates(int array[], int *N);
+   void   ML_splitup_big_msg(int, char *, char *, unsigned int, int *,
+                             int *, int *, int *, int , int *, ML_Comm *);
+   double ML_gdot(int N, double r[], double z[], ML_Comm *comm);
+   double ML_gsum_double(double val, ML_Comm *comm);
+   void   ML_gsum_vec_double(double *vals[], double *vals2[], int, ML_Comm *comm);
+   double ML_gmax_double(double val, ML_Comm *comm);
+   int    ML_gmax_int(int val, ML_Comm *comm);
+   int    ML_find_index(int key, int list[], int length);
+   void   ML_use_param(void *data, int junk);
+   void   ML_BreakForDebugger(ML_Comm *comm);
+   void ML_Pause(ML_Comm *comm);
+   void ML_print_line (const char *charstr, int ntimes);
+
+   /*MS*/
+   int ML_gsum_int(int val, ML_Comm *comm);
+   int ML_gmin_int(int val, ML_Comm *comm);
+   double ML_gmin_double(double val, ML_Comm *comm);
+   /*ms*/
+   extern int ML_Operator_Print_UsingGlobalOrdering( ML_Operator *matrix, 
+                                           const char label[],
+                                           int *, int *);
+   extern int ML_build_global_numbering( ML_Operator *Amat,
+                                         int **pglobal_numbering,
+                                         const char *rowsOrCols );
+
+
+   int ML_Operator_Lump(ML_Operator *A, ML_Operator **B);
+   double ML_Global_Standard_Deviation(double sample, int n,
+                                       int activeflag, ML_Comm *comm);
+
+   int ML_SetupCoordinates(ML *ml_ptr, int level, int NumPDEEqns,
+                        double *in_x_coord, double *in_y_coord,
+                        double *in_z_coord);
+   int ML_hash_init(int hash_list[], int hash_length, int *hash_used);
+#ifndef ML_UseInlinedHashFunction
+   void ML_hash_it(int value, int table[], int tableLength,int *spaceUsed,
+                   int *hashKey);
+   void ML_fast_hash(int value, int table[], int tableLengthMinusOne,
+                     int *spaceUsed, int *hashKey);
+#endif
+   void ML_print_align(int int2match, char *space, int pad);
+
+   int ML_estimate_avg_nz_per_row(ML_Operator * matrix, double * avg_nz);
+
+#ifndef ML_CPP
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+#endif
+
diff -ruN trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.h.rej trilinos-11.4.3/packages/ml/src/Utils/ml_utils.h.rej
--- trilinos-11.4.3-clean/packages/ml/src/Utils/ml_utils.h.rej	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/ml/src/Utils/ml_utils.h.rej	2014-02-06 15:48:50.000000000 -0700
@@ -0,0 +1,12 @@
+--- packages/ml/src/Utils/ml_utils.h	2013-11-04 12:27:11.000000000 -0700
++++ packages/ml/src/Utils/ml_utils.h	2014-01-09 21:23:38.867346800 -0700
+@@ -21,7 +21,8 @@
+ #endif
+ #endif
+ 
+-#ifndef ICL
++// #ifndef ICL
++#if ! (defined(ICL) || defined(_MSC_VER))
+ #include <unistd.h>
+ #endif
+ 
diff -ruN trilinos-11.4.3-clean/packages/seacas/libraries/exodus/cbind/include/exodusII.h trilinos-11.4.3/packages/seacas/libraries/exodus/cbind/include/exodusII.h
--- trilinos-11.4.3-clean/packages/seacas/libraries/exodus/cbind/include/exodusII.h	2014-02-06 15:46:52.000000000 -0700
+++ trilinos-11.4.3/packages/seacas/libraries/exodus/cbind/include/exodusII.h	2014-02-06 15:48:50.000000000 -0700
@@ -51,7 +51,12 @@
 
 #include <stddef.h>
 #include <stdlib.h>
-#include <stdint.h>
+#ifdef WIN32
+  typedef __int64 int64_t;
+  #define PRId64 "%ld"
+#else
+  #include <stdint.h>
+#endif
 
 #ifndef NC_INT64
 #error "NetCDF version 4.1.2 or later is required."
diff -ruN trilinos-11.4.3-clean/packages/seacas/libraries/exodus/cbind/include/exodusII.h.orig trilinos-11.4.3/packages/seacas/libraries/exodus/cbind/include/exodusII.h.orig
--- trilinos-11.4.3-clean/packages/seacas/libraries/exodus/cbind/include/exodusII.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/seacas/libraries/exodus/cbind/include/exodusII.h.orig	2013-11-21 13:12:15.000000000 -0700
@@ -0,0 +1,1983 @@
+/*
+ * Copyright (c) 2005 Sandia Corporation. Under the terms of Contract
+ * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Governement
+ * retains certain rights in this software.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ * 
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *       with the distribution.  
+ * 
+ *     * Neither the name of Sandia Corporation nor the names of its
+ *       contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ */
+
+/*****************************************************************************
+ *
+ * exodusII.h - Exodus II API include file
+ *
+ *****************************************************************************/
+
+#ifndef EXODUS_II_HDR
+#define EXODUS_II_HDR
+
+#include "netcdf.h"
+
+#if defined(PARALLEL_AWARE_EXODUS)
+#include "netcdf_par.h"
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#ifndef NC_INT64
+#error "NetCDF version 4.1.2 or later is required."
+#endif
+
+/* EXODUS II version number */
+#define EX_API_VERS 5.26f
+#define EX_API_VERS_NODOT 526
+#define EX_VERS EX_API_VERS
+#define NEMESIS_API_VERSION		EX_API_VERS
+#define NEMESIS_API_VERSION_NODOT	EX_API_VERS_NODOT
+#define NEMESIS_FILE_VERSION		2.6 
+
+/*
+ * need following extern if this include file is used in a C++
+ * program, to keep the C++ compiler from mangling the function names.
+ */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /*
+   * The following are miscellaneous constants used in the EXODUS II
+   * API. They should already be defined, but are left over from the
+   * old days...
+   */
+#ifndef TRUE
+#define TRUE -1
+#endif
+
+#ifndef FALSE
+#define FALSE 0 
+#endif
+
+  /**
+   * \defgroup FileVars Variables controlling the file creation mode.
+   *@{
+   */
+  /* Modes for ex_open */
+#define EX_READ                 0x0000 /**< ex_open(): open file for reading (default) */
+#define EX_WRITE                0x0001 /**< ex_open(): open existing file for appending. */
+
+#define EX_NOCLOBBER            0x0004 /**< Don't overwrite existing database, default */
+#define EX_CLOBBER              0x0008 /**< Overwrite existing database if it exists */
+#define EX_NORMAL_MODEL         0x0010 /**< disable mods that permit storage of larger models */
+#define EX_LARGE_MODEL          0x0020 /**< enable mods that permit storage of larger models */
+#define EX_NETCDF4              0x0040 /**< use the hdf5-based netcdf4 output */
+#define EX_NOSHARE              0x0080  /**< Do not open netcdf file in "share" mode */
+#define EX_SHARE                0x0100 /**< Do open netcdf file in "share" mode */
+#define EX_NOCLASSIC            0x0200 /**< Do not force netcdf to classic mode in netcdf4 mode */
+
+  /* Need to distinguish between storage on database (DB in name) and
+     passed through the API functions (API in name).
+  */
+#define EX_MAPS_INT64_DB        0x0400 /**< All maps (id, order, ...) store int64_t values */
+#define EX_IDS_INT64_DB         0x0800 /**< All entity ids (sets, blocks, maps) are int64_t values */
+#define EX_BULK_INT64_DB        0x1000 /**< All integer bulk data (local indices, counts, maps); not ids */
+#define EX_ALL_INT64_DB         (EX_MAPS_INT64_DB|EX_IDS_INT64_DB|EX_BULK_INT64_DB) /**< All of the above... */
+
+#define EX_MAPS_INT64_API       0x2000 /**< All maps (id, order, ...) store int64_t values */
+#define EX_IDS_INT64_API        0x4000 /**< All entity ids (sets, blocks, maps) are int64_t values */
+#define EX_BULK_INT64_API       0x8000 /**< All integer bulk data (local indices, counts, maps); not ids */
+#define EX_INQ_INT64_API       0x10000 /**< Integers passed to/from ex_inquire are int64_t */
+#define EX_ALL_INT64_API        (EX_MAPS_INT64_API|EX_IDS_INT64_API|EX_BULK_INT64_API|EX_INQ_INT64_API) /**< All of the above... */
+
+  /* Parallel IO mode flags... */
+#define EX_MPIIO               0x20000
+#define EX_MPIPOSIX            0x40000
+#define EX_PNETCDF             0x80000
+  
+  /*@}*/
+  
+  /*! \sa ex_inquire() */
+  enum ex_inquiry {
+    EX_INQ_FILE_TYPE       =  1,     /**< inquire EXODUS II file type*/
+    EX_INQ_API_VERS        =  2,     /**< inquire API version number */
+    EX_INQ_DB_VERS         =  3,     /**< inquire database version number */
+    EX_INQ_TITLE           =  4,     /**< inquire database title     */
+    EX_INQ_DIM             =  5,     /**< inquire number of dimensions */
+    EX_INQ_NODES           =  6,     /**< inquire number of nodes    */
+    EX_INQ_ELEM            =  7,     /**< inquire number of elements */
+    EX_INQ_ELEM_BLK        =  8,     /**< inquire number of element blocks */
+    EX_INQ_NODE_SETS       =  9,     /**< inquire number of node sets*/
+    EX_INQ_NS_NODE_LEN     = 10,     /**< inquire length of node set node list */
+    EX_INQ_SIDE_SETS       = 11,     /**< inquire number of side sets*/
+    EX_INQ_SS_NODE_LEN     = 12,     /**< inquire length of side set node list */
+    EX_INQ_SS_ELEM_LEN     = 13,     /**< inquire length of side set element list */
+    EX_INQ_QA              = 14,     /**< inquire number of QA records */
+    EX_INQ_INFO            = 15,     /**< inquire number of info records */
+    EX_INQ_TIME            = 16,     /**< inquire number of time steps in the database */
+    EX_INQ_EB_PROP         = 17,     /**< inquire number of element block properties */
+    EX_INQ_NS_PROP         = 18,     /**< inquire number of node set properties */
+    EX_INQ_SS_PROP         = 19,     /**< inquire number of side set properties */
+    EX_INQ_NS_DF_LEN       = 20,     /**< inquire length of node set distribution factor list*/
+    EX_INQ_SS_DF_LEN       = 21,     /**< inquire length of side set distribution factor list*/
+    EX_INQ_LIB_VERS        = 22,     /**< inquire API Lib vers number*/
+    EX_INQ_EM_PROP         = 23,     /**< inquire number of element map properties */
+    EX_INQ_NM_PROP         = 24,     /**< inquire number of node map properties */
+    EX_INQ_ELEM_MAP        = 25,     /**< inquire number of element maps */
+    EX_INQ_NODE_MAP        = 26,     /**< inquire number of node maps*/
+    EX_INQ_EDGE            = 27,     /**< inquire number of edges    */
+    EX_INQ_EDGE_BLK        = 28,     /**< inquire number of edge blocks */
+    EX_INQ_EDGE_SETS       = 29,     /**< inquire number of edge sets   */
+    EX_INQ_ES_LEN          = 30,     /**< inquire length of concat edge set edge list       */
+    EX_INQ_ES_DF_LEN       = 31,     /**< inquire length of concat edge set dist factor list*/
+    EX_INQ_EDGE_PROP       = 32,     /**< inquire number of properties stored per edge block    */
+    EX_INQ_ES_PROP         = 33,     /**< inquire number of properties stored per edge set      */
+    EX_INQ_FACE            = 34,     /**< inquire number of faces */
+    EX_INQ_FACE_BLK        = 35,     /**< inquire number of face blocks */
+    EX_INQ_FACE_SETS       = 36,     /**< inquire number of face sets */
+    EX_INQ_FS_LEN          = 37,     /**< inquire length of concat face set face list */
+    EX_INQ_FS_DF_LEN       = 38,     /**< inquire length of concat face set dist factor list*/
+    EX_INQ_FACE_PROP       = 39,     /**< inquire number of properties stored per face block */
+    EX_INQ_FS_PROP         = 40,     /**< inquire number of properties stored per face set */
+    EX_INQ_ELEM_SETS       = 41,     /**< inquire number of element sets */
+    EX_INQ_ELS_LEN         = 42,     /**< inquire length of concat element set element list       */
+    EX_INQ_ELS_DF_LEN      = 43,     /**< inquire length of concat element set dist factor list*/
+    EX_INQ_ELS_PROP        = 44,     /**< inquire number of properties stored per elem set      */
+    EX_INQ_EDGE_MAP        = 45,     /**< inquire number of edge maps                     */
+    EX_INQ_FACE_MAP        = 46,     /**< inquire number of face maps                     */
+    EX_INQ_COORD_FRAMES    = 47,     /**< inquire number of coordinate frames */
+    EX_INQ_DB_MAX_ALLOWED_NAME_LENGTH  = 48,     /**< inquire size of MAX_NAME_LENGTH dimension on database */
+    EX_INQ_DB_MAX_USED_NAME_LENGTH  = 49,     /**< inquire size of MAX_NAME_LENGTH dimension on database */
+    EX_INQ_MAX_READ_NAME_LENGTH = 50,     /**< inquire client-specified max size of returned names */
+    EX_INQ_INVALID         = -1};
+
+  typedef enum ex_inquiry ex_inquiry;
+  
+  /* Options */
+  /**
+   * \defgroup FileOptions Variables controlling the compression, name size, and integer size.
+   *@{
+   */
+  /* Modes for ex_open */
+  /*! \sa ex_set_option() */
+  enum ex_option_type {
+    EX_OPT_MAX_NAME_LENGTH = 1,
+    EX_OPT_COMPRESSION_TYPE,     /* Currently not used. GZip by default */
+    EX_OPT_COMPRESSION_LEVEL,    /* 0 (disabled/fastest) ... 9 (best/slowest) */
+    EX_OPT_COMPRESSION_SHUFFLE,  /* 0 (disabled); 1 (enabled) */
+    EX_OPT_INTEGER_SIZE_API,     /* See *_INT64_* values above */
+    EX_OPT_INTEGER_SIZE_DB /* (query only) */
+  };
+  typedef enum ex_option_type ex_option_type;
+  /*@}*/
+  
+  enum ex_entity_type {
+    EX_NODAL       = 14,          /**< nodal "block" for variables*/
+    EX_NODE_BLOCK  = 14,          /**< alias for EX_NODAL         */
+    EX_NODE_SET    =  2,          /**< node set property code     */
+    EX_EDGE_BLOCK  =  6,          /**< edge block property code   */
+    EX_EDGE_SET    =  7,          /**< edge set property code     */
+    EX_FACE_BLOCK  =  8,          /**< face block property code   */
+    EX_FACE_SET    =  9,          /**< face set property code     */
+    EX_ELEM_BLOCK  =  1,          /**< element block property code*/
+    EX_ELEM_SET    = 10,          /**< face set property code     */
+    
+    EX_SIDE_SET    =  3,          /**< side set property code     */
+    
+    EX_ELEM_MAP    =  4,          /**< element map property code  */
+    EX_NODE_MAP    =  5,          /**< node map property code     */
+    EX_EDGE_MAP    = 11,          /**< edge map property code     */
+    EX_FACE_MAP    = 12,          /**< face map property code     */
+    
+    EX_GLOBAL      = 13,          /**< global "block" for variables*/
+    EX_COORDINATE  = 15,          /**< kluge so some internal wrapper functions work */
+    EX_INVALID     = -1};             
+  typedef enum ex_entity_type ex_entity_type;
+  
+  /**
+   * ex_opts() function codes - codes are OR'ed into exopts
+   */
+  enum ex_options {
+    EX_DEFAULT  = 0,
+    EX_VERBOSE  = 1,  /**< verbose mode message flag   */
+    EX_DEBUG    = 2,  /**< debug mode def             */
+    EX_ABORT    = 4   /**< abort mode flag def        */
+  };
+  typedef enum ex_options ex_options;
+  
+  /** The value used to indicate that an entity (block, nset, sset)
+      has not had its id set to a valid value
+  */
+#define EX_INVALID_ID -1
+
+  /**
+   * \defgroup StringLengths maximum string lengths;
+   * constants that are used as netcdf dimensions must be of type long
+   * @{ 
+   */
+  /** Maximum length of QA record, element type name */
+#define MAX_STR_LENGTH          32L 
+  /** Maximum length of an entity name, attribute name, variable name */
+#define MAX_NAME_LENGTH         MAX_STR_LENGTH
+  
+  /** Maximum length of the database title or an information record */
+#define MAX_LINE_LENGTH         80L
+  /** Maximum length of an error message passed to ex_err() function. Typically, internal use only */
+#define MAX_ERR_LENGTH          256
+  /* @} */
+
+  /** Specifies that this argument is the id of an entity: element block, nodeset, sideset, ... */
+  typedef int64_t ex_entity_id;
+  
+  /** The mechanism for passing double/float and int/int64_t both use a
+     void*; to avoid some confusion as to whether a function takes an
+     integer or a float/double, the following typedef is used for the
+     integer argument
+  */
+  typedef void void_int;
+  
+  /**
+   * \defgroup APIStructs Structures used by external API functions.
+   * @{
+   */
+  typedef struct ex_init_params {
+    char title[MAX_LINE_LENGTH + 1];
+    int64_t num_dim;
+    int64_t num_nodes;
+    int64_t num_edge;
+    int64_t num_edge_blk;
+    int64_t num_face;
+    int64_t num_face_blk;
+    int64_t num_elem;
+    int64_t num_elem_blk;
+    int64_t num_node_sets;
+    int64_t num_edge_sets;
+    int64_t num_face_sets;
+    int64_t num_side_sets;
+    int64_t num_elem_sets;
+    int64_t num_node_maps;
+    int64_t num_edge_maps;
+    int64_t num_face_maps;
+    int64_t num_elem_maps;
+  } ex_init_params;
+
+  typedef struct ex_block {
+    int64_t id;
+    ex_entity_type type;
+    char   topology[MAX_STR_LENGTH+1];
+    int64_t num_entry;
+    int64_t num_nodes_per_entry;
+    int64_t num_edges_per_entry;
+    int64_t num_faces_per_entry;
+    int64_t num_attribute;
+  } ex_block;
+
+  typedef struct ex_set {
+    int64_t id;
+    ex_entity_type type;
+    int64_t num_entry;
+    int64_t num_distribution_factor;
+    void_int* entry_list;
+    void_int* extra_list;
+    void*     distribution_factor_list;
+  } ex_set;
+
+  typedef struct ex_block_params {
+    void_int*  edge_blk_id;
+    char** edge_type;
+    int*   num_edge_this_blk;
+    int*   num_nodes_per_edge;
+    int*   num_attr_edge;
+    void_int*   face_blk_id;
+    char** face_type;
+    int*   num_face_this_blk;
+    int*   num_nodes_per_face;
+    int*   num_attr_face;
+    void_int*   elem_blk_id;
+    char** elem_type;
+    int*   num_elem_this_blk;
+    int*   num_nodes_per_elem;
+    int*   num_edges_per_elem;
+    int*   num_faces_per_elem;
+    int*   num_attr_elem;
+    int    define_maps;
+  } ex_block_params;
+
+  typedef struct ex_set_specs {
+    void_int* sets_ids;
+    void_int* num_entries_per_set;
+    void_int* num_dist_per_set;
+    void_int* sets_entry_index;
+    void_int* sets_dist_index;
+    void_int* sets_entry_list;
+    void_int* sets_extra_list;
+    void* sets_dist_fact;
+  } ex_set_specs;
+
+  typedef struct ex_var_params {
+    int  num_glob;
+    int  num_node;
+    int  num_edge;
+    int  num_face;
+    int  num_elem;
+    int  num_nset;
+    int  num_eset;
+    int  num_fset;
+    int  num_sset;
+    int  num_elset;
+    int* edge_var_tab;
+    int* face_var_tab;
+    int* elem_var_tab;
+    int* nset_var_tab;
+    int* eset_var_tab;
+    int* fset_var_tab;
+    int* sset_var_tab;
+    int* elset_var_tab;
+  } ex_var_params;
+  /* @} */
+
+#ifndef EXODUS_EXPORT
+#define EXODUS_EXPORT extern
+#endif /* EXODUS_EXPORT */
+
+  /* routines for file initialization i/o */
+  EXODUS_EXPORT int ex_close (int exoid);
+
+  EXODUS_EXPORT int ex_copy (int in_exoid, int out_exoid);
+
+#define ex_create(path, mode, comp_ws, io_ws) ex_create_int(path, mode, comp_ws, io_ws, EX_API_VERS_NODOT)  
+
+  EXODUS_EXPORT int ex_create_int (const char *path, int cmode, int *comp_ws, int *io_ws, int my_version);
+
+ 
+  EXODUS_EXPORT int ex_get_all_times (int   exoid,
+				      void *time_values);
+
+  EXODUS_EXPORT int ex_get_coord_names (int    exoid,
+					char **coord_names);
+
+  EXODUS_EXPORT int ex_get_coord (int exoid,
+				  void *x_coor,
+				  void *y_coor,
+				  void *z_coor);
+
+  EXODUS_EXPORT int ex_get_n_coord (int exoid,
+				    int64_t start_node_num,
+				    int64_t  num_nodes,
+				    void *x_coor,
+				    void *y_coor,
+				    void *z_coor);
+
+  EXODUS_EXPORT int ex_get_partial_coord (int exoid,
+				    int64_t start_node_num,
+				    int64_t  num_nodes,
+				    void *x_coor,
+				    void *y_coor,
+				    void *z_coor);
+
+  EXODUS_EXPORT int ex_get_ids (int  exoid,
+				ex_entity_type  obj_type,
+				void_int   *ids);
+
+  EXODUS_EXPORT int ex_get_coordinate_frames(int exoid,
+					     int *nframes,
+					     void_int *cf_ids,
+					     void* pt_coordinates,
+					     char* tags);
+
+  EXODUS_EXPORT int ex_get_glob_vars (int   exoid,
+				      int   time_step,
+				      int   num_glob_vars,
+				      void *glob_var_vals);
+
+  EXODUS_EXPORT int ex_get_glob_var_time (int   exoid,
+					  int   glob_var_index,
+					  int   beg_time_step,
+					  int   end_time_step,
+					  void *glob_var_vals);
+
+  EXODUS_EXPORT int ex_get_info (int exoid, char **info);
+
+  EXODUS_EXPORT int ex_put_init_ext (int exoid,  const ex_init_params *param);
+
+  EXODUS_EXPORT int ex_get_init_ext (int exoid, ex_init_params *param);
+
+  EXODUS_EXPORT int ex_get_init (int   exoid,
+				 char *title,
+				 void_int  *num_dim,
+				 void_int  *num_nodes,
+				 void_int  *num_elem, 
+				 void_int  *num_elem_blk,
+				 void_int  *num_node_sets,
+				 void_int  *num_side_sets);
+
+  EXODUS_EXPORT int ex_put_init (int   exoid,
+				 const char *title,
+				 int64_t   num_dim,
+				 int64_t   num_nodes,
+				 int64_t   num_elem,
+				 int64_t   num_elem_blk,
+				 int64_t   num_node_sets,
+				 int64_t   num_side_sets);
+
+  EXODUS_EXPORT int ex_get_map_param (int   exoid,
+				      int  *num_node_maps,
+				      int  *num_elem_maps);
+
+  EXODUS_EXPORT int ex_get_name (int   exoid,
+				 ex_entity_type   obj_type,
+				 ex_entity_id     entity_id, 
+				 char *name);
+
+  EXODUS_EXPORT int ex_get_names (int exoid,
+				  ex_entity_type obj_type,
+				  char **names);
+
+  EXODUS_EXPORT int ex_get_nset_var_tab (int  exoid,
+					 int  num_nodesets,
+					 int  num_nset_var,
+					 int *nset_var_tab);
+
+  EXODUS_EXPORT int ex_get_n_nodal_var (int   exoid,
+					int   time_step,
+					int   nodal_var_index,
+					int64_t start_node, 
+					int64_t num_nodes, 
+					void *nodal_var_vals);
+
+  EXODUS_EXPORT int ex_get_partial_nodal_var (int   exoid,
+					int   time_step,
+					int   nodal_var_index,
+					int64_t start_node, 
+					int64_t num_nodes, 
+					void *nodal_var_vals);
+
+
+  EXODUS_EXPORT int ex_get_prop_array (int   exoid,
+				       ex_entity_type obj_type,
+				       const char *prop_name,
+				       void_int  *values);
+
+  EXODUS_EXPORT int ex_get_prop (int   exoid,
+				 ex_entity_type obj_type,
+				 ex_entity_id   obj_id,
+				 const char *prop_name,
+				 void_int  *value);
+
+  EXODUS_EXPORT int ex_get_partial_num_map (int   exoid,
+					    ex_entity_type map_type,
+					    ex_entity_id   map_id,
+					    int64_t ent_start,
+					    int64_t ent_count, 
+					    void_int  *elem_map);
+  
+  EXODUS_EXPORT int ex_get_prop_names (int    exoid,
+				       ex_entity_type obj_type,
+				       char **prop_names);
+
+  EXODUS_EXPORT int ex_get_qa (int exoid,
+			       char *qa_record[][4]);
+
+  EXODUS_EXPORT int ex_get_time (int   exoid,
+				 int   time_step,
+				 void *time_value);
+
+  EXODUS_EXPORT int ex_get_variable_names (int   exoid,
+					   ex_entity_type obj_type,
+					   int   num_vars,
+					   char *var_names[]);
+  EXODUS_EXPORT int ex_get_variable_name (int   exoid,
+					  ex_entity_type obj_type,
+					  int   var_num,
+					  char *var_name);
+
+  EXODUS_EXPORT int ex_get_variable_param (int   exoid,
+					   ex_entity_type obj_type,
+					   int  *num_vars);
+
+  EXODUS_EXPORT int ex_get_object_truth_vector (int  exoid,
+						ex_entity_type var_type,
+						ex_entity_id   object_id,
+						int  num_var,
+						int *var_vector);
+
+  EXODUS_EXPORT int ex_get_truth_table (int  exoid,
+					ex_entity_type obj_type,
+					int  num_blk,
+					int  num_var,
+					int *var_tab);
+  
+#define ex_open(path, mode, comp_ws, io_ws, version) ex_open_int(path, mode, comp_ws, io_ws, version, EX_API_VERS_NODOT)  
+
+  EXODUS_EXPORT int ex_open_int (const char  *path,
+				 int    mode,
+				 int   *comp_ws,
+				 int   *io_ws,
+				 float *version, int my_version);
+  
+  EXODUS_EXPORT int ex_put_attr_param (int   exoid,
+				       ex_entity_type obj_type,
+				       ex_entity_id   obj_id,
+				       int   num_attrs);
+
+  EXODUS_EXPORT int ex_get_attr_param (int   exoid,
+				       ex_entity_type obj_type,
+				       ex_entity_id   obj_id,
+				       int   *num_attrs);
+
+  EXODUS_EXPORT int ex_put_all_var_param (int exoid,
+					  int num_g, int num_n,
+					  int num_e, int *elem_var_tab,
+					  int num_m, int *nset_var_tab,
+					  int num_s, int *sset_var_tab);
+
+  EXODUS_EXPORT int ex_put_concat_elem_block (int    exoid,
+					      const void_int*   elem_blk_id,
+					      char *elem_type[],
+					      const void_int*   num_elem_this_blk,
+					      const void_int*   num_nodes_per_elem,
+					      const void_int*   num_attr,
+					      int    define_maps);
+
+  EXODUS_EXPORT int ex_put_coord_names (int   exoid,
+					char *coord_names[]);
+
+  EXODUS_EXPORT int ex_put_coord (int   exoid,
+				  const void *x_coor,
+				  const void *y_coor,
+				  const void *z_coor);
+
+  EXODUS_EXPORT int ex_put_n_coord (int   exoid,
+				    int64_t   start_node_num,
+				    int64_t   num_nodes,
+				    const void *x_coor,
+				    const void *y_coor,
+				    const void *z_coor);
+
+  EXODUS_EXPORT int ex_put_partial_coord (int   exoid,
+				    int64_t   start_node_num,
+				    int64_t   num_nodes,
+				    const void *x_coor,
+				    const void *y_coor,
+				    const void *z_coor);
+
+  EXODUS_EXPORT int ex_put_id_map(int exoid,
+				  ex_entity_type obj_type,
+				  const void_int *map);
+  
+  EXODUS_EXPORT int ex_put_partial_id_map(int exoid,
+					  ex_entity_type obj_type,
+					  int64_t   start_entity_num, 
+					  int64_t   num_entities, 
+					  const void_int *map);
+  
+  EXODUS_EXPORT int ex_put_n_elem_num_map (int  exoid,
+					   int64_t  start_ent,
+					   int64_t  num_ents,
+					   const void_int *map);
+
+  EXODUS_EXPORT int ex_put_n_node_num_map (int  exoid,
+					   int64_t  start_ent,
+					   int64_t  num_ents,
+					   const void_int *map);
+
+  EXODUS_EXPORT int ex_put_partial_elem_num_map (int  exoid,
+					   int64_t  start_ent,
+					   int64_t  num_ents,
+					   const void_int *map);
+
+  EXODUS_EXPORT int ex_put_partial_node_num_map (int  exoid,
+					   int64_t  start_ent,
+					   int64_t  num_ents,
+					   const void_int *map);
+
+  EXODUS_EXPORT int ex_get_id_map(int exoid,
+				  ex_entity_type obj_type,
+				  void_int *map);
+  
+  EXODUS_EXPORT int ex_get_partial_id_map (int   exoid,
+					   ex_entity_type map_type,
+					   int64_t   start_entity_num,
+					   int64_t   num_entities,
+					   void_int*  map);
+
+  EXODUS_EXPORT int ex_put_coordinate_frames(int exoid,
+					     int nframes,
+					     const void_int *cf_ids, 
+					     void* pt_coordinates,
+					     const char* tags);
+
+  EXODUS_EXPORT int ex_put_info (int   exoid, 
+				 int   num_info,
+				 char *info[]);
+
+  EXODUS_EXPORT int ex_put_map_param (int   exoid,
+				      int   num_node_maps,
+				      int   num_elem_maps);
+
+  EXODUS_EXPORT int ex_put_name (int   exoid,
+				 ex_entity_type obj_type,
+				 ex_entity_id   entity_id,
+				 const char *name);
+
+  EXODUS_EXPORT int ex_put_names (int   exoid,
+				  ex_entity_type obj_type,
+				  char *names[]);
+
+  EXODUS_EXPORT int ex_put_n_one_attr( int   exoid,
+				       ex_entity_type obj_type,
+				       ex_entity_id   obj_id,
+				       int64_t   start_num,
+				       int64_t   num_ent,
+				       int   attrib_index,
+				       const void *attrib );
+
+  EXODUS_EXPORT int ex_put_partial_one_attr( int   exoid,
+				       ex_entity_type obj_type,
+				       ex_entity_id   obj_id,
+				       int64_t   start_num,
+				       int64_t   num_ent,
+				       int   attrib_index,
+				       const void *attrib );
+
+  EXODUS_EXPORT int ex_put_prop (int   exoid,
+				 ex_entity_type obj_type,
+				 ex_entity_id   obj_id,
+				 const char *prop_name,
+				 ex_entity_id   value);
+
+  EXODUS_EXPORT int ex_put_prop_array (int   exoid,
+				       ex_entity_type obj_type,
+				       const char *prop_name,
+				       const void_int  *values);
+
+  EXODUS_EXPORT int ex_put_prop_names (int   exoid,
+				       ex_entity_type obj_type,
+				       int   num_props,
+				       char **prop_names);
+
+  EXODUS_EXPORT int ex_put_qa (int   exoid,
+			       int   num_qa_records,
+			       char* qa_record[][4]);
+
+  EXODUS_EXPORT int ex_put_time (int   exoid,
+				 int   time_step,
+				 const void *time_value);
+
+  EXODUS_EXPORT int ex_put_variable_name (int   exoid,
+					  ex_entity_type obj_type,
+					  int   var_num,
+					  const char *var_name);
+
+  EXODUS_EXPORT int ex_put_variable_names (int   exoid,
+					   ex_entity_type obj_type,
+					   int   num_vars,
+					   char* var_names[]);
+
+  EXODUS_EXPORT int ex_put_variable_param (int exoid,
+					   ex_entity_type obj_type,
+					   int num_vars);
+
+  EXODUS_EXPORT int ex_put_truth_table (int  exoid,
+					ex_entity_type obj_type,
+					int  num_blk,
+					int  num_var,
+					int *var_tab);
+
+  EXODUS_EXPORT int ex_update (int exoid);
+  EXODUS_EXPORT int ex_get_num_props (int exoid, ex_entity_type obj_type);
+  EXODUS_EXPORT int ex_large_model(int exoid);
+  EXODUS_EXPORT size_t ex_header_size(int exoid);
+
+  EXODUS_EXPORT void ex_err(const char *module_name, const char *message, int err_num);
+  EXODUS_EXPORT void ex_get_err(const char** msg, const char** func, int* errcode);
+  EXODUS_EXPORT void ex_opts(int options);
+  EXODUS_EXPORT int ex_inquire(int exoid, int inquiry, void_int*, float*, char*);
+  EXODUS_EXPORT int64_t ex_inquire_int(int exoid, int inquiry);
+  EXODUS_EXPORT int ex_int64_status(int exoid);
+  EXODUS_EXPORT int ex_set_int64_status(int exoid, int mode);
+
+  /** Note that the max name length setting is global at this time; not specific
+   * to a particular database; however, the exoid option is passed to give
+   * flexibility in the future to implement this on a database-by-database basis.
+   */
+  EXODUS_EXPORT int ex_set_max_name_length(int exoid, int length);
+
+  EXODUS_EXPORT int ex_set_option(int exoid, ex_option_type option, int option_value);
+
+  /*  Write Node Edge Face or Element Number Map */
+  EXODUS_EXPORT int ex_put_num_map(int exoid,
+				   ex_entity_type map_type,
+				   ex_entity_id map_id,
+				   const void_int *map);
+
+  /*  Read Number Map */
+  EXODUS_EXPORT int ex_get_num_map(int exoid,
+				   ex_entity_type map_type,
+				   ex_entity_id map_id,
+				   void_int *map);
+
+  /*  Write Edge Face or Element Block Parameters */
+  EXODUS_EXPORT int ex_put_block(int exoid,
+				 ex_entity_type blk_type,
+				 ex_entity_id   blk_id,
+				 const char *entry_descrip,
+				 int64_t num_entries_this_blk,
+				 int64_t num_nodes_per_entry,
+				 int64_t num_edges_per_entry,
+				 int64_t num_faces_per_entry,
+				 int64_t num_attr_per_entry);
+
+
+  /*! \deprecated Use ex_get_block_param() */
+  EXODUS_EXPORT int ex_get_block(int exoid,
+				 ex_entity_type blk_type,
+				 ex_entity_id   blk_id,
+				 char *elem_type,
+				 void_int *num_entries_this_blk,
+				 void_int *num_nodes_per_entry,
+				 void_int *num_edges_per_entry,
+				 void_int *num_faces_per_entry,
+				 void_int *num_attr_per_entry);
+
+  /*  Read Edge Face or Element Block Parameters */
+  EXODUS_EXPORT int ex_get_block_param(int exoid,
+				       ex_block *block);
+
+  EXODUS_EXPORT int ex_put_block_param(int exoid,
+				       const ex_block block);
+
+  /*  Write All Edge Face and Element Block Parameters */
+  EXODUS_EXPORT int ex_put_concat_all_blocks(int exoid,
+					     const ex_block_params *param);
+
+  EXODUS_EXPORT int ex_put_entity_count_per_polyhedra(int exoid,
+						      ex_entity_type blk_type,
+						      ex_entity_id   blk_id,
+						      const int *entity_counts);
+
+  EXODUS_EXPORT int ex_get_entity_count_per_polyhedra(int exoid,
+						      ex_entity_type blk_type,
+						      ex_entity_id   blk_id,
+						      int *entity_counts);
+
+  /*  Write Edge Face or Element Block Connectivity */
+  EXODUS_EXPORT int ex_put_conn(int exoid,
+				ex_entity_type blk_type,
+				ex_entity_id   blk_id,
+				const void_int *node_conn,
+				const void_int *elem_edge_conn,
+				const void_int *elem_face_conn);
+
+  /*  Read Edge Face or Element Block Connectivity */
+  EXODUS_EXPORT int ex_get_conn(int exoid,
+				ex_entity_type blk_type,
+				ex_entity_id   blk_id,
+				void_int *nodeconn,
+				void_int *edgeconn,
+				void_int *faceconn);
+
+  /*  Read Partial Edge Face or Element Block Connectivity */
+  EXODUS_EXPORT int ex_get_n_conn(int exoid,
+				  ex_entity_type blk_type,
+				  ex_entity_id   blk_id,
+				  int64_t start_num,
+				  int64_t num_ent,
+				  void_int *nodeconn,
+				  void_int *edgeconn,
+				  void_int *faceconn);
+
+  EXODUS_EXPORT int ex_get_partial_conn(int exoid,
+				  ex_entity_type blk_type,
+				  ex_entity_id   blk_id,
+				  int64_t start_num,
+				  int64_t num_ent,
+				  void_int *nodeconn,
+				  void_int *edgeconn,
+				  void_int *faceconn);
+
+  /*  Write Edge Face or Element Block Attributes */
+  EXODUS_EXPORT int ex_put_attr(int exoid,
+				ex_entity_type blk_type,
+				ex_entity_id   blk_id,
+				const void *attrib);
+
+  EXODUS_EXPORT int ex_put_partial_attr (int   exoid,
+					 ex_entity_type blk_type,
+					 ex_entity_id   blk_id,
+					 int64_t   start_entity,
+					 int64_t   num_entity,
+					 const void *attrib);
+
+  /*  Read Edge Face or Element Block Attributes */
+  EXODUS_EXPORT int ex_get_attr(int exoid,
+				ex_entity_type obj_type,
+				ex_entity_id   obj_id,
+				void *attrib);
+
+  EXODUS_EXPORT int ex_get_n_attr(int exoid,
+				  ex_entity_type obj_type,
+				  ex_entity_id   obj_id,
+				  int64_t start_num,
+				  int64_t num_ent,
+				  void *attrib);
+
+  EXODUS_EXPORT int ex_get_partial_attr(int exoid,
+				  ex_entity_type obj_type,
+				  ex_entity_id   obj_id,
+				  int64_t start_num,
+				  int64_t num_ent,
+				  void *attrib);
+
+  /*  Write One Edge Face or Element Block Attribute */
+  EXODUS_EXPORT int ex_put_one_attr(int exoid,
+				    ex_entity_type obj_type,
+				    ex_entity_id   obj_id,
+				    int attrib_index,
+				    const void *attrib);
+
+  /*  Read One Edge Face or Element Block Attribute */
+  EXODUS_EXPORT int ex_get_one_attr(int exoid,
+				    ex_entity_type obj_type,
+				    ex_entity_id   obj_id,
+				    int attrib_index,
+				    void *attrib);
+
+  /*  Read One Edge Face or Element Block Attribute */
+  EXODUS_EXPORT int ex_get_n_one_attr(int exoid,
+				      ex_entity_type obj_type,
+				      ex_entity_id   obj_id,
+				      int64_t start_num,
+				      int64_t num_ent,
+				      int attrib_index,
+				      void *attrib);
+
+  EXODUS_EXPORT int ex_get_partial_one_attr(int exoid,
+				      ex_entity_type obj_type,
+				      ex_entity_id   obj_id,
+				      int64_t start_num,
+				      int64_t num_ent,
+				      int attrib_index,
+				      void *attrib);
+
+  /*  Write Edge Face or Element Block Attribute Names */
+  EXODUS_EXPORT int ex_put_attr_names(int exoid,
+				      ex_entity_type blk_type,
+				      ex_entity_id   blk_id,
+				      char **names);
+
+  /*  Read Edge Face or Element Block Attribute Names */
+  EXODUS_EXPORT int ex_get_attr_names(int exoid,
+				      ex_entity_type obj_type,
+				      ex_entity_id   obj_id,
+				      char **names);
+
+  /*  Write Node Edge Face or Side Set Parameters */
+  EXODUS_EXPORT int ex_put_set_param(int exoid,
+				     ex_entity_type set_type,
+				     ex_entity_id   set_id,
+				     int64_t num_entries_in_set,
+				     int64_t num_dist_fact_in_set);
+
+  /*  Read Node Edge Face or Side Set Parameters */
+  EXODUS_EXPORT int ex_get_set_param(int exoid,
+				     ex_entity_type set_type,
+				     ex_entity_id   set_id,
+				     void_int *num_entry_in_set,
+				     void_int *num_dist_fact_in_set);
+
+  /*  Write a Node Edge Face or Side Set */
+  EXODUS_EXPORT int ex_put_set(int exoid,
+			       ex_entity_type set_type,
+			       ex_entity_id   set_id,
+			       const void_int *set_entry_list,
+			       const void_int *set_extra_list);
+
+  EXODUS_EXPORT int ex_put_partial_set(int exoid,
+				       ex_entity_type set_type,
+				       ex_entity_id   set_id,
+				       int64_t offset,
+				       int64_t count,
+				       const void_int *set_entry_list,
+				       const void_int *set_extra_list);
+
+  /*  Read a Node Edge Face or Side Set */
+  EXODUS_EXPORT int ex_get_set(int exoid,
+			       ex_entity_type set_type,
+			       ex_entity_id   set_id,
+			       void_int *set_entry_list,
+			       void_int *set_extra_list);
+
+  /*  Write Node Edge Face or Side Set Distribution Factors */
+  EXODUS_EXPORT int ex_put_set_dist_fact(int exoid,
+					 ex_entity_type set_type,
+					 ex_entity_id   set_id,
+					 const void *set_dist_fact);
+
+  /*  Read Node Edge Face or Side Set Distribution Factors */
+  EXODUS_EXPORT int ex_get_set_dist_fact(int exoid,
+					 ex_entity_type set_type,
+					 ex_entity_id   set_id,
+					 void *set_dist_fact);
+
+  EXODUS_EXPORT int ex_get_partial_set_dist_fact (int   exoid,
+						  ex_entity_type set_type,
+						  ex_entity_id   set_id,
+						  int64_t   offset,
+						  int64_t   num_to_put,
+						  void *set_dist_fact);
+
+  /*  Write Concatenated Node Edge Face or Side Sets */
+  EXODUS_EXPORT int ex_put_concat_sets(int exoid,
+				       ex_entity_type set_type,
+				       const struct ex_set_specs *set_specs);
+
+  /*  Read Concatenated Node Edge Face or Side Sets */
+  EXODUS_EXPORT int ex_get_concat_sets(int exoid,
+				       ex_entity_type set_type,
+				       struct ex_set_specs *set_specs);
+
+  /*  Write Concatenated Node Edge Face or Side Sets */
+  EXODUS_EXPORT int ex_put_sets(int exoid,
+				size_t set_count,
+				const struct ex_set *sets);
+
+  /*  Read Concatenated Node Edge Face or Side Sets */
+  EXODUS_EXPORT int ex_get_sets(int exoid,
+				size_t set_count,
+				struct ex_set *sets);
+
+  /*  (MODIFIED) Write All Results Variables Parameters */
+  EXODUS_EXPORT int ex_put_all_var_param_ext(int exoid,
+					     const ex_var_params *vp);
+
+  /*  Write Edge Face or Element Variable Values on Blocks or Sets at a Time Step */
+  EXODUS_EXPORT int ex_put_var(int exoid,
+			       int time_step,
+			       ex_entity_type var_type,
+			       int var_index,
+			       ex_entity_id   obj_id,
+			       int64_t num_entries_this_obj,
+			       const void *var_vals);
+
+  /*  Write Partial Edge Face or Element Variable Values on Blocks or Sets at a Time Step */
+  EXODUS_EXPORT int ex_put_n_var(int exoid,
+				 int time_step,
+				 ex_entity_type var_type,
+				 int var_index,
+				 ex_entity_id   obj_id,
+				 int64_t start_index,
+				 int64_t num_entities,
+				 const void *var_vals);
+
+  EXODUS_EXPORT int ex_put_partial_var(int exoid,
+				 int time_step,
+				 ex_entity_type var_type,
+				 int var_index,
+				 ex_entity_id   obj_id,
+				 int64_t start_index,
+				 int64_t num_entities,
+				 const void *var_vals);
+
+  /*  Read Edge Face or Element Variable Values Defined On Blocks or Sets at a Time Step */
+  EXODUS_EXPORT int ex_get_var(int exoid,
+			       int time_step,
+			       ex_entity_type var_type,
+			       int var_index,
+			       ex_entity_id obj_id,
+			       int64_t num_entry_this_obj,
+			       void *var_vals);
+
+  /*  Read Partial Edge Face or Element Variable Values on Blocks or Sets at a Time Step */
+  EXODUS_EXPORT int ex_get_n_var(int exoid,
+				 int time_step,
+				 ex_entity_type var_type,
+				 int var_index,
+				 ex_entity_id   obj_id,
+				 int64_t start_index,
+				 int64_t num_entities,
+				 void *var_vals);
+
+  EXODUS_EXPORT int ex_get_n_elem_var (int   exoid,
+				       int   time_step,
+				       int   elem_var_index,
+				       ex_entity_id elem_blk_id,
+				       int64_t num_elem_this_blk,
+				       int64_t start_elem_num,
+				       int64_t num_elem,
+				       void *elem_var_vals);
+
+  EXODUS_EXPORT int ex_get_partial_var(int exoid,
+				 int time_step,
+				 ex_entity_type var_type,
+				 int var_index,
+				 ex_entity_id   obj_id,
+				 int64_t start_index,
+				 int64_t num_entities,
+				 void *var_vals);
+
+  EXODUS_EXPORT int ex_get_partial_elem_var (int   exoid,
+				       int   time_step,
+				       int   elem_var_index,
+				       ex_entity_id elem_blk_id,
+				       int64_t num_elem_this_blk,
+				       int64_t start_elem_num,
+				       int64_t num_elem,
+				       void *elem_var_vals);
+
+  /*  Read Edge Face or Element Variable Values Defined On Blocks or Sets Through Time */
+  EXODUS_EXPORT int ex_get_var_time(int exoid,
+				    ex_entity_type var_type,
+				    int var_index,
+				    int64_t id,
+				    int beg_time_step,
+				    int end_time_step,
+				    void *var_vals);
+
+  EXODUS_EXPORT int ex_cvt_nodes_to_sides(int exoid,
+					  void_int *num_elem_per_set,
+					  void_int *num_nodes_per_set,
+					  void_int *side_sets_elem_index,
+					  void_int *side_sets_node_index,
+					  void_int *side_sets_elem_list,
+					  void_int *side_sets_node_list,
+					  void_int *side_sets_side_list);
+
+  /* Can be replaced by ex_put_var ... */
+  EXODUS_EXPORT int ex_put_nodal_var (int   exoid,
+				      int   time_step,
+				      int   nodal_var_index,
+				      int64_t   num_nodes, 
+				      const void *nodal_var_vals);
+
+  EXODUS_EXPORT int ex_put_n_nodal_var (int   exoid,
+					int   time_step,
+					int   nodal_var_index,
+					int64_t   start_node, 
+					int64_t   num_nodes, 
+					const void *nodal_var_vals);
+
+  EXODUS_EXPORT int ex_put_partial_nodal_var (int   exoid,
+					int   time_step,
+					int   nodal_var_index,
+					int64_t   start_node, 
+					int64_t   num_nodes, 
+					const void *nodal_var_vals);
+
+  EXODUS_EXPORT int ex_get_partial_elem_map (int   exoid,
+					     ex_entity_id   map_id,
+					     int64_t ent_start,
+					     int64_t ent_count, 
+					     void_int  *elem_map);
+
+  EXODUS_EXPORT int ex_put_partial_elem_map (int   exoid,
+					     ex_entity_id   map_id,
+					     int64_t ent_start,
+					     int64_t ent_count, 
+					     const void_int  *elem_map);
+
+  EXODUS_EXPORT int ex_put_partial_num_map (int   exoid,
+					    ex_entity_type map_type,
+					    ex_entity_id   map_id,
+					    int64_t ent_start,
+					    int64_t ent_count, 
+					    const void_int  *map);
+
+  EXODUS_EXPORT int ex_put_partial_set_dist_fact (int   exoid,
+						  ex_entity_type set_type,
+						  ex_entity_id   set_id,
+						  int64_t   offset,
+						  int64_t   num_to_put,
+						  const void *set_dist_fact);
+
+  /* TODO */
+  EXODUS_EXPORT int ex_get_concat_side_set_node_count(int exoid,
+						      int *side_set_node_cnt_list);
+
+  /* TODO */
+  EXODUS_EXPORT int ex_get_side_set_node_list_len(int exoid,
+						  ex_entity_id side_set_id,
+						  void_int *side_set_node_list_len);
+
+  /* TODO */
+  EXODUS_EXPORT int ex_get_side_set_node_count(int exoid,
+					       ex_entity_id side_set_id,
+					       int *side_set_node_cnt_list);
+
+  /* TODO */
+  EXODUS_EXPORT int ex_get_side_set_node_list(int exoid,
+					      ex_entity_id side_set_id,
+					      void_int *side_set_node_cnt_list,
+					      void_int *side_set_node_list);
+
+  /* ========================================================================
+     Functions pulled from nemesis library and incorporated into exodus...
+  */
+/*=============================================================================
+ *     Initial Information Routines
+ *===========================================================================*/
+EXODUS_EXPORT int
+ex_get_init_info(int   exoid,		/* NemesisI file ID */
+                 int  *num_proc,	/* Number of processors */
+                 int  *num_proc_in_f,	/* Number of procs in this file */
+                 char *ftype
+                 );
+
+EXODUS_EXPORT int
+ex_put_init_info(int   exoid,		/* NemesisI file ID */
+                 int   num_proc,	/* Number of processors */
+                 int   num_proc_in_f,	/* Number of procs in this file */
+                 char *ftype
+                 );
+
+EXODUS_EXPORT int
+ex_get_init_global(int   exoid, 		  /* NemesisI file ID */
+                   void_int  *num_nodes_g,	  /* Number of global FEM nodes */
+                   void_int  *num_elems_g,	  /* Number of global FEM elements */
+                   void_int  *num_elem_blks_g, /* Number of global elem blocks */
+                   void_int  *num_node_sets_g, /* Number of global node sets */
+                   void_int  *num_side_sets_g  /* Number of global side sets */
+                   );
+EXODUS_EXPORT int
+ex_put_init_global(int exoid, 		/* NemesisI file ID */
+                   int64_t num_nodes_g,	/* Number of global FEM nodes */
+                   int64_t num_elems_g,	/* Number of global FEM elements */
+                   int64_t num_elem_blks_g,	/* Number of global elem blocks */
+                   int64_t num_node_sets_g,	/* Number of global node sets */
+                   int64_t num_side_sets_g	/* Number of global side sets */
+                   );
+
+/*=============================================================================
+ *     Loadbalance Parameter Routines
+ *===========================================================================*/
+EXODUS_EXPORT int
+ex_get_loadbal_param(int   exoid, 	/* NetCDF/Exodus file ID */
+                     void_int  *num_int_nodes,  /* Number of internal FEM nodes */
+                     void_int  *num_bor_nodes,  /* Number of border FEM nodes */
+                     void_int  *num_ext_nodes,  /* Number of external FEM nodes */
+                     void_int  *num_int_elems,  /* Number of internal FEM elems */
+                     void_int  *num_bor_elems,  /* Number of border FEM elems */
+                     void_int  *num_node_cmaps, /* Number of nodal comm maps */
+                     void_int  *num_elem_cmaps, /* Number of elemental comm maps */
+                     int   processor         /* Processor ID */
+                     );
+
+EXODUS_EXPORT int
+ex_put_loadbal_param(int   exoid, 	  /* NemesisI file ID  */
+                     int64_t   num_int_nodes, /* Number of internal FEM nodes */
+                     int64_t   num_bor_nodes, /* Number of border FEM nodes */
+                     int64_t   num_ext_nodes, /* Number of external FEM nodes */
+                     int64_t   num_int_elems, /* Number of internal FEM elems */
+                     int64_t   num_bor_elems, /* Number of border FEM elems */
+                     int64_t   num_node_cmaps,/* Number of nodal comm maps */
+                     int64_t   num_elem_cmaps,/* Number of elemental comm maps */
+                     int       processor	  /* Processor ID */
+                     );
+
+EXODUS_EXPORT int
+ex_put_loadbal_param_cc(int   exoid,		/* NetCDF/Exodus file ID */
+                        void_int  *num_int_nodes,  /* Number of internal node IDs */
+                        void_int  *num_bor_nodes,  /* Number of border node IDs */
+                        void_int  *num_ext_nodes,  /* Number of external node IDs */
+                        void_int  *num_int_elems,  /* Number of internal elem IDs */
+                        void_int  *num_bor_elems,  /* Number of border elem IDs */
+                        void_int  *num_node_cmaps, /* Number of nodal comm maps */
+                        void_int  *num_elem_cmaps  /* Number of elem comm maps */
+                        );
+
+/*=============================================================================
+ *     NS, SS & EB Global Parameter Routines
+ *===========================================================================*/
+EXODUS_EXPORT int
+ex_get_ns_param_global(int exoid,	         /* NetCDF/Exodus file ID */
+                       void_int *ns_ids_glob,    /* Global IDs of node sets */
+                       void_int *ns_n_cnt_glob,  /* Count of nodes in node sets */
+                       void_int *ns_df_cnt_glob  /* Count of dist. factors in ns */
+                       );
+
+EXODUS_EXPORT int
+ex_put_ns_param_global(int exoid, 	         /* NemesisI file ID */
+                       void_int *global_ids,	 /* Vector of global node-set IDs */
+                       void_int *global_n_cnts,  /* Vector of node counts in node-sets */
+                       void_int *global_df_cnts  /* Vector of dist factor counts in node-sets */
+                       );
+
+EXODUS_EXPORT int
+ex_get_ss_param_global(int exoid,	    /* NetCDF/Exodus file ID */
+                       void_int *ss_ids_glob,    /* Global side-set IDs */
+                       void_int *ss_s_cnt_glob,  /* Global side count */
+                       void_int *ss_df_cnt_glob  /* Global dist. factor count */
+                       );
+
+EXODUS_EXPORT int
+ex_put_ss_param_global(int exoid, 	    /* NemesisI file ID */
+                       void_int *global_ids,	    /* Vector of global side-set IDs */
+                       void_int *global_el_cnts, /* Vector of element/side */
+					    /* counts in each side set */
+                       void_int *global_df_cnts  /* Vector of dist. factor */
+					    /* counts in each side set */
+                       );
+
+EXODUS_EXPORT int
+ex_get_eb_info_global(int exoid,		/* NemesisI file ID                 */
+                      void_int *el_blk_ids,	/* Vector of global element IDs     */
+                      void_int *el_blk_cnts	/* Vector of global element counts  */
+                      );
+
+EXODUS_EXPORT int
+ex_put_eb_info_global(int exoid,		/* NemesisI file ID */
+                      void_int *el_blk_ids,	/* Vector of global element IDs     */
+                      void_int *el_blk_cnts	/* Vector of global element counts  */
+                      );
+
+/*=============================================================================
+ *     NS, SS & EB Subset Routines
+ *===========================================================================*/
+EXODUS_EXPORT int
+ex_get_n_side_set(int  exoid,		    /* NetCDF/Exodus file ID */
+                  ex_entity_id side_set_id,	    /* Side-set ID to read */
+                  int64_t  start_side_num,      /* Starting element number */
+                  int64_t  num_sides,	    /* Number of sides to read */
+                  void_int *side_set_elem_list,  /* List of element IDs */
+                  void_int *side_set_side_list   /* List of side IDs */
+                  );
+
+EXODUS_EXPORT int
+ex_put_n_side_set(int  exoid,                /* NetCDF/Exodus file ID */
+                  ex_entity_id side_set_id,         /* Side-set ID to write */
+                  int64_t  start_side_num,      /* Starting element number */
+                  int64_t  num_sides,           /* Number of sides to write */
+                  const void_int *side_set_elem_list,  /* List of element IDs */
+                  const void_int *side_set_side_list   /* List of side IDs */
+                  );
+
+EXODUS_EXPORT int
+ex_get_n_side_set_df(int   exoid,		/* NetCDF/Exodus file ID */
+                     ex_entity_id   side_set_id,		/* Side-set ID */
+                     int64_t   start_num,		/* Starting df number */
+                     int64_t   num_df_to_get,	/* Number of df's to read */
+                     void *side_set_df 		/* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_put_n_side_set_df(int   exoid,                /* NetCDF/Exodus file ID */
+                     ex_entity_id   side_set_id,         /* Side-set ID */
+                     int64_t   start_num,           /* Starting df number */
+                     int64_t   num_df_to_get,       /* Number of df's to write */
+                     void *side_set_df          /* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_get_n_node_set(int  exoid,		   /* NetCDF/Exodus file ID */
+                  ex_entity_id  node_set_id,	   /* Node set ID */
+                  int64_t  start_node_num,	   /* Node index to start reading at */
+                  int64_t  num_node,	   /* Number of nodes to read */
+                  void_int *node_set_node_list  /* List of nodes in node set */
+                  );
+
+EXODUS_EXPORT int
+ex_put_n_node_set(int  exoid,		   /* NetCDF/Exodus file ID */
+                  ex_entity_id  node_set_id,	   /* Node set ID */
+                  int64_t  start_node_num,	   /* Node index to start writing at */
+                  int64_t  num_node,	   /* Number of nodes to write */
+                  const void_int *node_set_node_list  /* List of nodes in node set */
+                  );
+
+EXODUS_EXPORT int
+ex_get_n_node_set_df(int   exoid,		/* NetCDF/Exodus file ID */
+                     ex_entity_id   node_set_id,		/* Node-set ID */
+                     int64_t   start_num,		/* Starting df number */
+                     int64_t   num_df_to_get,	/* Number of df's to read */
+                     void *node_set_df 		/* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_put_n_node_set_df(int   exoid,		/* NetCDF/Exodus file ID */
+                     ex_entity_id   node_set_id,		/* Node-set ID */
+                     int64_t   start_num,		/* Starting df number */
+                     int64_t   num_df_to_get,	/* Number of df's to write */
+                     void *node_set_df 		/* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_get_n_elem_conn (int   exoid,		  /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,	  /* Element block ID */
+                    int64_t   start_elem_num, /* Starting position to read from */
+                    int64_t   num_elems,	  /* Number of elements to read */
+                    void_int  *connect	  /* Connectivity vector */
+                    );
+
+EXODUS_EXPORT int
+ex_put_n_elem_conn (int   exoid,           /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,    /* Element block ID */
+                    int64_t   start_elem_num, /* Starting position to write to */
+                    int64_t   num_elems,      /* Number of elements to write */
+                    const void_int  *connect         /* Connectivity vector */
+);
+
+EXODUS_EXPORT int
+ex_get_n_elem_attr (int   exoid,		   /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,	   /* Element block ID */
+                    int64_t   start_elem_num,  /* Starting position to read from */
+                    int64_t   num_elems,	   /* Number of elements to read */
+                    void *attrib	   /* Attribute */
+                    );
+
+EXODUS_EXPORT int
+ex_put_n_elem_attr (int   exoid,            /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,     /* Element block ID */
+                    int64_t   start_elem_num,  /* Starting position to write to */
+                    int64_t   num_elems,       /* Number of elements to write */
+                    void *attrib           /* Attribute */
+                    );
+EXODUS_EXPORT int
+ex_get_partial_side_set(int  exoid,		    /* NetCDF/Exodus file ID */
+                  ex_entity_id side_set_id,	    /* Side-set ID to read */
+                  int64_t  start_side_num,      /* Starting element number */
+                  int64_t  num_sides,	    /* Number of sides to read */
+                  void_int *side_set_elem_list,  /* List of element IDs */
+                  void_int *side_set_side_list   /* List of side IDs */
+                  );
+
+EXODUS_EXPORT int
+ex_put_partial_side_set(int  exoid,                /* NetCDF/Exodus file ID */
+                  ex_entity_id side_set_id,         /* Side-set ID to write */
+                  int64_t  start_side_num,      /* Starting element number */
+                  int64_t  num_sides,           /* Number of sides to write */
+                  const void_int *side_set_elem_list,  /* List of element IDs */
+                  const void_int *side_set_side_list   /* List of side IDs */
+                  );
+
+EXODUS_EXPORT int
+ex_get_partial_side_set_df(int   exoid,		/* NetCDF/Exodus file ID */
+                     ex_entity_id   side_set_id,		/* Side-set ID */
+                     int64_t   start_num,		/* Starting df number */
+                     int64_t   num_df_to_get,	/* Number of df's to read */
+                     void *side_set_df 		/* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_put_partial_side_set_df(int   exoid,                /* NetCDF/Exodus file ID */
+                     ex_entity_id   side_set_id,         /* Side-set ID */
+                     int64_t   start_num,           /* Starting df number */
+                     int64_t   num_df_to_get,       /* Number of df's to write */
+                     void *side_set_df          /* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_get_partial_node_set(int  exoid,		   /* NetCDF/Exodus file ID */
+                  ex_entity_id  node_set_id,	   /* Node set ID */
+                  int64_t  start_node_num,	   /* Node index to start reading at */
+                  int64_t  num_node,	   /* Number of nodes to read */
+                  void_int *node_set_node_list  /* List of nodes in node set */
+                  );
+
+EXODUS_EXPORT int
+ex_put_partial_node_set(int  exoid,		   /* NetCDF/Exodus file ID */
+                  ex_entity_id  node_set_id,	   /* Node set ID */
+                  int64_t  start_node_num,	   /* Node index to start writing at */
+                  int64_t  num_node,	   /* Number of nodes to write */
+                  const void_int *node_set_node_list  /* List of nodes in node set */
+                  );
+
+EXODUS_EXPORT int
+ex_get_partial_node_set_df(int   exoid,		/* NetCDF/Exodus file ID */
+                     ex_entity_id   node_set_id,		/* Node-set ID */
+                     int64_t   start_num,		/* Starting df number */
+                     int64_t   num_df_to_get,	/* Number of df's to read */
+                     void *node_set_df 		/* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_put_partial_node_set_df(int   exoid,		/* NetCDF/Exodus file ID */
+                     ex_entity_id   node_set_id,		/* Node-set ID */
+                     int64_t   start_num,		/* Starting df number */
+                     int64_t   num_df_to_get,	/* Number of df's to write */
+                     void *node_set_df 		/* Distribution factors */
+                     );
+
+EXODUS_EXPORT int
+ex_get_partial_elem_conn (int   exoid,		  /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,	  /* Element block ID */
+                    int64_t   start_elem_num, /* Starting position to read from */
+                    int64_t   num_elems,	  /* Number of elements to read */
+                    void_int  *connect	  /* Connectivity vector */
+                    );
+
+EXODUS_EXPORT int
+ex_put_partial_elem_conn (int   exoid,           /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,    /* Element block ID */
+                    int64_t   start_elem_num, /* Starting position to write to */
+                    int64_t   num_elems,      /* Number of elements to write */
+                    const void_int  *connect         /* Connectivity vector */
+);
+
+EXODUS_EXPORT int
+ex_get_partial_elem_attr (int   exoid,		   /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,	   /* Element block ID */
+                    int64_t   start_elem_num,  /* Starting position to read from */
+                    int64_t   num_elems,	   /* Number of elements to read */
+                    void *attrib	   /* Attribute */
+                    );
+
+EXODUS_EXPORT int
+ex_put_partial_elem_attr (int   exoid,            /* NetCDF/Exodus file ID */
+                    ex_entity_id   elem_blk_id,     /* Element block ID */
+                    int64_t   start_elem_num,  /* Starting position to write to */
+                    int64_t   num_elems,       /* Number of elements to write */
+                    void *attrib           /* Attribute */
+                    );
+
+EXODUS_EXPORT int
+ex_get_elem_type(int   exoid,            /* NetCDF/Exodus file ID */
+                 ex_entity_id   elem_blk_id,     /* Element block ID */
+                 char *elem_type        /* The name of the element type */
+                 );
+
+/*=============================================================================
+ *     Variable Routines
+ *===========================================================================*/
+EXODUS_EXPORT int
+ex_put_elem_var_slab (int   exoid,           /* NetCDF/Exodus file ID */
+                      int   time_step,      /* time index */
+                      int   elem_var_index, /* elemental variable index */
+                      ex_entity_id   elem_blk_id,    /* elemental block id */
+                      int64_t   start_pos,      /* Starting position to write to */
+                      int64_t   num_vals,       /* Number of elements to write */
+                      void *elem_var_vals   /* variable values */
+                      );
+
+EXODUS_EXPORT int
+ex_put_nodal_var_slab(int   exoid,            /* NetCDF/Exodus file ID */
+                      int   time_step,       /* The time step index */
+                      int   nodal_var_index, /* Nodal variable index */
+                      int64_t   start_pos,       /* Start position for write */
+                      int64_t   num_vals,        /* Number of nodal variables */
+                      void *nodal_var_vals   /* Nodal variable values */
+                      );
+
+/*=============================================================================
+ *     Number Map Routines
+ *===========================================================================*/
+EXODUS_EXPORT int
+ex_get_n_elem_num_map (int  exoid,           /* NetCDF/Exodus file ID */
+                       int64_t  start_ent,      /* Starting position to read from */
+                       int64_t  num_ents,       /* Number of elements to read */
+                       void_int *elem_map        /* element map numbers */
+                       );
+
+EXODUS_EXPORT int
+ex_get_n_node_num_map(int   exoid,	     /* NetCDF/Exodus file ID */
+                      int64_t   start_ent,       /* starting node number */
+                      int64_t   num_ents,        /* number of nodes to read */
+                      void_int  *node_map         /* vector for node map */
+                      );
+
+EXODUS_EXPORT int
+ex_get_partial_elem_num_map (int  exoid,           /* NetCDF/Exodus file ID */
+                       int64_t  start_ent,      /* Starting position to read from */
+                       int64_t  num_ents,       /* Number of elements to read */
+                       void_int *elem_map        /* element map numbers */
+                       );
+
+EXODUS_EXPORT int
+ex_get_partial_node_num_map(int   exoid,	     /* NetCDF/Exodus file ID */
+                      int64_t   start_ent,       /* starting node number */
+                      int64_t   num_ents,        /* number of nodes to read */
+                      void_int  *node_map         /* vector for node map */
+                      );
+
+EXODUS_EXPORT int
+ex_get_processor_node_maps(int   exoid,		/* NetCDF/Exodus file ID */
+			   void_int  *node_mapi,	/* Internal FEM node IDs */
+			   void_int  *node_mapb,	/* Border FEM node IDs */
+			   void_int  *node_mape,	/* External FEM node IDs */
+			   int   processor		/* Processor IDs */
+			   );
+
+EXODUS_EXPORT int
+ex_put_processor_node_maps(int   exoid,		/* NetCDF/Exodus file ID */
+			   void_int  *node_mapi,	/* Internal FEM node IDs */
+			   void_int  *node_mapb,	/* Border FEM node IDs */
+			   void_int  *node_mape,	/* External FEM node IDs */
+			   int   processor		/* This processor ID */
+			   );
+
+EXODUS_EXPORT int
+ex_get_processor_elem_maps(int   exoid,		/* NetCDF/Exodus file ID */
+			   void_int  *elem_mapi,	/* Internal element IDs */
+			   void_int  *elem_mapb,	/* Border element IDs */
+			   int   processor		/* Processor ID */
+			   );
+
+EXODUS_EXPORT int
+ex_put_processor_elem_maps(int   exoid,		/* NetCDF/Exodus file ID */
+			   void_int  *elem_mapi,	/* Internal FEM element IDs */
+			   void_int  *elem_mapb,	/* Border FEM element IDs */
+			   int   processor		/* This processor ID */
+			   );
+
+
+/*=============================================================================
+ *     Communications Maps Routines
+ *===========================================================================*/
+
+EXODUS_EXPORT int
+ex_get_cmap_params(int exoid,                  /* NetCDF/Exodus file ID */
+                   void_int *node_cmap_ids,        /* Nodal comm. map IDs */
+                   void_int *node_cmap_node_cnts,  /* Number of nodes in each map */
+                   void_int *elem_cmap_ids,        /* Elemental comm. map IDs */
+                   void_int *elem_cmap_elem_cnts,  /* Number of elems in each map */
+                   int  processor             /* This processor ID */
+                   );
+
+EXODUS_EXPORT int
+ex_put_cmap_params(int  exoid,			/* NetCDF/Exodus file ID */
+                   void_int *node_map_ids,	/* Node map IDs */
+                   void_int *node_map_node_cnts,/* Nodes in nodal comm */
+                   void_int *elem_map_ids,	/* Elem map IDs */
+                   void_int *elem_map_elem_cnts,/* Elems in elemental comm */
+                   int64_t   processor		/* This processor ID */
+                   );
+
+EXODUS_EXPORT int
+ex_put_cmap_params_cc(int  exoid,		/* NetCDF/Exodus file ID */
+                      void_int *node_map_ids,	/* Node map IDs */
+                      void_int *node_map_node_cnts,	/* Nodes in nodal comm */
+                      void_int *node_proc_ptrs,      /* Pointer into array for */
+						/* node maps		  */
+                      void_int *elem_map_ids,	/* Elem map IDs */
+                      void_int *elem_map_elem_cnts,	/* Elems in elemental comm */
+                      void_int *elem_proc_ptrs	/* Pointer into array for */
+						/* elem maps		  */
+                      );
+
+EXODUS_EXPORT int
+ex_get_node_cmap(int  exoid,             /* NetCDF/Exodus file ID */
+                 ex_entity_id  map_id,           /* Map ID */
+                 void_int *node_ids,         /* FEM node IDs */
+                 void_int *proc_ids,         /* Processor IDs */
+                 int  processor         /* This processor ID */
+                 );
+
+EXODUS_EXPORT int
+ex_put_node_cmap(int  exoid,	/* NetCDF/Exodus file ID */
+                 ex_entity_id  map_id,	/* Nodal comm map ID */
+                 void_int *node_ids,	/* FEM node IDs */
+                 void_int *proc_ids, /* Processor IDs */
+                 int  processor	/* This processor ID */
+                 );
+
+EXODUS_EXPORT int
+ex_get_elem_cmap(int  exoid,     /* NetCDF/Exodus file ID */
+                 ex_entity_id  map_id,   /* Elemental comm map ID */
+                 void_int *elem_ids, /* Element IDs */
+                 void_int *side_ids, /* Element side IDs */
+                 void_int *proc_ids, /* Processor IDs */
+                 int  processor /* This processor ID */
+                 );
+
+EXODUS_EXPORT int
+ex_put_elem_cmap(int  exoid,	/* NetCDF/Exodus file ID */
+                 ex_entity_id  map_id,	/* Elemental comm map ID */
+                 void_int *elem_ids,	/* Vector of element IDs */
+                 void_int *side_ids, /* Vector of side IDs */
+                 void_int *proc_ids, /* Vector of processor IDs */
+                 int  processor	/* This processor ID */
+                 );
+  
+  /* ========================================================================
+   * Deprecated functiona
+   */
+
+  EXODUS_EXPORT int ex_get_nodal_var (int   exoid,
+				      int   time_step,
+				      int   nodal_var_index,
+				      int64_t   num_nodes, 
+				      void *nodal_var_vals);
+
+  EXODUS_EXPORT int ex_get_nodal_var_time (int   exoid,
+					   int   nodal_var_index,
+					   int64_t   node_number,
+					   int   beg_time_step, 
+					   int   end_time_step,
+					   void *nodal_var_vals);
+
+  /* Use ex_get_concat_sets() */
+  EXODUS_EXPORT int ex_get_concat_node_sets (int   exoid,
+					     void_int  *node_set_ids,
+					     void_int  *num_nodes_per_set, 
+					     void_int  *num_df_per_set, 
+					     void_int  *node_sets_node_index,
+					     void_int  *node_sets_df_index,
+					     void_int  *node_sets_node_list, 
+					     void *node_sets_dist_fact);
+
+     
+  EXODUS_EXPORT int ex_get_concat_side_sets (int   exoid,
+					     void_int  *side_set_ids,
+					     void_int  *num_elem_per_set,
+					     void_int  *num_dist_per_set,
+					     void_int  *side_sets_elem_index,
+					     void_int  *side_sets_dist_index,
+					     void_int  *side_sets_elem_list,
+					     void_int  *side_sets_side_list,
+					     void *side_sets_dist_fact);
+
+  EXODUS_EXPORT int ex_get_elem_attr (int   exoid,
+				      ex_entity_id   elem_blk_id,
+				      void *attrib);
+
+  EXODUS_EXPORT int ex_get_elem_attr_names (int   exoid,
+					    ex_entity_id elem_blk_id,
+					    char **names);
+
+  EXODUS_EXPORT int ex_get_elem_blk_ids (int  exoid,
+					 void_int *ids);
+
+  EXODUS_EXPORT int ex_get_elem_block (int   exoid,
+				       ex_entity_id  elem_blk_id,
+				       char *elem_type,
+				       void_int  *num_elem_this_blk, 
+				       void_int  *num_nodes_per_elem,
+				       void_int  *num_attr);
+
+  EXODUS_EXPORT int ex_get_elem_conn (int   exoid,
+				      ex_entity_id   elem_blk_id,
+				      void_int  *connect);
+
+  EXODUS_EXPORT int ex_get_elem_map (int   exoid,
+				     ex_entity_id   map_id,
+				     void_int  *elem_map);
+
+  EXODUS_EXPORT int ex_get_elem_num_map (int  exoid,
+					 void_int *elem_map);
+
+  EXODUS_EXPORT int ex_get_elem_var (int   exoid,
+				     int   time_step,
+				     int   elem_var_index,
+				     ex_entity_id   elem_blk_id, 
+				     int64_t   num_elem_this_blk,
+				     void *elem_var_vals);
+
+  EXODUS_EXPORT int ex_get_elem_var_tab (int  exoid,
+					 int  num_elem_blk,
+					 int  num_elem_var,
+					 int *elem_var_tab);
+
+  EXODUS_EXPORT int ex_get_elem_var_time (int   exoid,
+					  int   elem_var_index,
+					  int64_t   elem_number,
+					  int   beg_time_step, 
+					  int   end_time_step,
+					  void *elem_var_vals);
+
+  EXODUS_EXPORT int ex_get_map (int  exoid, void_int *elem_map);
+
+  EXODUS_EXPORT int ex_get_node_map (int   exoid,
+				     ex_entity_id   map_id,
+				     void_int  *node_map);
+
+  EXODUS_EXPORT int ex_get_node_num_map (int  exoid,
+					 void_int *node_map);
+
+  EXODUS_EXPORT int ex_get_node_set_param (int  exoid,
+					   ex_entity_id  node_set_id,
+					   void_int *num_nodes_in_set,
+					   void_int *num_df_in_set);
+
+  EXODUS_EXPORT int ex_get_node_set (int   exoid,
+				     ex_entity_id   node_set_id,
+				     void_int  *node_set_node_list);
+
+  EXODUS_EXPORT int ex_get_node_set_dist_fact  (int   exoid,
+						ex_entity_id   node_set_id,
+						void *node_set_dist_fact);
+
+  EXODUS_EXPORT int ex_get_node_set_ids (int  exoid,
+					 void_int *ids);
+
+  EXODUS_EXPORT int ex_get_nset_var_tab (int  exoid,
+					 int  num_nodesets,
+					 int  num_nset_var,
+					 int *nset_var_tab);
+
+  EXODUS_EXPORT int ex_get_nset_var (int   exoid,
+				     int   time_step,
+				     int   nset_var_index,
+				     ex_entity_id   nset_id, 
+				     int64_t   num_node_this_nset,
+				     void *nset_var_vals);
+
+  EXODUS_EXPORT int ex_get_one_elem_attr (int   exoid,
+					  ex_entity_id   elem_blk_id,
+					  int   attrib_index,
+					  void *attrib);
+
+  EXODUS_EXPORT int ex_get_side_set (int   exoid,
+				     ex_entity_id   side_set_id,
+				     void_int  *side_set_elem_list, 
+				     void_int  *side_set_side_list);
+
+  EXODUS_EXPORT int ex_get_side_set_dist_fact (int   exoid,
+					       ex_entity_id   side_set_id,
+					       void *side_set_dist_fact);
+
+  EXODUS_EXPORT int ex_get_side_set_ids (int  exoid,
+					 void_int *ids);
+
+  EXODUS_EXPORT int ex_get_side_set_param (int  exoid,
+					   ex_entity_id  side_set_id,
+					   void_int *num_side_in_set, 
+					   void_int *num_dist_fact_in_set);
+
+  EXODUS_EXPORT int ex_get_sset_var (int   exoid,
+				     int   time_step,
+				     int   sset_var_index,
+				     ex_entity_id   sset_id, 
+				     int64_t   num_side_this_sset,
+				     void *sset_var_vals);
+
+  EXODUS_EXPORT int ex_get_sset_var_tab (int  exoid,
+					 int  num_sidesets,
+					 int  num_sset_var,
+					 int *sset_var_tab);
+
+  EXODUS_EXPORT int ex_get_var_names (int   exoid,
+				      const char *var_type,
+				      int   num_vars,
+				      char *var_names[]);
+
+  EXODUS_EXPORT int ex_get_var_name (int   exoid,
+				     const char *var_type,
+				     int   var_num,
+				     char *var_name);
+
+  EXODUS_EXPORT int ex_get_var_param (int   exoid,
+				      const char *var_type,
+				      int  *num_vars);
+
+  EXODUS_EXPORT int ex_get_var_tab (int  exoid,
+				    const char *var_type,
+				    int  num_blk,
+				    int  num_var,
+				    int *var_tab);
+
+  EXODUS_EXPORT int ex_put_concat_node_sets (int   exoid,
+					     void_int  *node_set_ids,
+					     void_int  *num_nodes_per_set,
+					     void_int  *num_dist_per_set,
+					     void_int  *node_sets_node_index,
+					     void_int  *node_sets_df_index,
+					     void_int  *node_sets_node_list,
+					     void *node_sets_dist_fact);
+
+  EXODUS_EXPORT int ex_put_concat_side_sets (int   exoid,
+					     void_int  *side_set_ids,
+					     void_int  *num_elem_per_set,
+					     void_int  *num_dist_per_set,
+					     void_int  *side_sets_elem_index,
+					     void_int  *side_sets_dist_index,
+					     void_int  *side_sets_elem_list,
+					     void_int  *side_sets_side_list,
+					     void *side_sets_dist_fact);
+
+  EXODUS_EXPORT int ex_put_concat_var_param (int exoid, int num_g, int num_n,
+					     int num_e, int num_elem_blk, int  *elem_var_tab);
+  
+  EXODUS_EXPORT int ex_put_elem_attr_names(int   exoid,
+					   ex_entity_id   elem_blk_id,
+					   char *names[]);
+  EXODUS_EXPORT int ex_put_elem_attr (int   exoid,
+				      ex_entity_id   elem_blk_id,
+				      const void *attrib);
+
+  EXODUS_EXPORT int ex_put_elem_block (int   exoid,
+				       ex_entity_id   elem_blk_id,
+				       const char *elem_type,
+				       int64_t   num_elem_this_blk,
+				       int64_t   num_nodes_per_elem,
+				       int64_t   num_attr);
+
+  EXODUS_EXPORT int ex_put_elem_conn (int   exoid,
+				      ex_entity_id   elem_blk_id,
+				      const void_int  *connect);
+
+  EXODUS_EXPORT int ex_put_elem_map (int exoid,
+				     ex_entity_id map_id,
+				     const void_int *elem_map);
+
+  EXODUS_EXPORT int ex_put_elem_num_map (int  exoid,
+					 const void_int *elem_map);
+
+  EXODUS_EXPORT int ex_put_elem_var (int   exoid,
+				     int   time_step,
+				     int   elem_var_index,
+				     ex_entity_id   elem_blk_id,
+				     int64_t num_elem_this_blk,
+				     const void *elem_var_vals);
+
+  EXODUS_EXPORT int ex_put_elem_var_tab (int  exoid,
+					 int  num_elem_blk,
+					 int  num_elem_var,
+					 int *elem_var_tab);
+
+  EXODUS_EXPORT int ex_put_glob_vars (int   exoid,
+				      int   time_step,
+				      int   num_glob_vars,
+				      const void *glob_var_vals);
+
+  EXODUS_EXPORT int ex_put_map (int  exoid,
+				const void_int *elem_map);
+
+  EXODUS_EXPORT int ex_put_node_map (int exoid,
+				     ex_entity_id map_id,
+				     const void_int *node_map);
+
+  EXODUS_EXPORT int ex_put_node_num_map (int  exoid,
+					 const void_int *node_map);
+
+  EXODUS_EXPORT int ex_put_node_set (int   exoid,
+				     ex_entity_id   node_set_id,
+				     const void_int  *node_set_node_list);
+
+  EXODUS_EXPORT int ex_put_node_set_dist_fact  (int   exoid,
+						ex_entity_id   node_set_id,
+						const void *node_set_dist_fact);
+
+  EXODUS_EXPORT int ex_put_node_set_param (int exoid,
+					   ex_entity_id node_set_id,
+					   int64_t num_nodes_in_set,
+					   int64_t num_dist_in_set);
+
+  EXODUS_EXPORT int ex_put_nset_var (int   exoid,
+				     int   time_step,
+				     int   nset_var_index,
+				     ex_entity_id   nset_id,
+				     int64_t num_nodes_this_nset,
+				     const void *nset_var_vals);
+
+  EXODUS_EXPORT int ex_put_nset_var_tab (int  exoid,
+					 int  num_nset,
+					 int  num_nset_var,
+					 int *nset_var_tab);
+
+  EXODUS_EXPORT int ex_put_one_elem_attr (int   exoid,
+					  ex_entity_id   elem_blk_id,
+					  int   attrib_index,
+					  const void *attrib);
+
+  EXODUS_EXPORT int ex_put_side_set (int   exoid,
+				     ex_entity_id   side_set_id,
+				     const void_int  *side_set_elem_list,
+				     const void_int  *side_set_side_list);
+
+  EXODUS_EXPORT int ex_put_side_set_dist_fact (int   exoid,
+					       ex_entity_id   side_set_id,
+					       const void *side_set_dist_fact);
+
+  EXODUS_EXPORT int ex_put_side_set_param (int exoid,
+					   ex_entity_id side_set_id,
+					   int64_t num_side_in_set,
+					   int64_t num_dist_fact_in_set);
+
+  EXODUS_EXPORT int ex_put_sset_var (int   exoid,
+				     int   time_step,
+				     int   sset_var_index,
+				     ex_entity_id   sset_id,
+				     int64_t  num_faces_this_sset,
+				     const void *sset_var_vals);
+
+  EXODUS_EXPORT int ex_put_sset_var_tab (int  exoid,
+					 int  num_sset,
+					 int  num_sset_var,
+					 int *sset_var_tab);
+
+  EXODUS_EXPORT int ex_put_var_name (int   exoid,
+				     const char *var_type,
+				     int   var_num,
+				     const char *var_name);
+
+  EXODUS_EXPORT int ex_put_var_names (int   exoid,
+				      const char *var_type,
+				      int   num_vars,
+				      char *var_names[]);
+
+  EXODUS_EXPORT int ex_put_var_param (int   exoid,
+				      const char *var_type,
+				      int   num_vars);
+
+  EXODUS_EXPORT int ex_put_var_tab (int  exoid,
+				    const char *var_type,
+				    int  num_blk,
+				    int  num_var,
+				    int *var_tab);
+  
+   /* End of Deprecated functions and their replacements
+    * ======================================================================== */
+
+  /* ERROR CODE DEFINITIONS AND STORAGE                                       */
+  extern int exerrval;     /**< shared error return value                */
+  extern int exoptval;     /**< error reporting flag (default is quiet)  */
+
+  char* ex_name_of_object(ex_entity_type obj_type);
+  ex_entity_type ex_var_type_to_ex_entity_type(char var_type);
+
+  /* Should be internal use only, but was in external include file for
+     nemesis and some codes are using the function
+  */
+  int ex_get_idx(int      neid,	 /* NetCDF/Exodus file ID */
+		 const char *ne_var_name, /* Nemesis index variable name */
+		 int64_t *index,	 /* array of length 2 to hold results */
+		 int      pos		 /* position of this proc/cmap in index */
+		 );
+
+
+#ifdef __cplusplus
+}                               /* close brackets on extern "C" declaration */
+#endif
+
+/**
+ * \defgroup ErrorReturnCodes Exodus error return codes - exerrval return values
+ * @{
+ */
+#define EX_MEMFAIL       1000   /**< memory allocation failure flag def       */
+#define EX_BADFILEMODE   1001   /**< bad file mode def                        */
+#define EX_BADFILEID     1002   /**< bad file id def                          */
+#define EX_WRONGFILETYPE 1003   /**< wrong file type for function             */
+#define EX_LOOKUPFAIL    1004   /**< id table lookup failed                   */
+#define EX_BADPARAM      1005   /**< bad parameter passed                     */
+#define EX_MSG          -1000   /**< message print code - no error implied    */
+#define EX_PRTLASTMSG   -1001   /**< print last error message msg code        */
+#define EX_NULLENTITY   -1006   /**< null entity found                        */
+/* @} */
+
+#endif
+
diff -ruN trilinos-11.4.3-clean/packages/seacas/libraries/exodus/cbind/include/exodusII_int.h trilinos-11.4.3/packages/seacas/libraries/exodus/cbind/include/exodusII_int.h
--- trilinos-11.4.3-clean/packages/seacas/libraries/exodus/cbind/include/exodusII_int.h	2014-02-06 15:46:52.000000000 -0700
+++ trilinos-11.4.3/packages/seacas/libraries/exodus/cbind/include/exodusII_int.h	2014-02-06 15:48:50.000000000 -0700
@@ -42,7 +42,12 @@
 #define EXODUS_II_INT_HDR
 
 #include "netcdf.h"
-#include <inttypes.h>
+#ifdef WIN32
+  typedef signed __int64 int64_t;
+  typedef int64_t ssize_t;
+#else
+  #include <inttypes.h>
+#endif
 
 #ifndef __APPLE__
 #if defined __STDC__ || defined __cplusplus
diff -ruN trilinos-11.4.3-clean/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp trilinos-11.4.3/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp
--- trilinos-11.4.3-clean/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp	2014-02-06 15:47:08.000000000 -0700
+++ trilinos-11.4.3/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp	2014-02-06 15:48:40.000000000 -0700
@@ -484,6 +484,12 @@
   : public DirectSerializationTraits<Ordinal, ptrdiff_t>
 {};
 
+template<typename Ordinal>
+class SerializationTraits<Ordinal, unsigned long long int>
+  : public DirectSerializationTraits<Ordinal, unsigned long long int>
+{};
+
+
 #endif // HAVE_TEUCHOS_LONG_LONG_INT
 
 } // namespace Teuchos
diff -ruN trilinos-11.4.3-clean/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp.orig trilinos-11.4.3/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp.orig
--- trilinos-11.4.3-clean/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/teuchos/comm/src/Teuchos_SerializationTraits.hpp.orig	2013-11-21 13:11:07.000000000 -0700
@@ -0,0 +1,491 @@
+// @HEADER
+// ***********************************************************************
+//
+//                    Teuchos: Common Tools Package
+//                 Copyright (2004) Sandia Corporation
+//
+// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
+// license for use of this work by or on behalf of the U.S. Government.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// 1. Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the Corporation nor the names of the
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Questions? Contact Michael A. Heroux (maherou@sandia.gov)
+//
+// ***********************************************************************
+// @HEADER
+
+/// \file Teuchos_SerializationTraits.hpp
+/// \brief Teuchos::SerializationTraits and Teuchos::DirectSerializationTraits definitions.
+///
+#ifndef TEUCHOS_SERIALIZATION_TRAITS_HPP
+#define TEUCHOS_SERIALIZATION_TRAITS_HPP
+
+#include "Teuchos_ConfigDefs.hpp"
+#include <climits> // SIZE_MAX, ULONG_MAX, etc.
+
+#ifdef HAVE_TEUCHOS_QD
+#include <qd/dd_real.h>
+#include <qd/qd_real.h>
+#endif
+
+namespace Teuchos {
+
+/// \class UndefinedSerializationTraits
+/// \brief Report an error if a specialization of \c SerializationTraits is missing.
+/// 
+/// This class reports a compile-time error if you attempt to
+/// instantiate it.  We use this class to make it easy to detect a
+/// missing specialization of \c SerializationTraits.
+template<typename T>
+struct UndefinedSerializationTraits {
+  //! This function should not compile if there is an attempt to instantiate!
+  static inline T notDefined() {return(T::this_type_is_missing_a_specialization());}
+};
+
+
+/** \class SerializationTraits 
+ * \brief Serialization traits class for types T that use value semantics.
+ *
+ * This traits class describes how to convert between arrays of T, and
+ * arrays of char.  We call the process of converting from T to char
+ * "serialization," and from char to T "deserialization."  Teuchos
+ * uses serialization and deserialization mainly for implementing
+ * distributed-memory message-passing communication in a generic way.
+ *
+ * \tparam Ordinal The same template parameter as that of \c Comm.
+ *   The integer type used to count the number of packets sent and
+ *   received.
+ *
+ * \tparam T The type of the objects that this class shows how to
+ *   serialize.  
+ *
+ * Teuchos defines specializations of this class for many commonly
+ * used types in distributed-memory communication, such as char, int
+ * (signed and unsigned), float, double, and std::pair<P1, P2> for
+ * certain types P1 and P2.  Depending on your Trilinos build options,
+ * other specializations may be defined as well, for example for long
+ * long int, double-double and quad-double real types (dd_real
+ * resp. qd_real), or certain std::complex<T> specializations.  If a
+ * specialization of this class does not exist for your type T, you
+ * may define your own specialization.
+ *
+ * \note Before defining specializations of this class, make sure that
+ *   they do not duplicate specializations already present in
+ *   PyTrilinos (see packages/PyTrilinos/src/Teuchos_Traits.i)
+ * 
+ * There are two different serialization modes: direct and indirect.
+ * "Direct" serialization means that you can convert directly between
+ * an object of type T and an array of char, of a specific length
+ * dependent only on the type T and not on the particular instance.
+ * Specifically, it means you can
+ *
+ * 1. reinterpret_cast a pointer to an instance of T into an array of
+ *    char (which array has length dependent only on the type T and
+ *    not on the specific T instance),
+ * 2. serialize the resulting array of char, and finally
+ * 3. deserialize by reading in the array of char and doing a
+ *    reinterpret_cast back into a T.
+ *
+ * "Indirect" serialization is defined as any serialization method
+ * more general than that.  The \c supportsDirectSerialization class
+ * Boolean tells you whether this specialization supports direct
+ * serialization.
+ *
+ * SerializationTraits is used by classes such as \c
+ * ValueTypeSerializationBuffer, \c ConstValueTypeSerializationBuffer,
+ * \c ValueTypeDeserializationBuffer, and \c
+ * ConstValueTypeDeserializationBuffer.
+ */
+template <typename Ordinal, typename T>
+class SerializationTraits {
+public:
+  
+  //! @name Serialization type selection 
+  //@{
+
+  /// \brief Whether the type T supports direct serialization.
+  ///
+  /// See the class documentation for definitions of "direct" and
+  /// "indirect" serialization.
+  static const bool supportsDirectSerialization = false;
+
+  //@}
+
+  //! @name Direct serialization functions (not defined if supportsDirectSerialization==false) 
+  //@{
+
+  /** \brief Return the number of bytes for <tt>count</tt> objects. */
+  static Ordinal fromCountToDirectBytes(const Ordinal count) { 
+    (void)count; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Convert the pointer type to <tt>char*</tt>. */
+  static char* convertToCharPtr( T* ptr ) { 
+    (void)ptr; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Convert the pointer type to <tt>const char*</tt>. */
+  static const char* convertToCharPtr( const T* ptr ) { 
+    (void)ptr; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Return the number of objects for <tt>bytes</tt> of storage. */
+  static Ordinal fromDirectBytesToCount(const Ordinal bytes) { 
+    (void)bytes; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Convert the pointer type from <tt>char*</tt>. */
+  static T* convertFromCharPtr( char* ptr ) { 
+    (void)ptr; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Convert the pointer type from <tt>char*</tt>. */
+  static const T* convertFromCharPtr( const char* ptr ) { 
+    (void)ptr; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  //@}
+
+  //! @name Indirect serialization functions (always defined and supported) 
+  //@{
+
+  /** \brief Return the number of bytes for <tt>count</tt> objects. */
+  static Ordinal fromCountToIndirectBytes(const Ordinal count, 
+					  const T buffer[]) { 
+    (void)count; (void)buffer; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Serialize to an indirect <tt>char[]</tt> buffer.
+   *
+   * \param  count
+   *           [in] The number of objects to serialize.
+   * \param  buffer
+   *           [in] The objects to serialize.
+   * \param  bytes
+   *           [in] Number of bytes in <tt>charBuffer[]</tt>
+   * \param  charBuffer
+   *           [out] Array (length <tt>bytes</tt>) containing the serialized objects.
+   *
+   * <b>Preconditions:</b><ul>
+   * <li><tt>bytes==fromCountToIndirectBytes(count)</tt>
+   * </ul>
+   */
+  static void serialize (const Ordinal count, 
+			 const T buffer[], 
+			 const Ordinal bytes, 
+			 char charBuffer[])
+  { 
+    (void)count; (void)buffer; (void)bytes; (void)charBuffer; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+  }
+
+  /** \brief Return the number of objects for <tt>bytes</tt> of storage. */
+  static Ordinal fromIndirectBytesToCount(const Ordinal bytes, 
+					  const char charBuffer[]) { 
+    (void)bytes; (void)charBuffer; 
+    UndefinedSerializationTraits<T>::notDefined(); 
+    return 0; 
+  }
+
+  /** \brief Deserialize from an indirect <tt>char[]</tt> buffer.
+   *
+   * \param  bytes
+   *           [in] Number of bytes in <tt>charBuffer[]</tt>
+   * \param  charBuffer
+   *           [in] Array (length <tt>bytes</tt>) containing the serialized objects.
+   * \param  count
+   *           [in] The number of objects to deserialize.
+   * \param  buffer
+   *           [out] The deserialized objects.
+   
+   * <b>Preconditions:</b><ul>
+   * <li><tt>count==fromIndirectBytesToCount(bytes)</tt>
+   * </ul>
+   */
+  static void deserialize (const Ordinal bytes, 
+			   const char charBuffer[], 
+			   const Ordinal count, 
+			   T buffer[])
+  { 
+    (void)bytes; (void)charBuffer; (void)count; (void)buffer;
+    UndefinedSerializationTraits<T>::notDefined(); 
+  }
+  
+  //@}
+
+};
+
+/** \class ValueTypeSerializer
+ * \brief Serialization class for types T that use value semantics.
+ *
+ * This works similarly to SerializationTraits, except that it provides
+ * a class that can be specialized for types T to implement serialization
+ * through an object instead of a traits class.  Some types need other data
+ * to help them serialize, and that data can be encapsulated into a non-static
+ * specialization of this class.
+ *
+ * The default implementation is just given by the SerializationTraits for the
+ * type T, and thus this class will be defined for any type that defines its
+ * SerializationTraits.
+ */
+template <typename Ordinal, typename T>
+class ValueTypeSerializer : public Teuchos::SerializationTraits<Ordinal,T> {};
+
+/// \class DirectSerializationTraits
+/// \brief Serialization traits for objects that support direct serialization.
+///
+/// "Direct" serialization means that you can convert directly
+/// between an object of type T and an array of char, of a specific
+/// length dependent only on the type T and not on the particular
+/// instance.  Specifically, it means you can
+///
+/// 1. reinterpret_cast a pointer to an instance of T into an 
+///    array of char (which array has length dependent only on 
+///    the type T and not on the specific T instance),
+/// 2. serialize the resulting array of char, and finally
+/// 3. deserialize by reading in the array of char and doing a 
+///    reinterpret_cast back into a T.
+///
+/// "Indirect" serialization is defined as any serialization method
+/// more general than that.
+///
+/// We use partial specializations of DirectSerializationTraits
+/// (specialized on certain T types, not Ordinal) as public base
+/// classes for the corresponding SerializationTraits specialization.
+/// This provides high-performance default implementations of
+/// serialization for commonly used types T (including char, int, and
+/// double).
+///
+/// \tparam Ordinal The same template parameter as that of \c Comm.
+///   The integer type used to count the number of packets sent and
+///   received.
+///
+/// \tparam T The type of the objects that this class shows how to
+///   serialize.  
+///
+template <typename Ordinal, typename T>
+class DirectSerializationTraits {
+public:
+  static const bool supportsDirectSerialization = true;
+  // Direct serialization
+  static Ordinal fromCountToDirectBytes(const Ordinal count)
+    { return sizeof(T)*count; }
+  static char* convertToCharPtr( T* ptr )
+    { return reinterpret_cast<char*>(ptr); }
+  static const char* convertToCharPtr( const T* ptr )
+    { return reinterpret_cast<const char*>(ptr); }
+  static Ordinal fromDirectBytesToCount(const Ordinal count)
+    { return count/sizeof(T); }
+  static T* convertFromCharPtr( char* ptr )
+    { return reinterpret_cast<T*>(ptr); }
+  static const T* convertFromCharPtr( const char* ptr )
+    { return reinterpret_cast<const T*>(ptr); }
+  // Indirect serialization
+  static Ordinal fromCountToIndirectBytes(const Ordinal count, const T buffer[])
+    { return fromCountToDirectBytes(count); }
+  static void serialize(
+    const Ordinal count, const T buffer[], const Ordinal bytes, char charBuffer[]
+    )
+    {
+#ifdef TEUCHOS_DEBUG
+      TEUCHOS_TEST_FOR_EXCEPT(bytes!=fromCountToDirectBytes(count));
+#endif
+      const char *_buffer = convertToCharPtr(buffer);
+      std::copy(_buffer,_buffer+bytes,charBuffer);
+    }
+  static Ordinal fromIndirectBytesToCount(const Ordinal bytes, 
+					  const char charBuffer[]) 
+    { return fromDirectBytesToCount(bytes); }
+  static void deserialize(
+    const Ordinal bytes, const char charBuffer[], const Ordinal count, T buffer[]
+    )
+    {
+#ifdef TEUCHOS_DEBUG
+      TEUCHOS_TEST_FOR_EXCEPT(count!=fromDirectBytesToCount(bytes));
+#endif
+      char *_buffer = convertToCharPtr(buffer);
+      std::copy(charBuffer,charBuffer+bytes,_buffer);
+    }
+};
+
+// Whether 'char' is signed or unsigned depends on the implementation.
+// However, on some systems (e.g., Clang 3.1 on Intel Mac), partially
+// specializing for signed char and unsigned char, but not for char,
+// does not work.  Thus, we include specializations for all three
+// possibilities.
+template<typename Ordinal>
+class SerializationTraits<Ordinal,char>
+  : public DirectSerializationTraits<Ordinal,char>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,signed char>
+  : public DirectSerializationTraits<Ordinal,signed char>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,unsigned char>
+  : public DirectSerializationTraits<Ordinal,unsigned char>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,short int>
+  : public DirectSerializationTraits<Ordinal,short int>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,unsigned short int>
+  : public DirectSerializationTraits<Ordinal,unsigned short int>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,int>
+  : public DirectSerializationTraits<Ordinal,int>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,unsigned int>
+  : public DirectSerializationTraits<Ordinal,unsigned int>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,long int>
+  : public DirectSerializationTraits<Ordinal,long int>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,unsigned long int>
+  : public DirectSerializationTraits<Ordinal,long unsigned int>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,float>
+  : public DirectSerializationTraits<Ordinal,float>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,double>
+  : public DirectSerializationTraits<Ordinal,double>
+{};
+
+// FIXME: How do we know that P1 and P2 are directly serializable?
+template<typename Ordinal, typename P1, typename P2>
+class SerializationTraits<Ordinal,std::pair<P1,P2> >
+  : public DirectSerializationTraits<Ordinal,std::pair<P1,P2> >
+{};
+
+#ifdef HAVE_TEUCHOS_QD
+template<typename Ordinal>
+class SerializationTraits<Ordinal,dd_real>
+  : public DirectSerializationTraits<Ordinal,dd_real>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,qd_real>
+  : public DirectSerializationTraits<Ordinal,qd_real>
+{};
+#endif
+
+#ifdef HAVE_TEUCHOS_COMPLEX
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,std::complex<float> >
+  : public DirectSerializationTraits<Ordinal,std::complex<float> >
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal,std::complex<double> >
+  : public DirectSerializationTraits<Ordinal,std::complex<double> >
+{};
+
+#endif // HAVE_TEUCHOS_COMPLEX
+
+#if defined(HAVE_TEUCHOS_LONG_LONG_INT)
+
+// Partial specialization for long long.
+// On platforms with sizeof(ptrdiff_t) <= sizeof(long long), 
+// this should take care of the ptrdiff_t specialization as well,
+// since we've covered all built-in signed integer types above 
+// with size <= sizeof(long long).
+template<typename Ordinal>
+class SerializationTraits<Ordinal, long long int>
+  : public DirectSerializationTraits<Ordinal, long long int>
+{};
+
+// Partial specialization for unsigned long long.
+// On platforms with sizeof(size_t) <= sizeof(unsigned long long), 
+// this should take care of the size_t specialization as well,
+// since we've covered all built-in unsigned integer types above 
+// with size <= sizeof(unsigned long long).
+template<typename Ordinal>
+class SerializationTraits<Ordinal, unsigned long long int>
+  : public DirectSerializationTraits<Ordinal, unsigned long long int>
+{};
+
+// The C preprocessor does not allow "sizeof(T)" expressions in #if
+// statements, even if T is a built-in type.  Otherwise, we could test
+// for 'sizeof(size_t) > sizeof(unsigned long int)'.  The constants
+// below are defined in the <cstdint> header file.
+#elif SIZE_MAX > ULONG_MAX
+// We already have an unsigned long int specialization above.  If
+// Teuchos support for "long long" is enabled, then we've taken care
+// of all possible lengths of size_t: unsigned (char, short, int,
+// long, long long).  If "long long" is _not_ enabled, we need to
+// check if sizeof(size_t) > sizeof(unsigned long).  If so, then we
+// need a specialization for size_t.  Ditto for ptrdiff_t (which is a
+// signed type of the same length as size_t).
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal, size_t>
+  : public DirectSerializationTraits<Ordinal, size_t>
+{};
+
+template<typename Ordinal>
+class SerializationTraits<Ordinal, ptrdiff_t>
+  : public DirectSerializationTraits<Ordinal, ptrdiff_t>
+{};
+
+#endif // HAVE_TEUCHOS_LONG_LONG_INT
+
+} // namespace Teuchos
+
+#endif // TEUCHOS_SERIALIZATION_TRAITS_HPP
diff -ruN trilinos-11.4.3-clean/packages/teuchos/core/src/Teuchos_Array.hpp.orig trilinos-11.4.3/packages/teuchos/core/src/Teuchos_Array.hpp.orig
--- trilinos-11.4.3-clean/packages/teuchos/core/src/Teuchos_Array.hpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/teuchos/core/src/Teuchos_Array.hpp.orig	2014-02-06 15:48:40.000000000 -0700
@@ -0,0 +1,1616 @@
+// @HEADER
+// ***********************************************************************
+//
+//                    Teuchos: Common Tools Package
+//                 Copyright (2004) Sandia Corporation
+//
+// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
+// license for use of this work by or on behalf of the U.S. Government.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// 1. Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the Corporation nor the names of the
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Questions? Contact Michael A. Heroux (maherou@sandia.gov)
+//
+// ***********************************************************************
+// @HEADER
+
+#ifndef TEUCHOS_ARRAY_H
+#define TEUCHOS_ARRAY_H
+
+/*! \file Teuchos_Array.hpp
+  \brief Templated array class derived from the STL std::vector
+*/
+
+#include "Teuchos_ConfigDefs.hpp"
+#include "Teuchos_Assert.hpp"
+#include "Teuchos_TypeNameTraits.hpp"
+#include "Teuchos_ArrayRCP.hpp"
+#include "Teuchos_Tuple.hpp"
+#include "Teuchos_Utils.hpp"
+#include "Teuchos_Assert.hpp"
+
+
+namespace Teuchos {
+
+
+/** \brief .
+ *
+ * \ingroup teuchos_mem_mng_grp
+ */
+class InvalidArrayStringRepresentation : public std::logic_error
+{public:InvalidArrayStringRepresentation(const std::string& what_arg) : std::logic_error(what_arg) {}};
+
+
+template<typename T> class Array;
+
+
+// 2007/11/30: rabartl: Below, I had to move the initial declaration of these
+// non-member template functions outside of the Array class since the Sun
+// compiler on sass9000 would not accept this.  However, this did work on a
+// number of other compilers such a g++, Intel C++ etc.  The old in-class
+// non-member friend definition is clearly ISO 98 C++ as shown in Item 46 of
+// "Effective C++: Third Edition".  This is not the end of the world but this
+// is something to remember for this platform.
+
+
+/** \brief Equality operator.
+ *
+ * \relates Array
+ */
+template<typename T> inline
+bool operator==( const Array<T> &a1, const Array<T> &a2 );
+
+
+/** \brief Non-equality operator.
+ *
+ * \relates Array
+ */
+template<typename T> inline
+bool operator!=( const Array<T> &a1, const Array<T> &a2 );
+
+
+/** \brief Non-member swap (specializes default std version).
+ *
+ * \relates Array
+ */
+template<typename T> inline
+void swap( Array<T> &a1, Array<T> &a2 );
+
+
+/** \brief Less-than operator.
+ *
+ * \relates Array
+ */
+template<typename T> inline
+bool operator<( const Array<T> &a1, const Array<T> &a2 );
+
+
+/** \brief Less-than-or-equal operator.
+ *
+ * \relates Array
+ */
+template<typename T> inline
+bool operator<=( const Array<T> &a1, const Array<T> &a2 );
+
+
+/** \brief Greater-than operator.
+ *
+ * \relates Array
+ */
+template<typename T> inline
+bool operator>( const Array<T> &a1, const Array<T> &a2 );
+
+
+/** \brief Greater-than-or-equal operator.
+ *
+ * \relates Array
+ */
+template<typename T> inline
+bool operator>=( const Array<T> &a1, const Array<T> &a2 );
+
+
+/** \brief Memory-safe templated array class that encapsulates std::vector.
+ *
+ * ToDo: Finish documentation!
+ *
+ * \section Teuchos_Array_Tuple_sec Tuple Construction
+ *
+ * A user can create a Teuchos::Tuple object to initialize an Array object by
+ * using one of the the convenient overloaded Teuchos::tuple() non-member
+ * constructor functions.  For example, see Array_test.cpp for how this is
+ * done.
+ *
+ * \section Teuchos_Array_DesignDiscussion_sec Design Discussion
+ *
+ * Currently, this class defines implicit conversions to ArrayView.  An
+ * alternative design would be to have Array derive from ArrayView.  This is a
+ * workable design but it would impart some extra storage and runtime
+ * overhead.  Perhaps the most significant overhead would be having the reset
+ * the base ArrayView pointer and size on each and every change in the
+ * structure of the container.  This would import extra overhead beyond a
+ * straight std::vector.
+ *
+ * The big advantage of deriving Array from ArrayView is that this would allow
+ * Array to be used to call some functions taking ArrayView without requiring
+ * an implicit conversion.  While the implicit shallow conversion from Array
+ * to ArrayView is very cheap (just a pointer and int copy), it does cause
+ * problems where the compiler will refuse to perform an implicit conversion
+ * to call a templated function.  However, note that an implicit conversion to
+ * an ArrayView<const T> would always have to be performed no matter what.
+ *
+ * In summary, having Array implicitly convert to ArrayView instead of having
+ * Array derive from ArrayView results in faster and simpler code at the
+ * expense of the compiler refusing the make implicit conversions in some
+ * cases when calling template functions.  Such conversion problems can always
+ * be dealt with by using explicit template arguments.
+ *
+ * \ingroup teuchos_mem_mng_grp
+ */
+template<typename T>
+class Array
+{
+public:
+
+  // 2007/11/30: rabartl: Below, note that the only reason that these
+  // functions are declared as friends is so that the compiler will do
+  // automatic type conversions as described in "Effective C++: Third Edition"
+  // Item 46.
+
+  /** \brief . */
+  template<typename T2>
+  friend bool Teuchos::operator==( const Array<T2> &a1, const Array<T2> &a2 );
+
+  /** \brief . */
+  template<typename T2>
+  friend bool Teuchos::operator!=( const Array<T2> &a1, const Array<T2> &a2 );
+
+  /** \brief . */
+  template<typename T2>
+  friend void swap( Array<T2> &a1, Array<T2> &a2 );
+
+  /** \brief . */
+  template<typename T2>
+  friend bool Teuchos::operator<( const Array<T2> &a1, const Array<T2> &a2 );
+
+  /** \brief . */
+  template<typename T2>
+  friend bool Teuchos::operator<=( const Array<T2> &a1, const Array<T2> &a2 );
+
+  /** \brief . */
+  template<typename T2>
+  friend bool Teuchos::operator>( const Array<T2> &a1, const Array<T2> &a2 );
+
+  /** \brief . */
+  template<typename T2>
+  friend bool Teuchos::operator>=( const Array<T2> &a1, const Array<T2> &a2 );
+
+  /** \name std::vector typedefs */
+  //@{
+
+  /** \brief. */
+  typedef Teuchos_Ordinal Ordinal;
+  /** \brief . */
+  typedef Ordinal size_type;
+  /** \brief . */
+  typedef Ordinal difference_type;
+  /** \brief . */
+  typedef typename std::vector<T>::value_type value_type;
+  /** \brief . */
+  typedef typename std::vector<T>::pointer pointer;
+  /** \brief . */
+  typedef typename std::vector<T>::const_pointer const_pointer;
+  /** \brief . */
+  typedef typename std::vector<T>::reference reference;
+  /** \brief . */
+  typedef typename std::vector<T>::const_reference const_reference;
+  /** \brief . */
+  typedef typename std::vector<T>::allocator_type allocator_type;
+
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  /** \brief . */
+  typedef ArrayRCP<T> iterator;
+  /** \brief . */
+  typedef ArrayRCP<const T> const_iterator;
+  /** \brief . */
+  typedef std::reverse_iterator<iterator> reverse_iterator;
+  /** \brief . */
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+#else
+  /** \brief . */
+  typedef typename std::vector<T>::iterator iterator;
+  /** \brief . */
+  typedef typename std::vector<T>::const_iterator const_iterator;
+  /** \brief . */
+  typedef typename std::vector<T>::reverse_iterator reverse_iterator;
+  /** \brief . */
+  typedef typename std::vector<T>::const_reverse_iterator const_reverse_iterator;
+#endif
+
+
+  //@}
+
+  /** \name All constructors */
+  //@{
+
+  /** \brief . */
+  inline Array();
+  /** \brief . */
+  inline explicit Array(size_type n, const value_type& value = value_type());
+  /** \brief . */
+  inline Array(const Array<T>& x);
+  /** \brief . */
+  template<typename InputIterator>
+  inline Array(InputIterator first, InputIterator last);
+  /** \brief . */
+  inline Array(const ArrayView<const T>& a);
+  /** \brief . */
+  template<int N>
+  inline Array(const Tuple<T,N>& t);
+  /** \brief . */
+  inline ~Array();
+  /** \brief . */
+  inline Array& operator=(const Array<T>& a);
+
+  //@}
+
+  /** \name Other std::vector functions */
+  //@{
+
+  /** \brief . */
+  inline void assign(size_type n, const value_type& val);
+  /** \brief . */
+  template<typename InputIterator>
+  inline void assign(InputIterator first, InputIterator last);
+  /** \brief . */
+  inline iterator begin();
+  /** \brief . */
+  inline iterator end();
+  /** \brief . */
+  inline const_iterator begin() const;
+  /** \brief . */
+  inline const_iterator end() const;
+  /** \brief . */
+  inline reverse_iterator rbegin();
+  /** \brief . */
+  inline reverse_iterator rend();
+  /** \brief . */
+  inline const_reverse_iterator rbegin() const;
+  /** \brief . */
+  inline const_reverse_iterator rend() const;
+  /** \brief . */
+  inline size_type size() const;
+  /** \brief . */
+  inline size_type max_size() const;
+  /** \brief . */
+  inline void resize(size_type new_size, const value_type& x = value_type());
+  /** \brief . */
+  inline size_type capacity() const;
+  /** \brief . */
+  inline bool empty() const;
+  /** \brief . */
+  inline void reserve(size_type n);
+  /** \brief . */
+  inline reference operator[](size_type i);
+  /** \brief . */
+  inline const_reference operator[](size_type i) const;
+  /** \brief . */
+  inline reference at(size_type i);
+  /** \brief . */
+  inline const_reference at(size_type i) const;
+  /** \brief . */
+  inline reference front();
+  /** \brief . */
+  inline const_reference front() const;
+  /** \brief . */
+  inline reference back();
+  /** \brief . */
+  inline const_reference back() const;
+  /** \brief . */
+  inline void push_back(const value_type& x);
+  /** \brief . */
+  inline void pop_back();
+  /** \brief . */
+  inline iterator insert(iterator position, const value_type& x);
+  /** \brief . */
+  inline void insert(iterator position, size_type n, const value_type& x);
+  /** \brief . */
+  template<typename InputIterator>
+  inline void insert(iterator position, InputIterator first, InputIterator last);
+  /** \brief . */
+  inline iterator erase(iterator position);
+  /** \brief . */
+  inline iterator erase(iterator first, iterator last);
+  /** \brief . */
+  inline void swap(Array& x);
+  /** \brief . */
+  inline void clear();
+
+  //@}
+
+  /** \name General non-standard functions. */
+  //@{
+
+  /** \brief Add a new entry at the end of the array.
+   *
+   * Resize to allow space for the new entry.
+   */
+  inline Array<T>& append(const T& x);
+
+  /** \brief Remove the i-th element from the array, with optional
+   * boundschecking.
+   */
+  inline void remove(int i);
+
+  /** \brief Return number of elements in the array.
+   *
+   * Equivalent to size(), but * included for backwards compatibility.
+   */
+  inline int length() const;
+
+  /** \brief Convert an Array to an <tt>std::string</tt> */
+  inline std::string toString() const;
+
+  /** \brief Return true if Array has been compiled with boundschecking on. */
+  inline static bool hasBoundsChecking();
+
+  /** \brief Return a raw pointer to beginning of array or NULL if unsized. */
+  inline T* getRawPtr();
+
+  /** \brief Return a const raw pointer to beginning of array or NULL if unsized. */
+  inline const T* getRawPtr() const;
+
+  //@}
+
+  /** \name Conversions to and from std::vector. */
+  //@{
+
+  /** \brief Copy constructor from an std::vector. */
+  inline Array( const std::vector<T> &v );
+
+  /** \brief Explicit copy conversion to an std::vector. */
+  inline std::vector<T> toVector() const;
+
+  /** \brief Assignment operator for std::vector. */
+  inline Array& operator=( const std::vector<T> &v );
+
+  //@}
+
+  //! @name Views
+  //@{
+
+        /** \brief Return non-const view of a contiguous range of elements.
+         *
+         * <b>Preconditions:</b><ul>
+   * <li><tt>0 <= offset && offset + size <= this->size()</tt>
+         * </ul>
+         *
+         * <b>Postconditions:</b><ul>
+   * <li><tt>returnVal.size() == size</tt>
+         * </ul>
+   *
+   * NOTE: A <tt>size==0</tt> view of even an empty Array is allowed and
+   * returns a <tt>null</tt> view.
+   */
+        inline ArrayView<T> view( size_type offset, size_type size );
+
+        /** \brief Return const view of a contiguous range of elements.
+         *
+         * <b>Preconditions:</b><ul>
+   * <li><tt>0 <= offset && offset + size <= this->size()</tt>
+         * </ul>
+         *
+         * <b>Postconditions:</b><ul>
+   * <li><tt>returnVal.size() == size</tt>
+         * </ul>
+   *
+   * NOTE: A <tt>size==0</tt> view of even an empty Array is allowed and
+   * returns a <tt>null</tt> view.
+   */
+        inline ArrayView<const T> view( size_type offset, size_type size ) const;
+
+        /** \brief Return a non-const view of a contiguous range of elements (calls
+   * view(offset,size)).
+   */
+        inline ArrayView<T> operator()( size_type offset, size_type size );
+
+        /** \brief Return a const view of a contiguous range of elements (calls
+   * view(offset,size)).
+   */
+        inline ArrayView<const T> operator()( size_type offset, size_type size ) const;
+
+        /** \brief Return an non-const ArrayView of *this.
+   *
+   * NOTE: This will return a null ArrayView if this->size() == 0.
+   */
+        inline ArrayView<T> operator()();
+
+        /** \brief Return an const ArrayView of *this.
+   *
+   * NOTE: This will return a null ArrayView if this->size() == 0.
+   */
+        inline ArrayView<const T> operator()() const;
+
+  /** \brief Perform an implicit conversion to a non-const ArrayView (calls
+   * operator()()).
+   */
+        inline operator ArrayView<T>();
+
+  /** \brief Perform an implicit conversion to a non-const ArrayView (calls
+   * operator()()).
+   */
+        inline operator ArrayView<const T>() const;
+
+  //@}
+
+private:
+
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  RCP<std::vector<T> > vec_;
+  mutable ArrayRCP<T> extern_arcp_;
+  mutable ArrayRCP<const T> extern_carcp_;
+#else
+  std::vector<T> vec_;
+#endif
+
+  inline std::vector<T>& vec(
+    bool isStructureBeingModified = false,
+    bool activeIter = false
+    );
+
+  inline const std::vector<T>& vec() const;
+
+  inline typename std::vector<T>::iterator
+  raw_position( iterator position );
+
+  inline void assertIndex(int i) const;
+
+  inline void assertNotNull() const;
+
+};
+
+
+/** \brief Wrap an <tt>RCP<Array<T> ></tt> object as an <tt>ArrayRCP<T></tt>
+ * object.
+ *
+ * \relates ArrayRCP
+ */
+template<class T>
+ArrayRCP<T> arcp( const RCP<Array<T> > &v )
+{
+  if ( is_null(v) || !v->size() )
+    return null;
+  return arcpWithEmbeddedObjPostDestroy<T,RCP<Array<T> > >(
+    &(*v)[0], 0, v->size(),
+    v, false
+    );
+}
+
+
+/** \brief Wrap a <tt>RCP<const Array<T> ></tt> object as an
+ * <tt>ArrayRCP<const T></tt> object.
+ *
+ * \relates ArrayRCP
+ */
+template<class T>
+ArrayRCP<const T> arcp( const RCP<const Array<T> > &v )
+{
+  if ( is_null(v) || !v->size() )
+    return null;
+  return arcpWithEmbeddedObjPostDestroy<const T,RCP<const Array<T> > >(
+    &(*v)[0], 0, v->size(),
+    v, false
+    );
+}
+
+
+/** \brief Wrap an <tt>Array<T></tt> object as a non-owning
+ * <tt>ArrayRCP<T></tt> object.
+ *
+ * \relates ArrayRCP
+ */
+template<class T>
+ArrayRCP<T> arcpFromArray( Array<T> &a )
+{
+  if (a.size() == 0)
+    return null;
+#ifdef TEUCHOS_DEBUG
+  return a.begin(); // Catch dangling reference!
+#else
+  return arcp(a.getRawPtr(), 0, a.size(), false);
+#endif
+}
+
+
+/** \brief Wrap a <tt>const Array<T></tt> object as a non-owning
+ * <tt>ArrayRCP<T></tt> object.
+ *
+ * \relates ArrayRCP
+ */
+template<class T>
+ArrayRCP<const T> arcpFromArray( const Array<T> &a )
+{
+  if (a.size() == 0)
+    return null;
+#ifdef TEUCHOS_DEBUG
+  return a.begin(); // Catch dangling reference!
+#else
+  return arcp(a.getRawPtr(), 0, a.size(), false);
+#endif
+}
+
+
+/** \brief Write an Array to an ostream.
+ *
+ * This prints arrays in the form:
+
+ \verbatim
+
+ { 1.0, 2.0, 3.0 }
+
+ \endverbatim
+
+ * \relates Array
+ */
+template<typename T>
+std::ostream& operator<<(std::ostream& os, const Array<T>& array);
+
+
+/** \brief Return the hash code.
+ *
+ * \relates Array.
+ */
+template<typename T> inline
+int hashCode(const Array<T>& array);
+
+
+/** \brief Copy conversion to an std::vector.
+ *
+ * This function is included for consistency with ArrayView.
+ *
+ * \relates Array.
+ */
+template<typename T> inline
+std::vector<T> createVector( const Array<T> &a );
+
+
+/** \brief Convert an array to a string representation.
+ *
+ * \relates Array
+ */
+template<typename T>
+std::string toString(const Array<T>& array);
+
+
+/** \brief Converts from std::string representation (as created by
+ * <tt>toString()</tt>) back into the array object.
+ *
+ * \param arrayStr [in] The std::string representation of the array (see
+ * below).
+ *
+ * <b>Exceptions:</b> If the std::string representation is not valid, then an
+ * std::exception of type <tt>InvalidArrayStringRepresentation</tt> with be
+ * thrown with a decent error message attached.
+ *
+ * The formating of the std::string <tt>arrayStr</tt> must look like:
+
+ \verbatim
+
+ {  val[0], val[1], val[2], val[3], ..., val[n-1] }
+
+ \endverbatim
+
+ * Currently <tt>operator>>()</tt> is used to convert the entries from their
+ * std::string representation to objects of type <tt>T</tt>.  White space is
+ * unimportant and the parser keys off of ',', '{' and '}' so even newlines
+ * are allowed.  In the future, a traits class might be defined that will
+ * allow for finer-grained control of how the conversion from strings to
+ * values is performed in cases where <tt>operator>>()</tt> does not exist
+ * for certain types.
+ *
+ * <b>Warning!</b> Currently this function only supports reading in flat
+ * array objects for basic types like <tt>bool</tt>, <tt>int</tt>, and
+ * <tt>double</tt> and does not yet support nested arrays (i.e. no
+ * <tt>Array<Array<int> ></tt>) or other such fancy nested types.  Support
+ * for nested arrays and other user defined types <tt>T</tt> can be added in
+ * the future with no impact on user code.  Only the parser for the array
+ * needs to be improved.  More specifically, the current implementation will
+ * not work for any types <tt>T</tt> who's std::string representation contains
+ * the characters <tt>','</tt> or <tt>'}'</tt>.  This implementation can be
+ * modified to allow any such types by watching for the nesting of common
+ * enclosing structures like <tt>[...]</tt>, <tt>{...}</tt> or
+ * <tt>(...)</tt> within each entry of the std::string representation.  However,
+ * this should all just work fine on most machines for the types
+ * <tt>int</tt>, <tt>bool</tt>, <tt>float</tt>, <tt>double</tt> etc.
+ *
+ * <b>Warning!</b> Trying to read in an array in std::string format of doubles in
+ * scientific notation such as <tt>{1e+2,3.53+6,...}</tt> into an array
+ * object such as <tt>Array<int></tt> will not yield the correct results.
+ * If one wants to allow a neutral std::string representation to be read in as an
+ * <tt>Array<double></tt> object or an <tt>Array<int></tt> object, then
+ * general formating such as <tt>{100,3530000,...}</tt> should be used.
+ * This templated function is unable to deal std::complex type conversion issues.
+ *
+ * \relates Array.
+ */
+template<typename T>
+Array<T> fromStringToArray(const std::string& arrayStr);
+
+/** \brief A wrapper around the \c fromStringToArray function
+ * which allows the operator>> to be used on Arrays.
+ *
+ * \relates Array
+ */
+template<typename T>
+std::istringstream& operator>> (std::istringstream& in, Array<T>& array){
+  array = fromStringToArray<T>(in.str());
+  return in;
+}
+
+/** \brief Extracts data from an istringstream object
+ * \note This templated function is necessary for the proper extraction of
+ *       data by the \c fromStringToArray function.
+ * \relates Array.
+ */
+template<typename T> inline
+void extractDataFromISS( std::istringstream& iss, T& data )
+{
+  iss >> data; // Assumes type has operator>>(...) defined!
+}
+
+/** \brief Extracts std::string data from an istringstream object
+ * \note This function overloads the templated \c extractDataFromISS function
+         and is necessary for the proper extraction of std::string objects
+         by the \c fromStringToArray function.
+ * \relates Array.
+ */
+inline
+void extractDataFromISS( std::istringstream& iss, std::string& data )
+{
+  // grab unformatted string.
+  data = iss.str();
+  // remove white space from beginning and end of string.
+  data = Utils::trimWhiteSpace(data);
+}
+
+/**
+ * \brief Get the format that is used for the specialization of the TypeName
+ * traits class for Array.
+ *
+ * The string returned will contain only one
+ * "*" character. The "*" character should then be replaced with the actual
+ * template type of the array.
+ * \relates Array.
+ */
+inline
+std::string getArrayTypeNameTraitsFormat(){
+  return "Array(*)";
+}
+
+
+
+/** \brief TypeNameTraits specialization for Array.
+ *
+ * NOTE: Use of this class requires that either that the type T be defined or
+ * that a TypeNameTraits<T> specialization exists.  In order to not restrict
+ * the use of Array<T> for undefined pointer types (where T=U*), this
+ * TypeNameTraits class specialization will not be used in core Array
+ * functionality.  This might seem trivial except that some MPI
+ * implementations use pointers to undefined structs and if you want to
+ * portably story these undefined struct pointers in an Array, then you can't
+ * use this traits class.  C++ is quite lacking in cases like this.
+ *
+ * \ingroup teuchos_mem_mng_grp
+ */
+template<typename T>
+class TEUCHOS_LIB_DLL_EXPORT TypeNameTraits<Array<T> > {
+public:
+  static std::string name(){
+    std::string formatString = getArrayTypeNameTraitsFormat();
+    size_t starPos = formatString.find("*");
+    std::string prefix = formatString.substr(0,starPos);
+    std::string postFix = formatString.substr(starPos+1);
+    return prefix+TypeNameTraits<T>::name()+postFix;
+  }
+  static std::string concreteName(const Array<T>&)
+    { return name(); }
+};
+
+
+} // namespace Teuchos
+
+
+//
+// Implementation
+//
+
+
+namespace Teuchos {
+
+
+// All constructors
+
+
+template<typename T> inline
+Array<T>::Array()
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  : vec_(rcp(new std::vector<T>()))
+#endif
+{}
+
+
+template<typename T> inline
+Array<T>::Array(size_type n, const value_type& value) :
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  vec_(rcp(new std::vector<T>(n,value)))
+#else
+  vec_(n, value)
+#endif
+{}
+
+
+template<typename T> inline
+Array<T>::Array(const Array<T>& x) :
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  vec_(rcp(new std::vector<T>(*x.vec_)))
+#else
+  vec_(x.vec_)
+#endif
+{}
+
+
+template<typename T> template<typename InputIterator> inline
+Array<T>::Array(InputIterator first, InputIterator last) :
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  vec_(rcp(new std::vector<T>(first, last)))
+#else
+  vec_(first, last)
+#endif
+{}
+
+
+template<typename T> inline
+Array<T>::~Array()
+{}
+
+
+template<typename T> inline
+Array<T>::Array(const ArrayView<const T>& a)
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  : vec_(rcp(new std::vector<T>()))
+#endif
+{
+  insert(begin(), a.begin(), a.end());
+}
+
+
+template<typename T>
+template<int N>
+inline
+Array<T>::Array(const Tuple<T,N>& t)
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  : vec_(rcp(new std::vector<T>()))
+#endif
+{
+  insert(begin(), t.begin(), t.end());
+}
+
+
+template<typename T> inline
+Array<T>& Array<T>::operator=(const Array& a)
+{
+  vec(true) = a.vec();
+  return *this;
+}
+
+
+// Other std::vector functions
+
+
+template<typename T> inline
+void Array<T>::assign(size_type n, const value_type& val)
+{
+  vec(true).assign(n,val);
+}
+
+
+template<typename T> template<typename InputIterator> inline
+void Array<T>::assign(InputIterator first, InputIterator last)
+{
+  vec(true).assign(first,last);
+}
+
+
+template<typename T> inline
+typename Array<T>::iterator
+Array<T>::begin()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  if (is_null(extern_arcp_)) {
+    // Here we must use the same RCP to avoid creating two unrelated RCPNodes!
+    extern_arcp_ = arcp(vec_); // Will be null if vec_ is sized!
+  }
+  // Returning a weak pointer will help to catch dangling references but still
+  // keep the same behavior as optimized code.
+  return extern_arcp_.create_weak();
+#else
+  return vec().begin();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::iterator
+Array<T>::end()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return begin() + size();
+#else
+  return vec().end();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::const_iterator
+Array<T>::begin() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  if (is_null(extern_carcp_)) {
+    extern_carcp_ = const_cast<Array<T>*>(this)->begin();
+  }
+  // Returning a weak pointer will help to catch dangling references but still
+  // keep the same behavior as optimized code.
+  return extern_carcp_.create_weak();
+#else
+  return vec().begin();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::const_iterator
+Array<T>::end() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return begin() + size();
+#else
+  return vec().end();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::reverse_iterator
+Array<T>::rbegin()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return reverse_iterator(end());
+#else
+  return vec().rbegin();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::reverse_iterator
+Array<T>::rend()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return reverse_iterator(begin());
+#else
+  return vec().rend();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::const_reverse_iterator
+Array<T>::rbegin() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return const_reverse_iterator(end());
+#else
+  return vec().rbegin();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::const_reverse_iterator
+Array<T>::rend() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return const_reverse_iterator(begin());
+#else
+  return vec().rend();
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::size_type
+Array<T>::size() const
+{
+  return vec().size();
+}
+
+
+template<typename T> inline
+typename Array<T>::size_type
+Array<T>::max_size() const
+{
+  return std::numeric_limits<size_type>::max();
+}
+
+
+template<typename T> inline
+void
+Array<T>::resize(size_type new_size, const value_type& x)
+{
+  vec(true).resize(new_size,x);
+}
+
+
+template<typename T> inline
+typename Array<T>::size_type
+Array<T>::capacity() const
+{
+  return vec().capacity();
+}
+
+
+template<typename T> inline
+bool Array<T>::empty() const
+{
+  return vec().empty();
+}
+
+
+template<typename T> inline
+void Array<T>::reserve(size_type n)
+{
+  vec(true).reserve(n);
+}
+
+
+template<typename T> inline
+typename Array<T>::reference
+Array<T>::operator[](size_type i)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertIndex(i);
+#endif
+  return vec()[i];
+}
+
+
+template<typename T> inline
+typename Array<T>::const_reference
+Array<T>::operator[](size_type i) const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertIndex(i);
+#endif
+  return vec()[i];
+}
+
+
+template<typename T> inline
+typename Array<T>::reference
+Array<T>::at(size_type i)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertIndex(i);
+#endif
+  return vec().at(i);
+}
+
+
+template<typename T> inline
+typename Array<T>::const_reference
+Array<T>::at(size_type i) const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertIndex(i);
+#endif
+  return vec().at(i);
+}
+
+
+template<typename T> inline
+typename Array<T>::reference
+Array<T>::front()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertNotNull();
+#endif
+  return vec().front();
+}
+
+
+template<typename T> inline
+typename Array<T>::const_reference
+Array<T>::front() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertNotNull();
+#endif
+  return vec().front();
+}
+
+
+template<typename T> inline
+typename Array<T>::reference
+Array<T>::back()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertNotNull();
+#endif
+  return vec().back();
+}
+
+
+template<typename T> inline
+typename Array<T>::const_reference
+Array<T>::back() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertNotNull();
+#endif
+  return vec().back();
+}
+
+
+template<typename T> inline
+void Array<T>::push_back(const value_type& x)
+{
+  vec(true).push_back(x);
+}
+
+
+template<typename T> inline
+void Array<T>::pop_back()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertNotNull();
+#endif
+  vec(true).pop_back();
+}
+
+
+// 2009/11/13:: rabartl: After moving to a full RCPNode tracing and lookup
+// model, I had to how modifying functions like insert(...) and erase(...)
+// work which have active iterators controled by the client and yet need to
+// allow the structure of the container change.  The way these troublesome
+// functions work is that first the raw std::vector iterator is extracted.
+// The function vec(true, true) then deletes the strong iterators but there is
+// still a weak ArrayRCP object that is owned by the client which is being
+// passed into this function.  The issue is that the design of ArrayRCP is
+// such that the RCPNode object is not removed but instead remains in order to
+// perform runtime checking.
+
+
+template<typename T> inline
+typename Array<T>::iterator
+Array<T>::insert(iterator position, const value_type& x)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  // Assert a valid iterator and get vector iterator
+  const typename std::vector<T>::iterator raw_poss = raw_position(position);
+  const difference_type i = position - begin();
+  vec(true, true).insert(raw_poss, x);
+  return begin() + i;
+#else
+  return vec_.insert(position, x);
+#endif
+}
+
+
+template<typename T> inline
+void Array<T>::insert(iterator position, size_type n, const value_type& x)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  const typename std::vector<T>::iterator raw_poss = raw_position(position);
+  vec(true, true).insert(raw_poss, n, x);
+#else
+  return vec_.insert(position, n, x);
+#endif
+}
+
+
+template<typename T> template<typename InputIterator> inline
+void Array<T>::insert(iterator position, InputIterator first, InputIterator last)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  const typename std::vector<T>::iterator raw_poss = raw_position(position);
+  vec(true, true).insert(raw_poss, first, last);
+#else
+  return vec_.insert(position, first, last);
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::iterator
+Array<T>::erase(iterator position)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertNotNull();
+  // Assert a valid iterator and get vector iterator
+  const typename std::vector<T>::iterator raw_poss = raw_position(position);
+  const difference_type i = position - begin();
+  vec(true, true).erase(raw_poss);
+  return begin() + i;
+#else
+  return vec_.erase(position);
+#endif
+}
+
+
+template<typename T> inline
+typename Array<T>::iterator
+Array<T>::erase(iterator first, iterator last)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  if (empty()) {
+    TEUCHOS_ASSERT(first == begin());
+    TEUCHOS_ASSERT(last == end());
+    return end();
+  }
+  assertNotNull();
+  // Assert a valid iterator and get vector iterator
+  const typename std::vector<T>::iterator raw_first = raw_position(first);
+  const typename std::vector<T>::iterator raw_last = raw_position(last);
+  const difference_type i = first - begin();
+  vec(true,true).erase(raw_first,raw_last);
+  return begin() + i;
+#else
+  return vec_.erase(first,last);
+#endif
+}
+
+
+template<typename T> inline
+void Array<T>::swap(Array& x)
+{
+  vec(true).swap(x.vec());
+}
+
+
+template<typename T> inline
+void Array<T>::clear()
+{
+  vec(true).clear();
+}
+
+
+// Non-standard functions
+
+
+template<typename T> inline
+Array<T>& Array<T>::append(const T& x)
+{
+  this->push_back(x);
+  return *this;
+}
+
+
+template<typename T> inline
+void Array<T>::remove(int i)
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  assertIndex(i);
+#endif
+  // Erase the i-th element of this array.
+  this->erase( this->begin() + i );
+}
+
+
+template<typename T> inline
+int Array<T>::length() const
+{
+  return this->size();
+}
+
+
+template<typename T> inline
+std::string Array<T>::toString() const
+{
+  return (*this)().toString();
+}
+
+
+template<typename T> inline
+bool Array<T>::hasBoundsChecking()
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return true;
+#else
+  return false;
+#endif
+}
+
+
+template<typename T> inline
+T* Array<T>::getRawPtr()
+{
+  return ( size() ? &(*this)[0] : 0 );
+}
+
+
+template<typename T> inline
+const T* Array<T>::getRawPtr() const
+{
+  return ( size() ? &(*this)[0] : 0 );
+}
+
+
+// Conversions to and from std::vector
+
+
+template<typename T> inline
+Array<T>::Array( const std::vector<T> &v ) :
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  vec_(new std::vector<T>(v))
+#else
+  vec_(v)
+#endif
+{}
+
+
+template<typename T> inline
+std::vector<T> Array<T>::toVector() const
+{
+  if (!size())
+    return std::vector<T>();
+  std::vector<T> v(begin(),end());
+  return v;
+}
+
+
+template<typename T> inline
+Array<T>& Array<T>::operator=( const std::vector<T> &v )
+{
+  vec(true) = v;
+  return *this;
+}
+
+
+// Views
+
+
+template<typename T> inline
+ArrayView<T> Array<T>::view( size_type offset, size_type size_in )
+{
+  if (size_in) {
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+    return ArrayView<T>(this->begin().persistingView(offset, size_in));
+#else
+    return arrayView( &vec()[offset], size_in );
+#endif
+  }
+  return Teuchos::null;
+}
+
+
+template<typename T> inline
+ArrayView<const T> Array<T>::view( size_type offset, size_type size_in ) const
+{
+  if (size_in) {
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+    return ArrayView<const T>(this->begin().persistingView(offset, size_in));
+#else
+    return arrayView( &vec()[offset], size_in );
+#endif
+  }
+  return Teuchos::null;
+  // NOTE: Above, we use a different implementation to call the const version
+  // of begin() instead of the non-const version.  This sets up a different
+  // ArrayRCP object that gets checked.
+}
+
+
+template<typename T> inline
+ArrayView<T> Array<T>::operator()( size_type offset, size_type size_in )
+{
+  return view(offset, size_in);
+}
+
+
+template<typename T> inline
+ArrayView<const T> Array<T>::operator()( size_type offset, size_type size_in ) const
+{
+  return view(offset, size_in);
+}
+
+
+template<typename T> inline
+ArrayView<T> Array<T>::operator()()
+{
+  if (!size())
+    return null;
+  return this->view(0, size());
+}
+
+
+template<typename T> inline
+ArrayView<const T> Array<T>::operator()() const
+{
+  if (!size())
+    return null;
+  return this->view(0, size());
+}
+
+
+template<typename T> inline
+Array<T>::operator ArrayView<T>()
+{
+  return this->operator()();
+}
+
+
+template<typename T> inline
+Array<T>::operator ArrayView<const T>() const
+{
+  return this->operator()();
+}
+
+
+// private
+
+
+template<typename T>
+std::vector<T>&
+Array<T>::vec( bool isStructureBeingModified, bool activeIter )
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  (void)activeIter;
+  if (isStructureBeingModified) {
+    // Give up my ArrayRCPs used for iterator access since the array we be
+    // getting modifed!  Any clients that have views through weak pointers
+    // better not touch them!
+    extern_arcp_ = null;
+    extern_carcp_ = null;
+  }
+  return *vec_;
+#else
+  // get rid of "unused parameter" warnings
+  (void)isStructureBeingModified;
+  (void)activeIter;
+  return vec_;
+#endif
+}
+
+
+template<typename T> inline
+const std::vector<T>&
+Array<T>::vec() const
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  return *vec_;
+#else
+  return vec_;
+#endif
+}
+
+
+template<typename T> inline
+typename std::vector<T>::iterator
+Array<T>::raw_position( iterator position )
+{
+#ifdef HAVE_TEUCHOS_ARRAY_BOUNDSCHECK
+  const iterator first = this->begin();
+  const iterator last = this->end();
+  TEUCHOS_TEST_FOR_EXCEPTION(
+    !(first <= position && position <= last), DanglingReferenceError,
+    "Error, this iterator is no longer valid for this Aray!"
+    );
+  // Note, above operator<=(...) functions will throw
+  // IncompatibleIteratorsError if the iterators do not share the same
+  // RCP_node object!
+  return vec_->begin() + (position - this->begin());
+#else
+  return position;
+#endif
+}
+
+
+template<typename T> inline
+void Array<T>::assertIndex(int i) const
+{
+  TEUCHOS_TEST_FOR_EXCEPTION(
+    !( 0 <= i && i < length() ), RangeError,
+    "Array<T>::assertIndex(i): i="<<i<<" out of range [0, "<< length() << ")"
+    );
+}
+
+
+template<typename T> inline
+void Array<T>::assertNotNull() const
+{
+  TEUCHOS_TEST_FOR_EXCEPTION(
+    !size(), NullReferenceError,
+    typeName(*this)<<"::assertNotNull(): "
+    "Error, the array has size zero!"
+    );
+}
+
+
+} // namespace Teuchos
+
+
+// Nonmember functions
+
+
+template<typename T> inline
+bool Teuchos::operator==( const Array<T> &a1, const Array<T> &a2 )
+{ return (a1.vec() == a2.vec()); }
+
+
+template<typename T> inline
+bool Teuchos::operator!=( const Array<T> &a1, const Array<T> &a2 )
+{ return (a1.vec() != a2.vec()); }
+
+
+template<typename T> inline
+void Teuchos::swap( Array<T> &a1, Array<T> &a2 )
+{ a1.swap(a2); }
+
+
+template<typename T> inline
+bool Teuchos::operator<( const Array<T> &a1, const Array<T> &a2 )
+{ return (a1.vec() < a2.vec()); }
+
+
+template<typename T> inline
+bool Teuchos::operator<=( const Array<T> &a1, const Array<T> &a2 )
+{ return (a1.vec() <= a2.vec()); }
+
+
+template<typename T> inline
+bool Teuchos::operator>( const Array<T> &a1, const Array<T> &a2 )
+{ return (a1.vec() > a2.vec()); }
+
+
+template<typename T> inline
+bool Teuchos::operator>=( const Array<T> &a1, const Array<T> &a2 )
+{ return (a1.vec() >= a2.vec()); }
+
+
+template<typename T> inline
+std::ostream& Teuchos::operator<<(
+  std::ostream& os, const Array<T>& array
+  )
+{
+  return os << Teuchos::toString(array);
+}
+
+
+template<typename T> inline
+int Teuchos::hashCode(const Array<T>& array)
+{
+  int rtn = hashCode(array.length());
+  for (int i=0; i<array.length(); i++)
+  {
+    rtn += hashCode(array[i]);
+  }
+  return rtn;
+}
+
+
+template<typename T> inline
+std::vector<T> Teuchos::createVector( const Array<T> &a )
+{
+  return a.toVector();
+}
+
+
+template<typename T> inline
+std::string Teuchos::toString(const Array<T>& array)
+{
+  return array.toString();
+}
+
+
+template<typename T>
+Teuchos::Array<T>
+Teuchos::fromStringToArray(const std::string& arrayStr)
+{
+  const std::string str = Utils::trimWhiteSpace(arrayStr);
+  std::istringstream iss(str);
+  TEUCHOS_TEST_FOR_EXCEPTION(
+    ( str[0]!='{' || str[str.length()-1] != '}' )
+    ,InvalidArrayStringRepresentation
+    ,"Error, the std::string:\n"
+    "----------\n"
+    <<str<<
+    "\n----------\n"
+    "is not a valid array represntation!"
+    );
+  char c;
+  c = iss.get(); // Read initial '{'
+  TEUCHOS_TEST_FOR_EXCEPT(c!='{'); // Should not throw!
+  // Now we are ready to begin reading the entries of the array!
+  Array<T> a;
+  while( !iss.eof() ) {
+    // Get the basic entry std::string
+    std::string entryStr;
+    std::getline(iss,entryStr,','); // Get next entry up to ,!
+    // ToDo: Above, we might have to be careful to look for the opening and
+    // closing of parentheses in order not to pick up an internal ',' in the
+    // middle of an entry (for a std::complex number for instance).  The above
+    // implementation assumes that there will be no commas in the middle of
+    // the std::string representation of an entry.  This is certainly true for
+    // the types bool, int, float, and double.
+    //
+    // Trim whitespace from beginning and end
+    entryStr = Utils::trimWhiteSpace(entryStr);
+    TEUCHOS_TEST_FOR_EXCEPTION(
+      0 == entryStr.length(),
+      InvalidArrayStringRepresentation,
+      "Error, the std::string:\n"
+      "----------\n"
+      <<str<<
+      "\n----------\n"
+      "is not a valid array represntation because it has an empty array entry!"
+      );
+    // Remove the final '}' if this is the last entry and we did not
+    // actually terminate the above getline(...) on ','
+    bool found_end = false;
+    if(entryStr[entryStr.length()-1]=='}') {
+      entryStr = entryStr.substr(0,entryStr.length()-1);
+      found_end = true;
+      if( entryStr.length()==0 && a.size()==0 )
+        return a; // This is the empty array "{}" (with any spaces in it!)
+    }
+    // Finally we can convert the entry and add it to the array!
+    std::istringstream entryiss(entryStr);
+    T entry;
+    Teuchos::extractDataFromISS( entryiss, entry );
+    // ToDo: We may need to define a traits class to allow us to specialized
+    // how conversion from a std::string to a object is done!
+    a.push_back(entry);
+    // At the end of the loop body here, if we have reached the last '}'
+    // then the input stream iss should be empty and iss.eof() should be
+    // true, so the loop should terminate.  We put an std::exception test here
+    // just in case something has gone wrong.
+    TEUCHOS_TEST_FOR_EXCEPTION(
+      found_end && !iss.eof()
+      ,InvalidArrayStringRepresentation
+      ,"Error, the std::string:\n"
+      "----------\n"
+      <<str<<
+      "\n----------\n"
+      "is not a valid array represntation!"
+      );
+  }
+  return a;
+}
+
+
+#endif // TEUCHOS_ARRAY_H
diff -ruN trilinos-11.4.3-clean/packages/teuchos/numerics/src/Teuchos_BLAS.cpp trilinos-11.4.3/packages/teuchos/numerics/src/Teuchos_BLAS.cpp
--- trilinos-11.4.3-clean/packages/teuchos/numerics/src/Teuchos_BLAS.cpp	2014-02-06 15:47:09.000000000 -0700
+++ trilinos-11.4.3/packages/teuchos/numerics/src/Teuchos_BLAS.cpp	2014-02-06 15:48:40.000000000 -0700
@@ -111,7 +111,8 @@
 
 //Explicitly instantiating these templates for windows due to an issue with
 //resolving them when linking dlls.
-#ifdef _WIN32
+// JRC #ifdef _WIN32
+#ifdef _MSC_VER
 #  ifdef HAVE_TEUCHOS_COMPLEX
      template BLAS<long int, std::complex<float> >;
      template BLAS<long int, std::complex<double> >;
diff -ruN trilinos-11.4.3-clean/packages/teuchos/numerics/src/Teuchos_BLAS.cpp.orig trilinos-11.4.3/packages/teuchos/numerics/src/Teuchos_BLAS.cpp.orig
--- trilinos-11.4.3-clean/packages/teuchos/numerics/src/Teuchos_BLAS.cpp.orig	1969-12-31 17:00:00.000000000 -0700
+++ trilinos-11.4.3/packages/teuchos/numerics/src/Teuchos_BLAS.cpp.orig	2013-11-21 13:11:09.000000000 -0700
@@ -0,0 +1,530 @@
+// @HEADER
+// ***********************************************************************
+//
+//                    Teuchos: Common Tools Package
+//                 Copyright (2004) Sandia Corporation
+//
+// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
+// license for use of this work by or on behalf of the U.S. Government.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// 1. Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// 2. Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// 3. Neither the name of the Corporation nor the names of the
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Questions? Contact Michael A. Heroux (maherou@sandia.gov)
+//
+// ***********************************************************************
+// @HEADER
+
+#include "Teuchos_BLAS.hpp"
+#include "Teuchos_BLAS_wrappers.hpp"
+
+/* for INTEL_CXML, the second arg may need to be changed to 'one'.  If so
+the appropriate declaration of one will need to be added back into
+functions that include the macro:
+*/
+
+namespace {
+#if defined (INTEL_CXML)
+        unsigned int one=1;
+#endif
+} // namespace
+
+#ifdef CHAR_MACRO
+#undef CHAR_MACRO
+#endif
+#if defined (INTEL_CXML)
+#define CHAR_MACRO(char_var) &char_var, one
+#else
+#define CHAR_MACRO(char_var) &char_var
+#endif
+
+
+const char Teuchos::ESideChar[] = {'L' , 'R' };
+const char Teuchos::ETranspChar[] = {'N' , 'T' , 'C' };
+const char Teuchos::EUploChar[] = {'U' , 'L' };
+const char Teuchos::EDiagChar[] = {'U' , 'N' };
+const char Teuchos::ETypeChar[] = {'G' , 'L', 'U', 'H', 'B', 'Q', 'Z' };
+//const char Teuchos::EFactChar[] = {'F', 'N' };
+//const char Teuchos::ENormChar[] = {'O', 'I' };
+//const char Teuchos::ECompQChar[] = {'N', 'I', 'V' };
+//const char Teuchos::EJobChar[] = {'E', 'V', 'B' };
+//const char Teuchos::EJobSChar[] = {'E', 'S' };
+//const char Teuchos::EJobVSChar[] = {'V', 'N' };
+//const char Teuchos::EHowmnyChar[] = {'A', 'S' };
+//const char Teuchos::ECMachChar[] = {'E', 'S', 'B', 'P', 'N', 'R', 'M', 'U', 'L', 'O' };
+//const char Teuchos::ESortChar[] = {'N', 'S'};
+
+
+namespace {
+
+
+template<typename Scalar>
+Scalar generic_dot(const int n, const Scalar* x, const int incx,
+  const Scalar* y, const int incy)
+{
+  typedef Teuchos::ScalarTraits<Scalar> ST;
+  Scalar dot = 0.0;
+  if (incx==1 && incy==1) {
+    for (int i = 0; i < n; ++i)
+      dot += (*x++)*ST::conjugate(*y++);
+  }
+  else {
+    if (incx < 0)
+      x = x - incx*(n-1);
+    if (incy < 0)
+      y = y - incy*(n-1);
+    for (int i = 0; i < n; ++i, x+=incx, y+=incy)
+      dot += (*x)*ST::conjugate(*y);
+  }
+  return dot;
+}
+
+
+} // namespace
+
+
+namespace Teuchos {
+
+//Explicitly instantiating these templates for windows due to an issue with
+//resolving them when linking dlls.
+#ifdef _WIN32
+#  ifdef HAVE_TEUCHOS_COMPLEX
+     template BLAS<long int, std::complex<float> >;
+     template BLAS<long int, std::complex<double> >;
+#  endif
+     template BLAS<long int, float>;
+     template BLAS<long int, double>;
+#endif
+
+  // *************************** BLAS<int,float> DEFINITIONS ******************************
+
+  void BLAS<int, float>::ROTG(float* da, float* db, float* c, float* s) const
+  { SROTG_F77(da, db, c, s ); }
+
+  void BLAS<int, float>::ROT(const int n, float* dx, const int incx, float* dy, const int incy, float* c, float* s) const
+  { SROT_F77(&n, dx, &incx, dy, &incy, c, s); }
+
+
+  float BLAS<int, float>::ASUM(const int n, const float* x, const int incx) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    return cblas_sasum(n, x, incx);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT)
+    float tmp = SASUM_F77(&n, x, &incx);
+    return tmp;
+#else
+    typedef ScalarTraits<float> ST;
+    float sum = 0.0;
+    if (incx == 1) {
+      for (int i = 0; i < n; ++i)
+        sum += ST::magnitude(*x++);
+    }
+    else {
+      for (int i = 0; i < n; ++i, x+=incx)
+        sum += ST::magnitude(*x);
+    }
+    return sum;
+#endif
+  }
+
+  void BLAS<int, float>::AXPY(const int n, const float alpha, const float* x, const int incx, float* y, const int incy) const
+  { SAXPY_F77(&n, &alpha, x, &incx, y, &incy); }
+
+  void BLAS<int, float>::COPY(const int n, const float* x, const int incx, float* y, const int incy) const
+  { SCOPY_F77(&n, x, &incx, y, &incy); }
+
+  float BLAS<int, float>::DOT(const int n, const float* x, const int incx, const float* y, const int incy) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    return cblas_sdot(n, x, incx, y, incy);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT)
+    return SDOT_F77(&n, x, &incx, y, &incy);
+#else
+    return generic_dot(n, x, incx, y, incy);
+#endif
+  }
+
+  int BLAS<int, float>::IAMAX(const int n, const float* x, const int incx) const
+  { return ISAMAX_F77(&n, x, &incx); }
+
+  float BLAS<int, float>::NRM2(const int n, const float* x, const int incx) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    return cblas_snrm2(n, x, incx);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT)
+    return SNRM2_F77(&n, x, &incx);
+#else
+    return ScalarTraits<float>::squareroot(generic_dot(n, x, incx, x, incx));
+#endif
+  }
+
+  void BLAS<int, float>::SCAL(const int n, const float alpha, float* x, const int incx) const
+  { SSCAL_F77(&n, &alpha, x, &incx); }
+
+  void BLAS<int, float>::GEMV(ETransp trans, const int m, const int n, const float alpha, const float* A, const int lda, const float* x, const int incx, const float beta, float* y, const int incy) const
+  { SGEMV_F77(CHAR_MACRO(ETranspChar[trans]), &m, &n, &alpha, A, &lda, x, &incx, &beta, y, &incy); }
+
+  void BLAS<int, float>::GER(const int m, const int n, const float alpha, const float* x, const int incx, const float* y, const int incy, float* A, const int lda) const
+  { SGER_F77(&m, &n, &alpha, x, &incx, y, &incy, A, &lda); }
+
+  void BLAS<int, float>::TRMV(EUplo uplo, ETransp trans, EDiag diag, const int n, const float* A, const int lda, float* x, const int incx) const
+  { STRMV_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), CHAR_MACRO(EDiagChar[diag]), &n, A, &lda, x, &incx); }
+
+  void BLAS<int, float>::GEMM(ETransp transa, ETransp transb, const int m, const int n, const int k, const float alpha, const float* A, const int lda, const float* B, const int ldb, const float beta, float* C, const int ldc) const
+  { SGEMM_F77(CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(ETranspChar[transb]), &m, &n, &k, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, float>::SYMM(ESide side, EUplo uplo, const int m, const int n, const float alpha, const float* A, const int lda, const float* B, const int ldb, const float beta, float* C, const int ldc) const
+  { SSYMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), &m, &n, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, float>::SYRK(EUplo uplo, ETransp trans, const int n, const int k, const float alpha, const float* A, const int lda, const float beta, float* C, const int ldc) const
+  { SSYRK_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), &n, &k, &alpha, A, &lda, &beta, C, &ldc); }
+
+  void BLAS<int, float>::TRMM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const float alpha, const float* A, const int lda, float* B, const int ldb) const
+  { STRMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+  void BLAS<int, float>::TRSM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const float alpha, const float* A, const int lda, float* B, const int ldb) const
+  { STRSM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+  // *************************** BLAS<int,double> DEFINITIONS ******************************
+
+  void BLAS<int, double>::ROTG(double* da, double* db, double* c, double* s) const
+  { DROTG_F77(da, db, c, s); }
+
+  void BLAS<int, double>::ROT(const int n, double* dx, const int incx, double* dy, const int incy, double* c, double* s) const
+  { DROT_F77(&n, dx, &incx, dy, &incy, c, s); }
+
+  double BLAS<int, double>::ASUM(const int n, const double* x, const int incx) const
+  { return DASUM_F77(&n, x, &incx); }
+
+  void BLAS<int, double>::AXPY(const int n, const double alpha, const double* x, const int incx, double* y, const int incy) const
+  { DAXPY_F77(&n, &alpha, x, &incx, y, &incy); }
+
+  void BLAS<int, double>::COPY(const int n, const double* x, const int incx, double* y, const int incy) const
+  { DCOPY_F77(&n, x, &incx, y, &incy); }
+
+  double BLAS<int, double>::DOT(const int n, const double* x, const int incx, const double* y, const int incy) const
+  {
+    return DDOT_F77(&n, x, &incx, y, &incy);
+  }
+
+  int BLAS<int, double>::IAMAX(const int n, const double* x, const int incx) const
+  { return IDAMAX_F77(&n, x, &incx); }
+
+  double BLAS<int, double>::NRM2(const int n, const double* x, const int incx) const
+  { return DNRM2_F77(&n, x, &incx); }
+
+  void BLAS<int, double>::SCAL(const int n, const double alpha, double* x, const int incx) const
+  { DSCAL_F77(&n, &alpha, x, &incx); }
+
+  void BLAS<int, double>::GEMV(ETransp trans, const int m, const int n, const double alpha, const double* A, const int lda, const double* x, const int incx, const double beta, double* y, const int incy) const
+  { DGEMV_F77(CHAR_MACRO(ETranspChar[trans]), &m, &n, &alpha, A, &lda, x, &incx, &beta, y, &incy); }
+
+  void BLAS<int, double>::GER(const int m, const int n, const double alpha, const double* x, const int incx, const double* y, const int incy, double* A, const int lda) const
+  { DGER_F77(&m, &n, &alpha, x, &incx, y, &incy, A, &lda); }
+
+  void BLAS<int, double>::TRMV(EUplo uplo, ETransp trans, EDiag diag, const int n, const double* A, const int lda, double* x, const int incx) const
+  { DTRMV_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), CHAR_MACRO(EDiagChar[diag]), &n, A, &lda, x, &incx); }
+
+  void BLAS<int, double>::GEMM(ETransp transa, ETransp transb, const int m, const int n, const int k, const double alpha, const double* A, const int lda, const double* B, const int ldb, const double beta, double* C, const int ldc) const
+  { DGEMM_F77(CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(ETranspChar[transb]), &m, &n, &k, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, double>::SYMM(ESide side, EUplo uplo, const int m, const int n, const double alpha, const double* A, const int lda, const double *B, const int ldb, const double beta, double *C, const int ldc) const
+  { DSYMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), &m, &n, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, double>::SYRK(EUplo uplo, ETransp trans, const int n, const int k, const double alpha, const double* A, const int lda, const double beta, double* C, const int ldc) const
+  { DSYRK_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), &n, &k, &alpha, A, &lda, &beta, C, &ldc); }
+
+  void BLAS<int, double>::TRMM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const double alpha, const double* A, const int lda, double* B, const int ldb) const
+  { DTRMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+  void BLAS<int, double>::TRSM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const double alpha, const double* A, const int lda, double* B, const int ldb) const
+  { DTRSM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+#ifdef HAVE_TEUCHOS_COMPLEX
+
+  // *************************** BLAS<int,std::complex<float> > DEFINITIONS ******************************
+
+  void BLAS<int, std::complex<float> >::ROTG(std::complex<float>* da, std::complex<float>* db, float* c, std::complex<float>* s) const
+  { CROTG_F77(da, db, c, s ); }
+
+  void BLAS<int, std::complex<float> >::ROT(const int n, std::complex<float>* dx, const int incx, std::complex<float>* dy, const int incy, float* c, std::complex<float>* s) const
+  { CROT_F77(&n, dx, &incx, dy, &incy, c, s); }
+
+  float BLAS<int, std::complex<float> >::ASUM(const int n, const std::complex<float>* x, const int incx) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    return cblas_scasum(n, x, incx);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT_DOUBLE_RETURN)
+    return (float) SCASUM_F77(&n, x, &incx);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT)
+    return SCASUM_F77(&n, x, &incx);
+#else // Wow, you just plain don't have this routine.
+    // mfh 01 Feb 2013: See www.netlib.org/blas/scasum.f.
+    // I've enhanced this by accumulating in double precision.
+    double result = 0;
+    if (incx == 1) {
+      for (int i = 0; i < n; ++i) {
+	result += std::abs (std::real (x[i])) + std::abs (std::imag (x[i]));
+      }
+    } else {
+      const int nincx = n * incx;
+      for (int i = 0; i < nincx; i += incx) {
+	result += std::abs (std::real (x[i])) + std::abs (std::imag (x[i]));
+      }
+    }
+    return static_cast<float> (result);
+#endif
+  }
+
+  void BLAS<int, std::complex<float> >::AXPY(const int n, const std::complex<float> alpha, const std::complex<float>* x, const int incx, std::complex<float>* y, const int incy) const
+  { CAXPY_F77(&n, &alpha, x, &incx, y, &incy); }
+
+  void BLAS<int, std::complex<float> >::COPY(const int n, const std::complex<float>* x, const int incx, std::complex<float>* y, const int incy) const
+  { CCOPY_F77(&n, x, &incx, y, &incy); }
+
+  std::complex<float> BLAS<int, std::complex<float> >::DOT(const int n, const std::complex<float>* x, const int incx, const std::complex<float>* y, const int incy) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    std::complex<float> z;
+    cblas_cdotc_sub(n,x,incx,y,incy,&z);
+    return z;
+#elif defined(HAVE_COMPLEX_BLAS_PROBLEM) && defined(HAVE_FIXABLE_COMPLEX_BLAS_PROBLEM)
+    std::complex<float> z;
+    CDOT_F77(&z, &n, x, &incx, y, &incy);
+    return z;
+#elif defined(HAVE_TEUCHOS_BLASFLOAT)
+    return CDOT_F77(&n, x, &incx, y, &incy);
+#else // Wow, you just plain don't have this routine.
+    // mfh 01 Feb 2013: See www.netlib.org/blas/cdotc.f.
+    // I've enhanced this by accumulating in double precision.
+    std::complex<double> result (0, 0);
+    if (n >= 0) {
+      if (incx == 1 && incy == 1) {
+	for (int i = 0; i < n; ++i) {
+	  result += std::conj (x[i]) * y[i];
+	}
+      } else {
+	int ix = 0;
+	int iy = 0;
+	if (incx < 0) {
+	  ix = (1-n) * incx;
+	}
+	if (incy < 0) {
+	  iy = (1-n) * incy;    
+	}
+	for (int i = 0; i < n; ++i) {
+	  result += std::conj (x[ix]) * y[iy];
+	  ix += incx;
+	  iy += incy;
+	}
+      }
+    }
+    return static_cast<std::complex<float> > (result);
+#endif
+  }
+
+  int BLAS<int, std::complex<float> >::IAMAX(const int n, const std::complex<float>* x, const int incx) const
+  { return ICAMAX_F77(&n, x, &incx); }
+
+  float BLAS<int, std::complex<float> >::NRM2(const int n, const std::complex<float>* x, const int incx) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    return cblas_scnrm2(n, x, incx);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT_DOUBLE_RETURN)
+    return (float) SCNRM2_F77(&n, x, &incx);
+#elif defined(HAVE_TEUCHOS_BLASFLOAT)
+    return SCNRM2_F77(&n, x, &incx);
+#else // Wow, you just plain don't have this routine.
+    // mfh 01 Feb 2013: See www.netlib.org/blas/scnrm2.f.
+    // I've enhanced this by accumulating in double precision.
+    if (n < 1 || incx < 1) {
+      return 0;
+    } else {
+      double scale = 0;
+      double ssq = 1;
+
+      const int upper = 1 + (n-1)*incx;
+      for (int ix = 0; ix < upper; ix += incx) {
+	// The reference BLAS implementation cleverly scales the
+	// intermediate result. so that even if the square of the norm
+	// would overflow, computing the norm itself does not.  Hence,
+	// "ssq" for "scaled square root."
+	if (std::real (x[ix]) != 0) {
+	  const double temp = std::abs (std::real (x[ix]));
+	  if (scale < temp) {
+	    const double scale_over_temp = scale / temp;
+	    ssq = 1 + ssq * scale_over_temp*scale_over_temp;
+	    // New scaling factor: biggest (in magnitude) real or imaginary part seen thus far.
+	    scale = temp;
+	  } else {
+	    const double temp_over_scale = temp / scale;
+	    ssq = ssq + temp_over_scale*temp_over_scale;
+	  }
+	}
+	if (std::imag (x[ix]) != 0) {
+	  const double temp = std::abs (std::imag (x[ix]));
+	  if (scale < temp) {
+	    const double scale_over_temp = scale / temp;
+	    ssq = 1 + ssq * scale_over_temp*scale_over_temp;
+	    // New scaling factor: biggest (in magnitude) real or imaginary part seen thus far.
+	    scale = temp;
+	  } else {
+	    const double temp_over_scale = temp / scale;
+	    ssq = ssq + temp_over_scale*temp_over_scale;
+	  }
+	}
+      }
+      return static_cast<float> (scale * std::sqrt (ssq));
+    }
+#endif
+  }
+
+  void BLAS<int, std::complex<float> >::SCAL(const int n, const std::complex<float> alpha, std::complex<float>* x, const int incx) const
+  { CSCAL_F77(&n, &alpha, x, &incx); }
+
+  void BLAS<int, std::complex<float> >::GEMV(ETransp trans, const int m, const int n, const std::complex<float> alpha, const std::complex<float>* A, const int lda, const std::complex<float>* x, const int incx, const std::complex<float> beta, std::complex<float>* y, const int incy) const
+  { CGEMV_F77(CHAR_MACRO(ETranspChar[trans]), &m, &n, &alpha, A, &lda, x, &incx, &beta, y, &incy); }
+
+  void BLAS<int, std::complex<float> >::GER(const int m, const int n, const std::complex<float> alpha, const std::complex<float>* x, const int incx, const std::complex<float>* y, const int incy, std::complex<float>* A, const int lda) const
+  { CGER_F77(&m, &n, &alpha, x, &incx, y, &incy, A, &lda); }
+
+  void BLAS<int, std::complex<float> >::TRMV(EUplo uplo, ETransp trans, EDiag diag, const int n, const std::complex<float>* A, const int lda, std::complex<float>* x, const int incx) const
+  { CTRMV_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), CHAR_MACRO(EDiagChar[diag]), &n, A, &lda, x, &incx); }
+
+  void BLAS<int, std::complex<float> >::GEMM(ETransp transa, ETransp transb, const int m, const int n, const int k, const std::complex<float> alpha, const std::complex<float>* A, const int lda, const std::complex<float>* B, const int ldb, const std::complex<float> beta, std::complex<float>* C, const int ldc) const
+  { CGEMM_F77(CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(ETranspChar[transb]), &m, &n, &k, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, std::complex<float> >::SYMM(ESide side, EUplo uplo, const int m, const int n, const std::complex<float> alpha, const std::complex<float>* A, const int lda, const std::complex<float>* B, const int ldb, const std::complex<float> beta, std::complex<float>* C, const int ldc) const
+  { CSYMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), &m, &n, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, std::complex<float> >::SYRK(EUplo uplo, ETransp trans, const int n, const int k, const std::complex<float> alpha, const std::complex<float>* A, const int lda, const std::complex<float> beta, std::complex<float>* C, const int ldc) const
+  { CSYRK_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), &n, &k, &alpha, A, &lda, &beta, C, &ldc); }
+
+  void BLAS<int, std::complex<float> >::TRMM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const std::complex<float> alpha, const std::complex<float>* A, const int lda, std::complex<float>* B, const int ldb) const
+  { CTRMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+  void BLAS<int, std::complex<float> >::TRSM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const std::complex<float> alpha, const std::complex<float>* A, const int lda, std::complex<float>* B, const int ldb) const
+  { CTRSM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+  // *************************** BLAS<int,std::complex<double> > DEFINITIONS ******************************
+
+  void BLAS<int, std::complex<double> >::ROTG(std::complex<double>* da, std::complex<double>* db, double* c, std::complex<double>* s) const
+  { ZROTG_F77(da, db, c, s); }
+
+  void BLAS<int, std::complex<double> >::ROT(const int n, std::complex<double>* dx, const int incx, std::complex<double>* dy, const int incy, double* c, std::complex<double>* s) const
+  { ZROT_F77(&n, dx, &incx, dy, &incy, c, s); }
+
+  double BLAS<int, std::complex<double> >::ASUM(const int n, const std::complex<double>* x, const int incx) const
+  { return ZASUM_F77(&n, x, &incx); }
+
+  void BLAS<int, std::complex<double> >::AXPY(const int n, const std::complex<double> alpha, const std::complex<double>* x, const int incx, std::complex<double>* y, const int incy) const
+  { ZAXPY_F77(&n, &alpha, x, &incx, y, &incy); }
+
+  void BLAS<int, std::complex<double> >::COPY(const int n, const std::complex<double>* x, const int incx, std::complex<double>* y, const int incy) const
+  { ZCOPY_F77(&n, x, &incx, y, &incy); }
+
+  std::complex<double> BLAS<int, std::complex<double> >::DOT(const int n, const std::complex<double>* x, const int incx, const std::complex<double>* y, const int incy) const
+  {
+#if defined(HAVE_TEUCHOS_BLASFLOAT_APPLE_VECLIB_BUGFIX)
+    std::complex<double> z;
+    cblas_zdotc_sub(n,x,incx,y,incy,&z);
+    return z;
+#elif defined(HAVE_COMPLEX_BLAS_PROBLEM)
+#  if defined(HAVE_FIXABLE_COMPLEX_BLAS_PROBLEM)
+    std::complex<double> z;
+    ZDOT_F77(&z, &n, x, &incx, y, &incy);
+    return z;
+#  else 
+    // mfh 01 Feb 2013: Your complex BLAS is broken, but the problem
+    // doesn't have the easy workaround.  I'll just reimplement the
+    // missing routine here.  See www.netlib.org/blas/zdotc.f.
+    std::complex<double> ztemp (0, 0);
+    if (n > 0) {
+      if (incx == 1 && incy == 1) {
+	for (int i = 0; i < n; ++i) {
+	  ztemp += std::conj (x[i]) * y[i];
+	}
+      } else {
+	int ix = 0;
+	int iy = 0;
+	if (incx < 0) {
+	  ix = (1-n)*incx;
+	}
+	if (incy < 0) {
+	  iy = (1-n)*incy;
+	}
+	for (int i = 0; i < n; ++i) {
+	  ztemp += std::conj (x[ix]) * y[iy];
+	  ix += incx;
+	  iy += incy;
+	}
+      }
+    }
+    return ztemp;
+
+#  endif // defined(HAVE_FIXABLE_COMPLEX_BLAS_PROBLEM)
+#else
+    return ZDOT_F77(&n, x, &incx, y, &incy);
+#endif
+  }
+
+  int BLAS<int, std::complex<double> >::IAMAX(const int n, const std::complex<double>* x, const int incx) const
+  { return IZAMAX_F77(&n, x, &incx); }
+
+  double BLAS<int, std::complex<double> >::NRM2(const int n, const std::complex<double>* x, const int incx) const
+  { return ZNRM2_F77(&n, x, &incx); }
+
+  void BLAS<int, std::complex<double> >::SCAL(const int n, const std::complex<double> alpha, std::complex<double>* x, const int incx) const
+  { ZSCAL_F77(&n, &alpha, x, &incx); }
+
+  void BLAS<int, std::complex<double> >::GEMV(ETransp trans, const int m, const int n, const std::complex<double> alpha, const std::complex<double>* A, const int lda, const std::complex<double>* x, const int incx, const std::complex<double> beta, std::complex<double>* y, const int incy) const
+  { ZGEMV_F77(CHAR_MACRO(ETranspChar[trans]), &m, &n, &alpha, A, &lda, x, &incx, &beta, y, &incy); }
+
+  void BLAS<int, std::complex<double> >::GER(const int m, const int n, const std::complex<double> alpha, const std::complex<double>* x, const int incx, const std::complex<double>* y, const int incy, std::complex<double>* A, const int lda) const
+  { ZGER_F77(&m, &n, &alpha, x, &incx, y, &incy, A, &lda); }
+
+  void BLAS<int, std::complex<double> >::TRMV(EUplo uplo, ETransp trans, EDiag diag, const int n, const std::complex<double>* A, const int lda, std::complex<double>* x, const int incx) const
+  { ZTRMV_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), CHAR_MACRO(EDiagChar[diag]), &n, A, &lda, x, &incx); }
+
+  void BLAS<int, std::complex<double> >::GEMM(ETransp transa, ETransp transb, const int m, const int n, const int k, const std::complex<double> alpha, const std::complex<double>* A, const int lda, const std::complex<double>* B, const int ldb, const std::complex<double> beta, std::complex<double>* C, const int ldc) const
+  { ZGEMM_F77(CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(ETranspChar[transb]), &m, &n, &k, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, std::complex<double> >::SYMM(ESide side, EUplo uplo, const int m, const int n, const std::complex<double> alpha, const std::complex<double>* A, const int lda, const std::complex<double> *B, const int ldb, const std::complex<double> beta, std::complex<double> *C, const int ldc) const
+  { ZSYMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), &m, &n, &alpha, A, &lda, B, &ldb, &beta, C, &ldc); }
+
+  void BLAS<int, std::complex<double> >::SYRK(EUplo uplo, ETransp trans, const int n, const int k, const std::complex<double> alpha, const std::complex<double>* A, const int lda, const std::complex<double> beta, std::complex<double>* C, const int ldc) const
+  { ZSYRK_F77(CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[trans]), &n, &k, &alpha, A, &lda, &beta, C, &ldc); }
+
+  void BLAS<int, std::complex<double> >::TRMM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const std::complex<double> alpha, const std::complex<double>* A, const int lda, std::complex<double>* B, const int ldb) const
+  { ZTRMM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+  void BLAS<int, std::complex<double> >::TRSM(ESide side, EUplo uplo, ETransp transa, EDiag diag, const int m, const int n, const std::complex<double> alpha, const std::complex<double>* A, const int lda, std::complex<double>* B, const int ldb) const
+  { ZTRSM_F77(CHAR_MACRO(ESideChar[side]), CHAR_MACRO(EUploChar[uplo]), CHAR_MACRO(ETranspChar[transa]), CHAR_MACRO(EDiagChar[diag]), &m, &n, &alpha, A, &lda, B, &ldb); }
+
+#endif // HAVE_TEUCHOS_COMPLEX
+
+}
diff -ruN trilinos-10.12.2/PackagesList.cmake trilinos-10.12.2-new/PackagesList.cmake
--- trilinos-10.12.2/PackagesList.cmake 2013-11-04 12:29:58.000000000 -0700
+++ trilinos-10.12.2-new/PackagesList.cmake     2014-01-09 21:28:24.742011900 -0700
@@ -184,8 +184,8 @@
 PACKAGE_DISABLE_ON_PLATFORMS(TriKota Windows)
 PACKAGE_DISABLE_ON_PLATFORMS(Pamgen Windows)
 PACKAGE_DISABLE_ON_PLATFORMS(STK Windows)
-PACKAGE_DISABLE_ON_PLATFORMS(SEACAS Windows)
+#PACKAGE_DISABLE_ON_PLATFORMS(SEACAS Windows)
 PACKAGE_DISABLE_ON_PLATFORMS(Anasazi Windows)
 PACKAGE_DISABLE_ON_PLATFORMS(Zoltan Windows)
 PACKAGE_DISABLE_ON_PLATFORMS(Isorropia Windows)
